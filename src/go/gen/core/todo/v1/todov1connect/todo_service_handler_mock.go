package todov1connect

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/koblas/grpc-todo/gen/core/todo/v1/todov1connect.TodoServiceHandler -o ./todo_service_handler_mock.go -n TodoServiceHandlerMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	connect_go "github.com/bufbuild/connect-go"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/koblas/grpc-todo/gen/core/todo/v1"
)

// TodoServiceHandlerMock implements TodoServiceHandler
type TodoServiceHandlerMock struct {
	t minimock.Tester

	funcTodoAdd          func(ctx context.Context, pp1 *connect_go.Request[v1.TodoAddRequest]) (pp2 *connect_go.Response[v1.TodoAddResponse], err error)
	inspectFuncTodoAdd   func(ctx context.Context, pp1 *connect_go.Request[v1.TodoAddRequest])
	afterTodoAddCounter  uint64
	beforeTodoAddCounter uint64
	TodoAddMock          mTodoServiceHandlerMockTodoAdd

	funcTodoDelete          func(ctx context.Context, pp1 *connect_go.Request[v1.TodoDeleteRequest]) (pp2 *connect_go.Response[v1.TodoDeleteResponse], err error)
	inspectFuncTodoDelete   func(ctx context.Context, pp1 *connect_go.Request[v1.TodoDeleteRequest])
	afterTodoDeleteCounter  uint64
	beforeTodoDeleteCounter uint64
	TodoDeleteMock          mTodoServiceHandlerMockTodoDelete

	funcTodoList          func(ctx context.Context, pp1 *connect_go.Request[v1.TodoListRequest]) (pp2 *connect_go.Response[v1.TodoListResponse], err error)
	inspectFuncTodoList   func(ctx context.Context, pp1 *connect_go.Request[v1.TodoListRequest])
	afterTodoListCounter  uint64
	beforeTodoListCounter uint64
	TodoListMock          mTodoServiceHandlerMockTodoList
}

// NewTodoServiceHandlerMock returns a mock for TodoServiceHandler
func NewTodoServiceHandlerMock(t minimock.Tester) *TodoServiceHandlerMock {
	m := &TodoServiceHandlerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.TodoAddMock = mTodoServiceHandlerMockTodoAdd{mock: m}
	m.TodoAddMock.callArgs = []*TodoServiceHandlerMockTodoAddParams{}

	m.TodoDeleteMock = mTodoServiceHandlerMockTodoDelete{mock: m}
	m.TodoDeleteMock.callArgs = []*TodoServiceHandlerMockTodoDeleteParams{}

	m.TodoListMock = mTodoServiceHandlerMockTodoList{mock: m}
	m.TodoListMock.callArgs = []*TodoServiceHandlerMockTodoListParams{}

	return m
}

type mTodoServiceHandlerMockTodoAdd struct {
	mock               *TodoServiceHandlerMock
	defaultExpectation *TodoServiceHandlerMockTodoAddExpectation
	expectations       []*TodoServiceHandlerMockTodoAddExpectation

	callArgs []*TodoServiceHandlerMockTodoAddParams
	mutex    sync.RWMutex
}

// TodoServiceHandlerMockTodoAddExpectation specifies expectation struct of the TodoServiceHandler.TodoAdd
type TodoServiceHandlerMockTodoAddExpectation struct {
	mock    *TodoServiceHandlerMock
	params  *TodoServiceHandlerMockTodoAddParams
	results *TodoServiceHandlerMockTodoAddResults
	Counter uint64
}

// TodoServiceHandlerMockTodoAddParams contains parameters of the TodoServiceHandler.TodoAdd
type TodoServiceHandlerMockTodoAddParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.TodoAddRequest]
}

// TodoServiceHandlerMockTodoAddResults contains results of the TodoServiceHandler.TodoAdd
type TodoServiceHandlerMockTodoAddResults struct {
	pp2 *connect_go.Response[v1.TodoAddResponse]
	err error
}

// Expect sets up expected params for TodoServiceHandler.TodoAdd
func (mmTodoAdd *mTodoServiceHandlerMockTodoAdd) Expect(ctx context.Context, pp1 *connect_go.Request[v1.TodoAddRequest]) *mTodoServiceHandlerMockTodoAdd {
	if mmTodoAdd.mock.funcTodoAdd != nil {
		mmTodoAdd.mock.t.Fatalf("TodoServiceHandlerMock.TodoAdd mock is already set by Set")
	}

	if mmTodoAdd.defaultExpectation == nil {
		mmTodoAdd.defaultExpectation = &TodoServiceHandlerMockTodoAddExpectation{}
	}

	mmTodoAdd.defaultExpectation.params = &TodoServiceHandlerMockTodoAddParams{ctx, pp1}
	for _, e := range mmTodoAdd.expectations {
		if minimock.Equal(e.params, mmTodoAdd.defaultExpectation.params) {
			mmTodoAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTodoAdd.defaultExpectation.params)
		}
	}

	return mmTodoAdd
}

// Inspect accepts an inspector function that has same arguments as the TodoServiceHandler.TodoAdd
func (mmTodoAdd *mTodoServiceHandlerMockTodoAdd) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.TodoAddRequest])) *mTodoServiceHandlerMockTodoAdd {
	if mmTodoAdd.mock.inspectFuncTodoAdd != nil {
		mmTodoAdd.mock.t.Fatalf("Inspect function is already set for TodoServiceHandlerMock.TodoAdd")
	}

	mmTodoAdd.mock.inspectFuncTodoAdd = f

	return mmTodoAdd
}

// Return sets up results that will be returned by TodoServiceHandler.TodoAdd
func (mmTodoAdd *mTodoServiceHandlerMockTodoAdd) Return(pp2 *connect_go.Response[v1.TodoAddResponse], err error) *TodoServiceHandlerMock {
	if mmTodoAdd.mock.funcTodoAdd != nil {
		mmTodoAdd.mock.t.Fatalf("TodoServiceHandlerMock.TodoAdd mock is already set by Set")
	}

	if mmTodoAdd.defaultExpectation == nil {
		mmTodoAdd.defaultExpectation = &TodoServiceHandlerMockTodoAddExpectation{mock: mmTodoAdd.mock}
	}
	mmTodoAdd.defaultExpectation.results = &TodoServiceHandlerMockTodoAddResults{pp2, err}
	return mmTodoAdd.mock
}

// Set uses given function f to mock the TodoServiceHandler.TodoAdd method
func (mmTodoAdd *mTodoServiceHandlerMockTodoAdd) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.TodoAddRequest]) (pp2 *connect_go.Response[v1.TodoAddResponse], err error)) *TodoServiceHandlerMock {
	if mmTodoAdd.defaultExpectation != nil {
		mmTodoAdd.mock.t.Fatalf("Default expectation is already set for the TodoServiceHandler.TodoAdd method")
	}

	if len(mmTodoAdd.expectations) > 0 {
		mmTodoAdd.mock.t.Fatalf("Some expectations are already set for the TodoServiceHandler.TodoAdd method")
	}

	mmTodoAdd.mock.funcTodoAdd = f
	return mmTodoAdd.mock
}

// When sets expectation for the TodoServiceHandler.TodoAdd which will trigger the result defined by the following
// Then helper
func (mmTodoAdd *mTodoServiceHandlerMockTodoAdd) When(ctx context.Context, pp1 *connect_go.Request[v1.TodoAddRequest]) *TodoServiceHandlerMockTodoAddExpectation {
	if mmTodoAdd.mock.funcTodoAdd != nil {
		mmTodoAdd.mock.t.Fatalf("TodoServiceHandlerMock.TodoAdd mock is already set by Set")
	}

	expectation := &TodoServiceHandlerMockTodoAddExpectation{
		mock:   mmTodoAdd.mock,
		params: &TodoServiceHandlerMockTodoAddParams{ctx, pp1},
	}
	mmTodoAdd.expectations = append(mmTodoAdd.expectations, expectation)
	return expectation
}

// Then sets up TodoServiceHandler.TodoAdd return parameters for the expectation previously defined by the When method
func (e *TodoServiceHandlerMockTodoAddExpectation) Then(pp2 *connect_go.Response[v1.TodoAddResponse], err error) *TodoServiceHandlerMock {
	e.results = &TodoServiceHandlerMockTodoAddResults{pp2, err}
	return e.mock
}

// TodoAdd implements TodoServiceHandler
func (mmTodoAdd *TodoServiceHandlerMock) TodoAdd(ctx context.Context, pp1 *connect_go.Request[v1.TodoAddRequest]) (pp2 *connect_go.Response[v1.TodoAddResponse], err error) {
	mm_atomic.AddUint64(&mmTodoAdd.beforeTodoAddCounter, 1)
	defer mm_atomic.AddUint64(&mmTodoAdd.afterTodoAddCounter, 1)

	if mmTodoAdd.inspectFuncTodoAdd != nil {
		mmTodoAdd.inspectFuncTodoAdd(ctx, pp1)
	}

	mm_params := &TodoServiceHandlerMockTodoAddParams{ctx, pp1}

	// Record call args
	mmTodoAdd.TodoAddMock.mutex.Lock()
	mmTodoAdd.TodoAddMock.callArgs = append(mmTodoAdd.TodoAddMock.callArgs, mm_params)
	mmTodoAdd.TodoAddMock.mutex.Unlock()

	for _, e := range mmTodoAdd.TodoAddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmTodoAdd.TodoAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTodoAdd.TodoAddMock.defaultExpectation.Counter, 1)
		mm_want := mmTodoAdd.TodoAddMock.defaultExpectation.params
		mm_got := TodoServiceHandlerMockTodoAddParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTodoAdd.t.Errorf("TodoServiceHandlerMock.TodoAdd got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTodoAdd.TodoAddMock.defaultExpectation.results
		if mm_results == nil {
			mmTodoAdd.t.Fatal("No results are set for the TodoServiceHandlerMock.TodoAdd")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmTodoAdd.funcTodoAdd != nil {
		return mmTodoAdd.funcTodoAdd(ctx, pp1)
	}
	mmTodoAdd.t.Fatalf("Unexpected call to TodoServiceHandlerMock.TodoAdd. %v %v", ctx, pp1)
	return
}

// TodoAddAfterCounter returns a count of finished TodoServiceHandlerMock.TodoAdd invocations
func (mmTodoAdd *TodoServiceHandlerMock) TodoAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTodoAdd.afterTodoAddCounter)
}

// TodoAddBeforeCounter returns a count of TodoServiceHandlerMock.TodoAdd invocations
func (mmTodoAdd *TodoServiceHandlerMock) TodoAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTodoAdd.beforeTodoAddCounter)
}

// Calls returns a list of arguments used in each call to TodoServiceHandlerMock.TodoAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTodoAdd *mTodoServiceHandlerMockTodoAdd) Calls() []*TodoServiceHandlerMockTodoAddParams {
	mmTodoAdd.mutex.RLock()

	argCopy := make([]*TodoServiceHandlerMockTodoAddParams, len(mmTodoAdd.callArgs))
	copy(argCopy, mmTodoAdd.callArgs)

	mmTodoAdd.mutex.RUnlock()

	return argCopy
}

// MinimockTodoAddDone returns true if the count of the TodoAdd invocations corresponds
// the number of defined expectations
func (m *TodoServiceHandlerMock) MinimockTodoAddDone() bool {
	for _, e := range m.TodoAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TodoAddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTodoAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTodoAdd != nil && mm_atomic.LoadUint64(&m.afterTodoAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockTodoAddInspect logs each unmet expectation
func (m *TodoServiceHandlerMock) MinimockTodoAddInspect() {
	for _, e := range m.TodoAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TodoServiceHandlerMock.TodoAdd with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TodoAddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTodoAddCounter) < 1 {
		if m.TodoAddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TodoServiceHandlerMock.TodoAdd")
		} else {
			m.t.Errorf("Expected call to TodoServiceHandlerMock.TodoAdd with params: %#v", *m.TodoAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTodoAdd != nil && mm_atomic.LoadUint64(&m.afterTodoAddCounter) < 1 {
		m.t.Error("Expected call to TodoServiceHandlerMock.TodoAdd")
	}
}

type mTodoServiceHandlerMockTodoDelete struct {
	mock               *TodoServiceHandlerMock
	defaultExpectation *TodoServiceHandlerMockTodoDeleteExpectation
	expectations       []*TodoServiceHandlerMockTodoDeleteExpectation

	callArgs []*TodoServiceHandlerMockTodoDeleteParams
	mutex    sync.RWMutex
}

// TodoServiceHandlerMockTodoDeleteExpectation specifies expectation struct of the TodoServiceHandler.TodoDelete
type TodoServiceHandlerMockTodoDeleteExpectation struct {
	mock    *TodoServiceHandlerMock
	params  *TodoServiceHandlerMockTodoDeleteParams
	results *TodoServiceHandlerMockTodoDeleteResults
	Counter uint64
}

// TodoServiceHandlerMockTodoDeleteParams contains parameters of the TodoServiceHandler.TodoDelete
type TodoServiceHandlerMockTodoDeleteParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.TodoDeleteRequest]
}

// TodoServiceHandlerMockTodoDeleteResults contains results of the TodoServiceHandler.TodoDelete
type TodoServiceHandlerMockTodoDeleteResults struct {
	pp2 *connect_go.Response[v1.TodoDeleteResponse]
	err error
}

// Expect sets up expected params for TodoServiceHandler.TodoDelete
func (mmTodoDelete *mTodoServiceHandlerMockTodoDelete) Expect(ctx context.Context, pp1 *connect_go.Request[v1.TodoDeleteRequest]) *mTodoServiceHandlerMockTodoDelete {
	if mmTodoDelete.mock.funcTodoDelete != nil {
		mmTodoDelete.mock.t.Fatalf("TodoServiceHandlerMock.TodoDelete mock is already set by Set")
	}

	if mmTodoDelete.defaultExpectation == nil {
		mmTodoDelete.defaultExpectation = &TodoServiceHandlerMockTodoDeleteExpectation{}
	}

	mmTodoDelete.defaultExpectation.params = &TodoServiceHandlerMockTodoDeleteParams{ctx, pp1}
	for _, e := range mmTodoDelete.expectations {
		if minimock.Equal(e.params, mmTodoDelete.defaultExpectation.params) {
			mmTodoDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTodoDelete.defaultExpectation.params)
		}
	}

	return mmTodoDelete
}

// Inspect accepts an inspector function that has same arguments as the TodoServiceHandler.TodoDelete
func (mmTodoDelete *mTodoServiceHandlerMockTodoDelete) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.TodoDeleteRequest])) *mTodoServiceHandlerMockTodoDelete {
	if mmTodoDelete.mock.inspectFuncTodoDelete != nil {
		mmTodoDelete.mock.t.Fatalf("Inspect function is already set for TodoServiceHandlerMock.TodoDelete")
	}

	mmTodoDelete.mock.inspectFuncTodoDelete = f

	return mmTodoDelete
}

// Return sets up results that will be returned by TodoServiceHandler.TodoDelete
func (mmTodoDelete *mTodoServiceHandlerMockTodoDelete) Return(pp2 *connect_go.Response[v1.TodoDeleteResponse], err error) *TodoServiceHandlerMock {
	if mmTodoDelete.mock.funcTodoDelete != nil {
		mmTodoDelete.mock.t.Fatalf("TodoServiceHandlerMock.TodoDelete mock is already set by Set")
	}

	if mmTodoDelete.defaultExpectation == nil {
		mmTodoDelete.defaultExpectation = &TodoServiceHandlerMockTodoDeleteExpectation{mock: mmTodoDelete.mock}
	}
	mmTodoDelete.defaultExpectation.results = &TodoServiceHandlerMockTodoDeleteResults{pp2, err}
	return mmTodoDelete.mock
}

// Set uses given function f to mock the TodoServiceHandler.TodoDelete method
func (mmTodoDelete *mTodoServiceHandlerMockTodoDelete) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.TodoDeleteRequest]) (pp2 *connect_go.Response[v1.TodoDeleteResponse], err error)) *TodoServiceHandlerMock {
	if mmTodoDelete.defaultExpectation != nil {
		mmTodoDelete.mock.t.Fatalf("Default expectation is already set for the TodoServiceHandler.TodoDelete method")
	}

	if len(mmTodoDelete.expectations) > 0 {
		mmTodoDelete.mock.t.Fatalf("Some expectations are already set for the TodoServiceHandler.TodoDelete method")
	}

	mmTodoDelete.mock.funcTodoDelete = f
	return mmTodoDelete.mock
}

// When sets expectation for the TodoServiceHandler.TodoDelete which will trigger the result defined by the following
// Then helper
func (mmTodoDelete *mTodoServiceHandlerMockTodoDelete) When(ctx context.Context, pp1 *connect_go.Request[v1.TodoDeleteRequest]) *TodoServiceHandlerMockTodoDeleteExpectation {
	if mmTodoDelete.mock.funcTodoDelete != nil {
		mmTodoDelete.mock.t.Fatalf("TodoServiceHandlerMock.TodoDelete mock is already set by Set")
	}

	expectation := &TodoServiceHandlerMockTodoDeleteExpectation{
		mock:   mmTodoDelete.mock,
		params: &TodoServiceHandlerMockTodoDeleteParams{ctx, pp1},
	}
	mmTodoDelete.expectations = append(mmTodoDelete.expectations, expectation)
	return expectation
}

// Then sets up TodoServiceHandler.TodoDelete return parameters for the expectation previously defined by the When method
func (e *TodoServiceHandlerMockTodoDeleteExpectation) Then(pp2 *connect_go.Response[v1.TodoDeleteResponse], err error) *TodoServiceHandlerMock {
	e.results = &TodoServiceHandlerMockTodoDeleteResults{pp2, err}
	return e.mock
}

// TodoDelete implements TodoServiceHandler
func (mmTodoDelete *TodoServiceHandlerMock) TodoDelete(ctx context.Context, pp1 *connect_go.Request[v1.TodoDeleteRequest]) (pp2 *connect_go.Response[v1.TodoDeleteResponse], err error) {
	mm_atomic.AddUint64(&mmTodoDelete.beforeTodoDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmTodoDelete.afterTodoDeleteCounter, 1)

	if mmTodoDelete.inspectFuncTodoDelete != nil {
		mmTodoDelete.inspectFuncTodoDelete(ctx, pp1)
	}

	mm_params := &TodoServiceHandlerMockTodoDeleteParams{ctx, pp1}

	// Record call args
	mmTodoDelete.TodoDeleteMock.mutex.Lock()
	mmTodoDelete.TodoDeleteMock.callArgs = append(mmTodoDelete.TodoDeleteMock.callArgs, mm_params)
	mmTodoDelete.TodoDeleteMock.mutex.Unlock()

	for _, e := range mmTodoDelete.TodoDeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmTodoDelete.TodoDeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTodoDelete.TodoDeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmTodoDelete.TodoDeleteMock.defaultExpectation.params
		mm_got := TodoServiceHandlerMockTodoDeleteParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTodoDelete.t.Errorf("TodoServiceHandlerMock.TodoDelete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTodoDelete.TodoDeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmTodoDelete.t.Fatal("No results are set for the TodoServiceHandlerMock.TodoDelete")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmTodoDelete.funcTodoDelete != nil {
		return mmTodoDelete.funcTodoDelete(ctx, pp1)
	}
	mmTodoDelete.t.Fatalf("Unexpected call to TodoServiceHandlerMock.TodoDelete. %v %v", ctx, pp1)
	return
}

// TodoDeleteAfterCounter returns a count of finished TodoServiceHandlerMock.TodoDelete invocations
func (mmTodoDelete *TodoServiceHandlerMock) TodoDeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTodoDelete.afterTodoDeleteCounter)
}

// TodoDeleteBeforeCounter returns a count of TodoServiceHandlerMock.TodoDelete invocations
func (mmTodoDelete *TodoServiceHandlerMock) TodoDeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTodoDelete.beforeTodoDeleteCounter)
}

// Calls returns a list of arguments used in each call to TodoServiceHandlerMock.TodoDelete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTodoDelete *mTodoServiceHandlerMockTodoDelete) Calls() []*TodoServiceHandlerMockTodoDeleteParams {
	mmTodoDelete.mutex.RLock()

	argCopy := make([]*TodoServiceHandlerMockTodoDeleteParams, len(mmTodoDelete.callArgs))
	copy(argCopy, mmTodoDelete.callArgs)

	mmTodoDelete.mutex.RUnlock()

	return argCopy
}

// MinimockTodoDeleteDone returns true if the count of the TodoDelete invocations corresponds
// the number of defined expectations
func (m *TodoServiceHandlerMock) MinimockTodoDeleteDone() bool {
	for _, e := range m.TodoDeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TodoDeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTodoDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTodoDelete != nil && mm_atomic.LoadUint64(&m.afterTodoDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockTodoDeleteInspect logs each unmet expectation
func (m *TodoServiceHandlerMock) MinimockTodoDeleteInspect() {
	for _, e := range m.TodoDeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TodoServiceHandlerMock.TodoDelete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TodoDeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTodoDeleteCounter) < 1 {
		if m.TodoDeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TodoServiceHandlerMock.TodoDelete")
		} else {
			m.t.Errorf("Expected call to TodoServiceHandlerMock.TodoDelete with params: %#v", *m.TodoDeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTodoDelete != nil && mm_atomic.LoadUint64(&m.afterTodoDeleteCounter) < 1 {
		m.t.Error("Expected call to TodoServiceHandlerMock.TodoDelete")
	}
}

type mTodoServiceHandlerMockTodoList struct {
	mock               *TodoServiceHandlerMock
	defaultExpectation *TodoServiceHandlerMockTodoListExpectation
	expectations       []*TodoServiceHandlerMockTodoListExpectation

	callArgs []*TodoServiceHandlerMockTodoListParams
	mutex    sync.RWMutex
}

// TodoServiceHandlerMockTodoListExpectation specifies expectation struct of the TodoServiceHandler.TodoList
type TodoServiceHandlerMockTodoListExpectation struct {
	mock    *TodoServiceHandlerMock
	params  *TodoServiceHandlerMockTodoListParams
	results *TodoServiceHandlerMockTodoListResults
	Counter uint64
}

// TodoServiceHandlerMockTodoListParams contains parameters of the TodoServiceHandler.TodoList
type TodoServiceHandlerMockTodoListParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.TodoListRequest]
}

// TodoServiceHandlerMockTodoListResults contains results of the TodoServiceHandler.TodoList
type TodoServiceHandlerMockTodoListResults struct {
	pp2 *connect_go.Response[v1.TodoListResponse]
	err error
}

// Expect sets up expected params for TodoServiceHandler.TodoList
func (mmTodoList *mTodoServiceHandlerMockTodoList) Expect(ctx context.Context, pp1 *connect_go.Request[v1.TodoListRequest]) *mTodoServiceHandlerMockTodoList {
	if mmTodoList.mock.funcTodoList != nil {
		mmTodoList.mock.t.Fatalf("TodoServiceHandlerMock.TodoList mock is already set by Set")
	}

	if mmTodoList.defaultExpectation == nil {
		mmTodoList.defaultExpectation = &TodoServiceHandlerMockTodoListExpectation{}
	}

	mmTodoList.defaultExpectation.params = &TodoServiceHandlerMockTodoListParams{ctx, pp1}
	for _, e := range mmTodoList.expectations {
		if minimock.Equal(e.params, mmTodoList.defaultExpectation.params) {
			mmTodoList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTodoList.defaultExpectation.params)
		}
	}

	return mmTodoList
}

// Inspect accepts an inspector function that has same arguments as the TodoServiceHandler.TodoList
func (mmTodoList *mTodoServiceHandlerMockTodoList) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.TodoListRequest])) *mTodoServiceHandlerMockTodoList {
	if mmTodoList.mock.inspectFuncTodoList != nil {
		mmTodoList.mock.t.Fatalf("Inspect function is already set for TodoServiceHandlerMock.TodoList")
	}

	mmTodoList.mock.inspectFuncTodoList = f

	return mmTodoList
}

// Return sets up results that will be returned by TodoServiceHandler.TodoList
func (mmTodoList *mTodoServiceHandlerMockTodoList) Return(pp2 *connect_go.Response[v1.TodoListResponse], err error) *TodoServiceHandlerMock {
	if mmTodoList.mock.funcTodoList != nil {
		mmTodoList.mock.t.Fatalf("TodoServiceHandlerMock.TodoList mock is already set by Set")
	}

	if mmTodoList.defaultExpectation == nil {
		mmTodoList.defaultExpectation = &TodoServiceHandlerMockTodoListExpectation{mock: mmTodoList.mock}
	}
	mmTodoList.defaultExpectation.results = &TodoServiceHandlerMockTodoListResults{pp2, err}
	return mmTodoList.mock
}

// Set uses given function f to mock the TodoServiceHandler.TodoList method
func (mmTodoList *mTodoServiceHandlerMockTodoList) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.TodoListRequest]) (pp2 *connect_go.Response[v1.TodoListResponse], err error)) *TodoServiceHandlerMock {
	if mmTodoList.defaultExpectation != nil {
		mmTodoList.mock.t.Fatalf("Default expectation is already set for the TodoServiceHandler.TodoList method")
	}

	if len(mmTodoList.expectations) > 0 {
		mmTodoList.mock.t.Fatalf("Some expectations are already set for the TodoServiceHandler.TodoList method")
	}

	mmTodoList.mock.funcTodoList = f
	return mmTodoList.mock
}

// When sets expectation for the TodoServiceHandler.TodoList which will trigger the result defined by the following
// Then helper
func (mmTodoList *mTodoServiceHandlerMockTodoList) When(ctx context.Context, pp1 *connect_go.Request[v1.TodoListRequest]) *TodoServiceHandlerMockTodoListExpectation {
	if mmTodoList.mock.funcTodoList != nil {
		mmTodoList.mock.t.Fatalf("TodoServiceHandlerMock.TodoList mock is already set by Set")
	}

	expectation := &TodoServiceHandlerMockTodoListExpectation{
		mock:   mmTodoList.mock,
		params: &TodoServiceHandlerMockTodoListParams{ctx, pp1},
	}
	mmTodoList.expectations = append(mmTodoList.expectations, expectation)
	return expectation
}

// Then sets up TodoServiceHandler.TodoList return parameters for the expectation previously defined by the When method
func (e *TodoServiceHandlerMockTodoListExpectation) Then(pp2 *connect_go.Response[v1.TodoListResponse], err error) *TodoServiceHandlerMock {
	e.results = &TodoServiceHandlerMockTodoListResults{pp2, err}
	return e.mock
}

// TodoList implements TodoServiceHandler
func (mmTodoList *TodoServiceHandlerMock) TodoList(ctx context.Context, pp1 *connect_go.Request[v1.TodoListRequest]) (pp2 *connect_go.Response[v1.TodoListResponse], err error) {
	mm_atomic.AddUint64(&mmTodoList.beforeTodoListCounter, 1)
	defer mm_atomic.AddUint64(&mmTodoList.afterTodoListCounter, 1)

	if mmTodoList.inspectFuncTodoList != nil {
		mmTodoList.inspectFuncTodoList(ctx, pp1)
	}

	mm_params := &TodoServiceHandlerMockTodoListParams{ctx, pp1}

	// Record call args
	mmTodoList.TodoListMock.mutex.Lock()
	mmTodoList.TodoListMock.callArgs = append(mmTodoList.TodoListMock.callArgs, mm_params)
	mmTodoList.TodoListMock.mutex.Unlock()

	for _, e := range mmTodoList.TodoListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmTodoList.TodoListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTodoList.TodoListMock.defaultExpectation.Counter, 1)
		mm_want := mmTodoList.TodoListMock.defaultExpectation.params
		mm_got := TodoServiceHandlerMockTodoListParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTodoList.t.Errorf("TodoServiceHandlerMock.TodoList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTodoList.TodoListMock.defaultExpectation.results
		if mm_results == nil {
			mmTodoList.t.Fatal("No results are set for the TodoServiceHandlerMock.TodoList")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmTodoList.funcTodoList != nil {
		return mmTodoList.funcTodoList(ctx, pp1)
	}
	mmTodoList.t.Fatalf("Unexpected call to TodoServiceHandlerMock.TodoList. %v %v", ctx, pp1)
	return
}

// TodoListAfterCounter returns a count of finished TodoServiceHandlerMock.TodoList invocations
func (mmTodoList *TodoServiceHandlerMock) TodoListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTodoList.afterTodoListCounter)
}

// TodoListBeforeCounter returns a count of TodoServiceHandlerMock.TodoList invocations
func (mmTodoList *TodoServiceHandlerMock) TodoListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTodoList.beforeTodoListCounter)
}

// Calls returns a list of arguments used in each call to TodoServiceHandlerMock.TodoList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTodoList *mTodoServiceHandlerMockTodoList) Calls() []*TodoServiceHandlerMockTodoListParams {
	mmTodoList.mutex.RLock()

	argCopy := make([]*TodoServiceHandlerMockTodoListParams, len(mmTodoList.callArgs))
	copy(argCopy, mmTodoList.callArgs)

	mmTodoList.mutex.RUnlock()

	return argCopy
}

// MinimockTodoListDone returns true if the count of the TodoList invocations corresponds
// the number of defined expectations
func (m *TodoServiceHandlerMock) MinimockTodoListDone() bool {
	for _, e := range m.TodoListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TodoListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTodoListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTodoList != nil && mm_atomic.LoadUint64(&m.afterTodoListCounter) < 1 {
		return false
	}
	return true
}

// MinimockTodoListInspect logs each unmet expectation
func (m *TodoServiceHandlerMock) MinimockTodoListInspect() {
	for _, e := range m.TodoListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TodoServiceHandlerMock.TodoList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TodoListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTodoListCounter) < 1 {
		if m.TodoListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TodoServiceHandlerMock.TodoList")
		} else {
			m.t.Errorf("Expected call to TodoServiceHandlerMock.TodoList with params: %#v", *m.TodoListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTodoList != nil && mm_atomic.LoadUint64(&m.afterTodoListCounter) < 1 {
		m.t.Error("Expected call to TodoServiceHandlerMock.TodoList")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TodoServiceHandlerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockTodoAddInspect()

		m.MinimockTodoDeleteInspect()

		m.MinimockTodoListInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TodoServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TodoServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockTodoAddDone() &&
		m.MinimockTodoDeleteDone() &&
		m.MinimockTodoListDone()
}
