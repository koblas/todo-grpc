package send_emailv1connect

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/koblas/grpc-todo/gen/core/send_email/v1/send_emailv1connect.SendEmailServiceHandler -o ./send_email_service_handler_mock.go -n SendEmailServiceHandlerMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	connect_go "github.com/bufbuild/connect-go"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/koblas/grpc-todo/gen/core/send_email/v1"
)

// SendEmailServiceHandlerMock implements SendEmailServiceHandler
type SendEmailServiceHandlerMock struct {
	t minimock.Tester

	funcInviteUserMessage          func(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest]) (pp2 *connect_go.Response[v1.InviteUserMessageResponse], err error)
	inspectFuncInviteUserMessage   func(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest])
	afterInviteUserMessageCounter  uint64
	beforeInviteUserMessageCounter uint64
	InviteUserMessageMock          mSendEmailServiceHandlerMockInviteUserMessage

	funcPasswordChangeMessage          func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]) (pp2 *connect_go.Response[v1.PasswordChangeMessageResponse], err error)
	inspectFuncPasswordChangeMessage   func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest])
	afterPasswordChangeMessageCounter  uint64
	beforePasswordChangeMessageCounter uint64
	PasswordChangeMessageMock          mSendEmailServiceHandlerMockPasswordChangeMessage

	funcPasswordRecoveryMessage          func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]) (pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse], err error)
	inspectFuncPasswordRecoveryMessage   func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest])
	afterPasswordRecoveryMessageCounter  uint64
	beforePasswordRecoveryMessageCounter uint64
	PasswordRecoveryMessageMock          mSendEmailServiceHandlerMockPasswordRecoveryMessage

	funcRegisterMessage          func(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest]) (pp2 *connect_go.Response[v1.RegisterMessageResponse], err error)
	inspectFuncRegisterMessage   func(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest])
	afterRegisterMessageCounter  uint64
	beforeRegisterMessageCounter uint64
	RegisterMessageMock          mSendEmailServiceHandlerMockRegisterMessage
}

// NewSendEmailServiceHandlerMock returns a mock for SendEmailServiceHandler
func NewSendEmailServiceHandlerMock(t minimock.Tester) *SendEmailServiceHandlerMock {
	m := &SendEmailServiceHandlerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.InviteUserMessageMock = mSendEmailServiceHandlerMockInviteUserMessage{mock: m}
	m.InviteUserMessageMock.callArgs = []*SendEmailServiceHandlerMockInviteUserMessageParams{}

	m.PasswordChangeMessageMock = mSendEmailServiceHandlerMockPasswordChangeMessage{mock: m}
	m.PasswordChangeMessageMock.callArgs = []*SendEmailServiceHandlerMockPasswordChangeMessageParams{}

	m.PasswordRecoveryMessageMock = mSendEmailServiceHandlerMockPasswordRecoveryMessage{mock: m}
	m.PasswordRecoveryMessageMock.callArgs = []*SendEmailServiceHandlerMockPasswordRecoveryMessageParams{}

	m.RegisterMessageMock = mSendEmailServiceHandlerMockRegisterMessage{mock: m}
	m.RegisterMessageMock.callArgs = []*SendEmailServiceHandlerMockRegisterMessageParams{}

	return m
}

type mSendEmailServiceHandlerMockInviteUserMessage struct {
	mock               *SendEmailServiceHandlerMock
	defaultExpectation *SendEmailServiceHandlerMockInviteUserMessageExpectation
	expectations       []*SendEmailServiceHandlerMockInviteUserMessageExpectation

	callArgs []*SendEmailServiceHandlerMockInviteUserMessageParams
	mutex    sync.RWMutex
}

// SendEmailServiceHandlerMockInviteUserMessageExpectation specifies expectation struct of the SendEmailServiceHandler.InviteUserMessage
type SendEmailServiceHandlerMockInviteUserMessageExpectation struct {
	mock    *SendEmailServiceHandlerMock
	params  *SendEmailServiceHandlerMockInviteUserMessageParams
	results *SendEmailServiceHandlerMockInviteUserMessageResults
	Counter uint64
}

// SendEmailServiceHandlerMockInviteUserMessageParams contains parameters of the SendEmailServiceHandler.InviteUserMessage
type SendEmailServiceHandlerMockInviteUserMessageParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.InviteUserMessageRequest]
}

// SendEmailServiceHandlerMockInviteUserMessageResults contains results of the SendEmailServiceHandler.InviteUserMessage
type SendEmailServiceHandlerMockInviteUserMessageResults struct {
	pp2 *connect_go.Response[v1.InviteUserMessageResponse]
	err error
}

// Expect sets up expected params for SendEmailServiceHandler.InviteUserMessage
func (mmInviteUserMessage *mSendEmailServiceHandlerMockInviteUserMessage) Expect(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest]) *mSendEmailServiceHandlerMockInviteUserMessage {
	if mmInviteUserMessage.mock.funcInviteUserMessage != nil {
		mmInviteUserMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.InviteUserMessage mock is already set by Set")
	}

	if mmInviteUserMessage.defaultExpectation == nil {
		mmInviteUserMessage.defaultExpectation = &SendEmailServiceHandlerMockInviteUserMessageExpectation{}
	}

	mmInviteUserMessage.defaultExpectation.params = &SendEmailServiceHandlerMockInviteUserMessageParams{ctx, pp1}
	for _, e := range mmInviteUserMessage.expectations {
		if minimock.Equal(e.params, mmInviteUserMessage.defaultExpectation.params) {
			mmInviteUserMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInviteUserMessage.defaultExpectation.params)
		}
	}

	return mmInviteUserMessage
}

// Inspect accepts an inspector function that has same arguments as the SendEmailServiceHandler.InviteUserMessage
func (mmInviteUserMessage *mSendEmailServiceHandlerMockInviteUserMessage) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest])) *mSendEmailServiceHandlerMockInviteUserMessage {
	if mmInviteUserMessage.mock.inspectFuncInviteUserMessage != nil {
		mmInviteUserMessage.mock.t.Fatalf("Inspect function is already set for SendEmailServiceHandlerMock.InviteUserMessage")
	}

	mmInviteUserMessage.mock.inspectFuncInviteUserMessage = f

	return mmInviteUserMessage
}

// Return sets up results that will be returned by SendEmailServiceHandler.InviteUserMessage
func (mmInviteUserMessage *mSendEmailServiceHandlerMockInviteUserMessage) Return(pp2 *connect_go.Response[v1.InviteUserMessageResponse], err error) *SendEmailServiceHandlerMock {
	if mmInviteUserMessage.mock.funcInviteUserMessage != nil {
		mmInviteUserMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.InviteUserMessage mock is already set by Set")
	}

	if mmInviteUserMessage.defaultExpectation == nil {
		mmInviteUserMessage.defaultExpectation = &SendEmailServiceHandlerMockInviteUserMessageExpectation{mock: mmInviteUserMessage.mock}
	}
	mmInviteUserMessage.defaultExpectation.results = &SendEmailServiceHandlerMockInviteUserMessageResults{pp2, err}
	return mmInviteUserMessage.mock
}

// Set uses given function f to mock the SendEmailServiceHandler.InviteUserMessage method
func (mmInviteUserMessage *mSendEmailServiceHandlerMockInviteUserMessage) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest]) (pp2 *connect_go.Response[v1.InviteUserMessageResponse], err error)) *SendEmailServiceHandlerMock {
	if mmInviteUserMessage.defaultExpectation != nil {
		mmInviteUserMessage.mock.t.Fatalf("Default expectation is already set for the SendEmailServiceHandler.InviteUserMessage method")
	}

	if len(mmInviteUserMessage.expectations) > 0 {
		mmInviteUserMessage.mock.t.Fatalf("Some expectations are already set for the SendEmailServiceHandler.InviteUserMessage method")
	}

	mmInviteUserMessage.mock.funcInviteUserMessage = f
	return mmInviteUserMessage.mock
}

// When sets expectation for the SendEmailServiceHandler.InviteUserMessage which will trigger the result defined by the following
// Then helper
func (mmInviteUserMessage *mSendEmailServiceHandlerMockInviteUserMessage) When(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest]) *SendEmailServiceHandlerMockInviteUserMessageExpectation {
	if mmInviteUserMessage.mock.funcInviteUserMessage != nil {
		mmInviteUserMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.InviteUserMessage mock is already set by Set")
	}

	expectation := &SendEmailServiceHandlerMockInviteUserMessageExpectation{
		mock:   mmInviteUserMessage.mock,
		params: &SendEmailServiceHandlerMockInviteUserMessageParams{ctx, pp1},
	}
	mmInviteUserMessage.expectations = append(mmInviteUserMessage.expectations, expectation)
	return expectation
}

// Then sets up SendEmailServiceHandler.InviteUserMessage return parameters for the expectation previously defined by the When method
func (e *SendEmailServiceHandlerMockInviteUserMessageExpectation) Then(pp2 *connect_go.Response[v1.InviteUserMessageResponse], err error) *SendEmailServiceHandlerMock {
	e.results = &SendEmailServiceHandlerMockInviteUserMessageResults{pp2, err}
	return e.mock
}

// InviteUserMessage implements SendEmailServiceHandler
func (mmInviteUserMessage *SendEmailServiceHandlerMock) InviteUserMessage(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest]) (pp2 *connect_go.Response[v1.InviteUserMessageResponse], err error) {
	mm_atomic.AddUint64(&mmInviteUserMessage.beforeInviteUserMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmInviteUserMessage.afterInviteUserMessageCounter, 1)

	if mmInviteUserMessage.inspectFuncInviteUserMessage != nil {
		mmInviteUserMessage.inspectFuncInviteUserMessage(ctx, pp1)
	}

	mm_params := &SendEmailServiceHandlerMockInviteUserMessageParams{ctx, pp1}

	// Record call args
	mmInviteUserMessage.InviteUserMessageMock.mutex.Lock()
	mmInviteUserMessage.InviteUserMessageMock.callArgs = append(mmInviteUserMessage.InviteUserMessageMock.callArgs, mm_params)
	mmInviteUserMessage.InviteUserMessageMock.mutex.Unlock()

	for _, e := range mmInviteUserMessage.InviteUserMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmInviteUserMessage.InviteUserMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInviteUserMessage.InviteUserMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmInviteUserMessage.InviteUserMessageMock.defaultExpectation.params
		mm_got := SendEmailServiceHandlerMockInviteUserMessageParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInviteUserMessage.t.Errorf("SendEmailServiceHandlerMock.InviteUserMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInviteUserMessage.InviteUserMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmInviteUserMessage.t.Fatal("No results are set for the SendEmailServiceHandlerMock.InviteUserMessage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmInviteUserMessage.funcInviteUserMessage != nil {
		return mmInviteUserMessage.funcInviteUserMessage(ctx, pp1)
	}
	mmInviteUserMessage.t.Fatalf("Unexpected call to SendEmailServiceHandlerMock.InviteUserMessage. %v %v", ctx, pp1)
	return
}

// InviteUserMessageAfterCounter returns a count of finished SendEmailServiceHandlerMock.InviteUserMessage invocations
func (mmInviteUserMessage *SendEmailServiceHandlerMock) InviteUserMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInviteUserMessage.afterInviteUserMessageCounter)
}

// InviteUserMessageBeforeCounter returns a count of SendEmailServiceHandlerMock.InviteUserMessage invocations
func (mmInviteUserMessage *SendEmailServiceHandlerMock) InviteUserMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInviteUserMessage.beforeInviteUserMessageCounter)
}

// Calls returns a list of arguments used in each call to SendEmailServiceHandlerMock.InviteUserMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInviteUserMessage *mSendEmailServiceHandlerMockInviteUserMessage) Calls() []*SendEmailServiceHandlerMockInviteUserMessageParams {
	mmInviteUserMessage.mutex.RLock()

	argCopy := make([]*SendEmailServiceHandlerMockInviteUserMessageParams, len(mmInviteUserMessage.callArgs))
	copy(argCopy, mmInviteUserMessage.callArgs)

	mmInviteUserMessage.mutex.RUnlock()

	return argCopy
}

// MinimockInviteUserMessageDone returns true if the count of the InviteUserMessage invocations corresponds
// the number of defined expectations
func (m *SendEmailServiceHandlerMock) MinimockInviteUserMessageDone() bool {
	for _, e := range m.InviteUserMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InviteUserMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInviteUserMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInviteUserMessage != nil && mm_atomic.LoadUint64(&m.afterInviteUserMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockInviteUserMessageInspect logs each unmet expectation
func (m *SendEmailServiceHandlerMock) MinimockInviteUserMessageInspect() {
	for _, e := range m.InviteUserMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SendEmailServiceHandlerMock.InviteUserMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InviteUserMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInviteUserMessageCounter) < 1 {
		if m.InviteUserMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SendEmailServiceHandlerMock.InviteUserMessage")
		} else {
			m.t.Errorf("Expected call to SendEmailServiceHandlerMock.InviteUserMessage with params: %#v", *m.InviteUserMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInviteUserMessage != nil && mm_atomic.LoadUint64(&m.afterInviteUserMessageCounter) < 1 {
		m.t.Error("Expected call to SendEmailServiceHandlerMock.InviteUserMessage")
	}
}

type mSendEmailServiceHandlerMockPasswordChangeMessage struct {
	mock               *SendEmailServiceHandlerMock
	defaultExpectation *SendEmailServiceHandlerMockPasswordChangeMessageExpectation
	expectations       []*SendEmailServiceHandlerMockPasswordChangeMessageExpectation

	callArgs []*SendEmailServiceHandlerMockPasswordChangeMessageParams
	mutex    sync.RWMutex
}

// SendEmailServiceHandlerMockPasswordChangeMessageExpectation specifies expectation struct of the SendEmailServiceHandler.PasswordChangeMessage
type SendEmailServiceHandlerMockPasswordChangeMessageExpectation struct {
	mock    *SendEmailServiceHandlerMock
	params  *SendEmailServiceHandlerMockPasswordChangeMessageParams
	results *SendEmailServiceHandlerMockPasswordChangeMessageResults
	Counter uint64
}

// SendEmailServiceHandlerMockPasswordChangeMessageParams contains parameters of the SendEmailServiceHandler.PasswordChangeMessage
type SendEmailServiceHandlerMockPasswordChangeMessageParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]
}

// SendEmailServiceHandlerMockPasswordChangeMessageResults contains results of the SendEmailServiceHandler.PasswordChangeMessage
type SendEmailServiceHandlerMockPasswordChangeMessageResults struct {
	pp2 *connect_go.Response[v1.PasswordChangeMessageResponse]
	err error
}

// Expect sets up expected params for SendEmailServiceHandler.PasswordChangeMessage
func (mmPasswordChangeMessage *mSendEmailServiceHandlerMockPasswordChangeMessage) Expect(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]) *mSendEmailServiceHandlerMockPasswordChangeMessage {
	if mmPasswordChangeMessage.mock.funcPasswordChangeMessage != nil {
		mmPasswordChangeMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.PasswordChangeMessage mock is already set by Set")
	}

	if mmPasswordChangeMessage.defaultExpectation == nil {
		mmPasswordChangeMessage.defaultExpectation = &SendEmailServiceHandlerMockPasswordChangeMessageExpectation{}
	}

	mmPasswordChangeMessage.defaultExpectation.params = &SendEmailServiceHandlerMockPasswordChangeMessageParams{ctx, pp1}
	for _, e := range mmPasswordChangeMessage.expectations {
		if minimock.Equal(e.params, mmPasswordChangeMessage.defaultExpectation.params) {
			mmPasswordChangeMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPasswordChangeMessage.defaultExpectation.params)
		}
	}

	return mmPasswordChangeMessage
}

// Inspect accepts an inspector function that has same arguments as the SendEmailServiceHandler.PasswordChangeMessage
func (mmPasswordChangeMessage *mSendEmailServiceHandlerMockPasswordChangeMessage) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest])) *mSendEmailServiceHandlerMockPasswordChangeMessage {
	if mmPasswordChangeMessage.mock.inspectFuncPasswordChangeMessage != nil {
		mmPasswordChangeMessage.mock.t.Fatalf("Inspect function is already set for SendEmailServiceHandlerMock.PasswordChangeMessage")
	}

	mmPasswordChangeMessage.mock.inspectFuncPasswordChangeMessage = f

	return mmPasswordChangeMessage
}

// Return sets up results that will be returned by SendEmailServiceHandler.PasswordChangeMessage
func (mmPasswordChangeMessage *mSendEmailServiceHandlerMockPasswordChangeMessage) Return(pp2 *connect_go.Response[v1.PasswordChangeMessageResponse], err error) *SendEmailServiceHandlerMock {
	if mmPasswordChangeMessage.mock.funcPasswordChangeMessage != nil {
		mmPasswordChangeMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.PasswordChangeMessage mock is already set by Set")
	}

	if mmPasswordChangeMessage.defaultExpectation == nil {
		mmPasswordChangeMessage.defaultExpectation = &SendEmailServiceHandlerMockPasswordChangeMessageExpectation{mock: mmPasswordChangeMessage.mock}
	}
	mmPasswordChangeMessage.defaultExpectation.results = &SendEmailServiceHandlerMockPasswordChangeMessageResults{pp2, err}
	return mmPasswordChangeMessage.mock
}

// Set uses given function f to mock the SendEmailServiceHandler.PasswordChangeMessage method
func (mmPasswordChangeMessage *mSendEmailServiceHandlerMockPasswordChangeMessage) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]) (pp2 *connect_go.Response[v1.PasswordChangeMessageResponse], err error)) *SendEmailServiceHandlerMock {
	if mmPasswordChangeMessage.defaultExpectation != nil {
		mmPasswordChangeMessage.mock.t.Fatalf("Default expectation is already set for the SendEmailServiceHandler.PasswordChangeMessage method")
	}

	if len(mmPasswordChangeMessage.expectations) > 0 {
		mmPasswordChangeMessage.mock.t.Fatalf("Some expectations are already set for the SendEmailServiceHandler.PasswordChangeMessage method")
	}

	mmPasswordChangeMessage.mock.funcPasswordChangeMessage = f
	return mmPasswordChangeMessage.mock
}

// When sets expectation for the SendEmailServiceHandler.PasswordChangeMessage which will trigger the result defined by the following
// Then helper
func (mmPasswordChangeMessage *mSendEmailServiceHandlerMockPasswordChangeMessage) When(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]) *SendEmailServiceHandlerMockPasswordChangeMessageExpectation {
	if mmPasswordChangeMessage.mock.funcPasswordChangeMessage != nil {
		mmPasswordChangeMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.PasswordChangeMessage mock is already set by Set")
	}

	expectation := &SendEmailServiceHandlerMockPasswordChangeMessageExpectation{
		mock:   mmPasswordChangeMessage.mock,
		params: &SendEmailServiceHandlerMockPasswordChangeMessageParams{ctx, pp1},
	}
	mmPasswordChangeMessage.expectations = append(mmPasswordChangeMessage.expectations, expectation)
	return expectation
}

// Then sets up SendEmailServiceHandler.PasswordChangeMessage return parameters for the expectation previously defined by the When method
func (e *SendEmailServiceHandlerMockPasswordChangeMessageExpectation) Then(pp2 *connect_go.Response[v1.PasswordChangeMessageResponse], err error) *SendEmailServiceHandlerMock {
	e.results = &SendEmailServiceHandlerMockPasswordChangeMessageResults{pp2, err}
	return e.mock
}

// PasswordChangeMessage implements SendEmailServiceHandler
func (mmPasswordChangeMessage *SendEmailServiceHandlerMock) PasswordChangeMessage(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]) (pp2 *connect_go.Response[v1.PasswordChangeMessageResponse], err error) {
	mm_atomic.AddUint64(&mmPasswordChangeMessage.beforePasswordChangeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmPasswordChangeMessage.afterPasswordChangeMessageCounter, 1)

	if mmPasswordChangeMessage.inspectFuncPasswordChangeMessage != nil {
		mmPasswordChangeMessage.inspectFuncPasswordChangeMessage(ctx, pp1)
	}

	mm_params := &SendEmailServiceHandlerMockPasswordChangeMessageParams{ctx, pp1}

	// Record call args
	mmPasswordChangeMessage.PasswordChangeMessageMock.mutex.Lock()
	mmPasswordChangeMessage.PasswordChangeMessageMock.callArgs = append(mmPasswordChangeMessage.PasswordChangeMessageMock.callArgs, mm_params)
	mmPasswordChangeMessage.PasswordChangeMessageMock.mutex.Unlock()

	for _, e := range mmPasswordChangeMessage.PasswordChangeMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmPasswordChangeMessage.PasswordChangeMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPasswordChangeMessage.PasswordChangeMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmPasswordChangeMessage.PasswordChangeMessageMock.defaultExpectation.params
		mm_got := SendEmailServiceHandlerMockPasswordChangeMessageParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPasswordChangeMessage.t.Errorf("SendEmailServiceHandlerMock.PasswordChangeMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPasswordChangeMessage.PasswordChangeMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmPasswordChangeMessage.t.Fatal("No results are set for the SendEmailServiceHandlerMock.PasswordChangeMessage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmPasswordChangeMessage.funcPasswordChangeMessage != nil {
		return mmPasswordChangeMessage.funcPasswordChangeMessage(ctx, pp1)
	}
	mmPasswordChangeMessage.t.Fatalf("Unexpected call to SendEmailServiceHandlerMock.PasswordChangeMessage. %v %v", ctx, pp1)
	return
}

// PasswordChangeMessageAfterCounter returns a count of finished SendEmailServiceHandlerMock.PasswordChangeMessage invocations
func (mmPasswordChangeMessage *SendEmailServiceHandlerMock) PasswordChangeMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPasswordChangeMessage.afterPasswordChangeMessageCounter)
}

// PasswordChangeMessageBeforeCounter returns a count of SendEmailServiceHandlerMock.PasswordChangeMessage invocations
func (mmPasswordChangeMessage *SendEmailServiceHandlerMock) PasswordChangeMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPasswordChangeMessage.beforePasswordChangeMessageCounter)
}

// Calls returns a list of arguments used in each call to SendEmailServiceHandlerMock.PasswordChangeMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPasswordChangeMessage *mSendEmailServiceHandlerMockPasswordChangeMessage) Calls() []*SendEmailServiceHandlerMockPasswordChangeMessageParams {
	mmPasswordChangeMessage.mutex.RLock()

	argCopy := make([]*SendEmailServiceHandlerMockPasswordChangeMessageParams, len(mmPasswordChangeMessage.callArgs))
	copy(argCopy, mmPasswordChangeMessage.callArgs)

	mmPasswordChangeMessage.mutex.RUnlock()

	return argCopy
}

// MinimockPasswordChangeMessageDone returns true if the count of the PasswordChangeMessage invocations corresponds
// the number of defined expectations
func (m *SendEmailServiceHandlerMock) MinimockPasswordChangeMessageDone() bool {
	for _, e := range m.PasswordChangeMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PasswordChangeMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPasswordChangeMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPasswordChangeMessage != nil && mm_atomic.LoadUint64(&m.afterPasswordChangeMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockPasswordChangeMessageInspect logs each unmet expectation
func (m *SendEmailServiceHandlerMock) MinimockPasswordChangeMessageInspect() {
	for _, e := range m.PasswordChangeMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SendEmailServiceHandlerMock.PasswordChangeMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PasswordChangeMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPasswordChangeMessageCounter) < 1 {
		if m.PasswordChangeMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SendEmailServiceHandlerMock.PasswordChangeMessage")
		} else {
			m.t.Errorf("Expected call to SendEmailServiceHandlerMock.PasswordChangeMessage with params: %#v", *m.PasswordChangeMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPasswordChangeMessage != nil && mm_atomic.LoadUint64(&m.afterPasswordChangeMessageCounter) < 1 {
		m.t.Error("Expected call to SendEmailServiceHandlerMock.PasswordChangeMessage")
	}
}

type mSendEmailServiceHandlerMockPasswordRecoveryMessage struct {
	mock               *SendEmailServiceHandlerMock
	defaultExpectation *SendEmailServiceHandlerMockPasswordRecoveryMessageExpectation
	expectations       []*SendEmailServiceHandlerMockPasswordRecoveryMessageExpectation

	callArgs []*SendEmailServiceHandlerMockPasswordRecoveryMessageParams
	mutex    sync.RWMutex
}

// SendEmailServiceHandlerMockPasswordRecoveryMessageExpectation specifies expectation struct of the SendEmailServiceHandler.PasswordRecoveryMessage
type SendEmailServiceHandlerMockPasswordRecoveryMessageExpectation struct {
	mock    *SendEmailServiceHandlerMock
	params  *SendEmailServiceHandlerMockPasswordRecoveryMessageParams
	results *SendEmailServiceHandlerMockPasswordRecoveryMessageResults
	Counter uint64
}

// SendEmailServiceHandlerMockPasswordRecoveryMessageParams contains parameters of the SendEmailServiceHandler.PasswordRecoveryMessage
type SendEmailServiceHandlerMockPasswordRecoveryMessageParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]
}

// SendEmailServiceHandlerMockPasswordRecoveryMessageResults contains results of the SendEmailServiceHandler.PasswordRecoveryMessage
type SendEmailServiceHandlerMockPasswordRecoveryMessageResults struct {
	pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse]
	err error
}

// Expect sets up expected params for SendEmailServiceHandler.PasswordRecoveryMessage
func (mmPasswordRecoveryMessage *mSendEmailServiceHandlerMockPasswordRecoveryMessage) Expect(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]) *mSendEmailServiceHandlerMockPasswordRecoveryMessage {
	if mmPasswordRecoveryMessage.mock.funcPasswordRecoveryMessage != nil {
		mmPasswordRecoveryMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.PasswordRecoveryMessage mock is already set by Set")
	}

	if mmPasswordRecoveryMessage.defaultExpectation == nil {
		mmPasswordRecoveryMessage.defaultExpectation = &SendEmailServiceHandlerMockPasswordRecoveryMessageExpectation{}
	}

	mmPasswordRecoveryMessage.defaultExpectation.params = &SendEmailServiceHandlerMockPasswordRecoveryMessageParams{ctx, pp1}
	for _, e := range mmPasswordRecoveryMessage.expectations {
		if minimock.Equal(e.params, mmPasswordRecoveryMessage.defaultExpectation.params) {
			mmPasswordRecoveryMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPasswordRecoveryMessage.defaultExpectation.params)
		}
	}

	return mmPasswordRecoveryMessage
}

// Inspect accepts an inspector function that has same arguments as the SendEmailServiceHandler.PasswordRecoveryMessage
func (mmPasswordRecoveryMessage *mSendEmailServiceHandlerMockPasswordRecoveryMessage) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest])) *mSendEmailServiceHandlerMockPasswordRecoveryMessage {
	if mmPasswordRecoveryMessage.mock.inspectFuncPasswordRecoveryMessage != nil {
		mmPasswordRecoveryMessage.mock.t.Fatalf("Inspect function is already set for SendEmailServiceHandlerMock.PasswordRecoveryMessage")
	}

	mmPasswordRecoveryMessage.mock.inspectFuncPasswordRecoveryMessage = f

	return mmPasswordRecoveryMessage
}

// Return sets up results that will be returned by SendEmailServiceHandler.PasswordRecoveryMessage
func (mmPasswordRecoveryMessage *mSendEmailServiceHandlerMockPasswordRecoveryMessage) Return(pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse], err error) *SendEmailServiceHandlerMock {
	if mmPasswordRecoveryMessage.mock.funcPasswordRecoveryMessage != nil {
		mmPasswordRecoveryMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.PasswordRecoveryMessage mock is already set by Set")
	}

	if mmPasswordRecoveryMessage.defaultExpectation == nil {
		mmPasswordRecoveryMessage.defaultExpectation = &SendEmailServiceHandlerMockPasswordRecoveryMessageExpectation{mock: mmPasswordRecoveryMessage.mock}
	}
	mmPasswordRecoveryMessage.defaultExpectation.results = &SendEmailServiceHandlerMockPasswordRecoveryMessageResults{pp2, err}
	return mmPasswordRecoveryMessage.mock
}

// Set uses given function f to mock the SendEmailServiceHandler.PasswordRecoveryMessage method
func (mmPasswordRecoveryMessage *mSendEmailServiceHandlerMockPasswordRecoveryMessage) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]) (pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse], err error)) *SendEmailServiceHandlerMock {
	if mmPasswordRecoveryMessage.defaultExpectation != nil {
		mmPasswordRecoveryMessage.mock.t.Fatalf("Default expectation is already set for the SendEmailServiceHandler.PasswordRecoveryMessage method")
	}

	if len(mmPasswordRecoveryMessage.expectations) > 0 {
		mmPasswordRecoveryMessage.mock.t.Fatalf("Some expectations are already set for the SendEmailServiceHandler.PasswordRecoveryMessage method")
	}

	mmPasswordRecoveryMessage.mock.funcPasswordRecoveryMessage = f
	return mmPasswordRecoveryMessage.mock
}

// When sets expectation for the SendEmailServiceHandler.PasswordRecoveryMessage which will trigger the result defined by the following
// Then helper
func (mmPasswordRecoveryMessage *mSendEmailServiceHandlerMockPasswordRecoveryMessage) When(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]) *SendEmailServiceHandlerMockPasswordRecoveryMessageExpectation {
	if mmPasswordRecoveryMessage.mock.funcPasswordRecoveryMessage != nil {
		mmPasswordRecoveryMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.PasswordRecoveryMessage mock is already set by Set")
	}

	expectation := &SendEmailServiceHandlerMockPasswordRecoveryMessageExpectation{
		mock:   mmPasswordRecoveryMessage.mock,
		params: &SendEmailServiceHandlerMockPasswordRecoveryMessageParams{ctx, pp1},
	}
	mmPasswordRecoveryMessage.expectations = append(mmPasswordRecoveryMessage.expectations, expectation)
	return expectation
}

// Then sets up SendEmailServiceHandler.PasswordRecoveryMessage return parameters for the expectation previously defined by the When method
func (e *SendEmailServiceHandlerMockPasswordRecoveryMessageExpectation) Then(pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse], err error) *SendEmailServiceHandlerMock {
	e.results = &SendEmailServiceHandlerMockPasswordRecoveryMessageResults{pp2, err}
	return e.mock
}

// PasswordRecoveryMessage implements SendEmailServiceHandler
func (mmPasswordRecoveryMessage *SendEmailServiceHandlerMock) PasswordRecoveryMessage(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]) (pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse], err error) {
	mm_atomic.AddUint64(&mmPasswordRecoveryMessage.beforePasswordRecoveryMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmPasswordRecoveryMessage.afterPasswordRecoveryMessageCounter, 1)

	if mmPasswordRecoveryMessage.inspectFuncPasswordRecoveryMessage != nil {
		mmPasswordRecoveryMessage.inspectFuncPasswordRecoveryMessage(ctx, pp1)
	}

	mm_params := &SendEmailServiceHandlerMockPasswordRecoveryMessageParams{ctx, pp1}

	// Record call args
	mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.mutex.Lock()
	mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.callArgs = append(mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.callArgs, mm_params)
	mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.mutex.Unlock()

	for _, e := range mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.defaultExpectation.params
		mm_got := SendEmailServiceHandlerMockPasswordRecoveryMessageParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPasswordRecoveryMessage.t.Errorf("SendEmailServiceHandlerMock.PasswordRecoveryMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmPasswordRecoveryMessage.t.Fatal("No results are set for the SendEmailServiceHandlerMock.PasswordRecoveryMessage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmPasswordRecoveryMessage.funcPasswordRecoveryMessage != nil {
		return mmPasswordRecoveryMessage.funcPasswordRecoveryMessage(ctx, pp1)
	}
	mmPasswordRecoveryMessage.t.Fatalf("Unexpected call to SendEmailServiceHandlerMock.PasswordRecoveryMessage. %v %v", ctx, pp1)
	return
}

// PasswordRecoveryMessageAfterCounter returns a count of finished SendEmailServiceHandlerMock.PasswordRecoveryMessage invocations
func (mmPasswordRecoveryMessage *SendEmailServiceHandlerMock) PasswordRecoveryMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPasswordRecoveryMessage.afterPasswordRecoveryMessageCounter)
}

// PasswordRecoveryMessageBeforeCounter returns a count of SendEmailServiceHandlerMock.PasswordRecoveryMessage invocations
func (mmPasswordRecoveryMessage *SendEmailServiceHandlerMock) PasswordRecoveryMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPasswordRecoveryMessage.beforePasswordRecoveryMessageCounter)
}

// Calls returns a list of arguments used in each call to SendEmailServiceHandlerMock.PasswordRecoveryMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPasswordRecoveryMessage *mSendEmailServiceHandlerMockPasswordRecoveryMessage) Calls() []*SendEmailServiceHandlerMockPasswordRecoveryMessageParams {
	mmPasswordRecoveryMessage.mutex.RLock()

	argCopy := make([]*SendEmailServiceHandlerMockPasswordRecoveryMessageParams, len(mmPasswordRecoveryMessage.callArgs))
	copy(argCopy, mmPasswordRecoveryMessage.callArgs)

	mmPasswordRecoveryMessage.mutex.RUnlock()

	return argCopy
}

// MinimockPasswordRecoveryMessageDone returns true if the count of the PasswordRecoveryMessage invocations corresponds
// the number of defined expectations
func (m *SendEmailServiceHandlerMock) MinimockPasswordRecoveryMessageDone() bool {
	for _, e := range m.PasswordRecoveryMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PasswordRecoveryMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPasswordRecoveryMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPasswordRecoveryMessage != nil && mm_atomic.LoadUint64(&m.afterPasswordRecoveryMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockPasswordRecoveryMessageInspect logs each unmet expectation
func (m *SendEmailServiceHandlerMock) MinimockPasswordRecoveryMessageInspect() {
	for _, e := range m.PasswordRecoveryMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SendEmailServiceHandlerMock.PasswordRecoveryMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PasswordRecoveryMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPasswordRecoveryMessageCounter) < 1 {
		if m.PasswordRecoveryMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SendEmailServiceHandlerMock.PasswordRecoveryMessage")
		} else {
			m.t.Errorf("Expected call to SendEmailServiceHandlerMock.PasswordRecoveryMessage with params: %#v", *m.PasswordRecoveryMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPasswordRecoveryMessage != nil && mm_atomic.LoadUint64(&m.afterPasswordRecoveryMessageCounter) < 1 {
		m.t.Error("Expected call to SendEmailServiceHandlerMock.PasswordRecoveryMessage")
	}
}

type mSendEmailServiceHandlerMockRegisterMessage struct {
	mock               *SendEmailServiceHandlerMock
	defaultExpectation *SendEmailServiceHandlerMockRegisterMessageExpectation
	expectations       []*SendEmailServiceHandlerMockRegisterMessageExpectation

	callArgs []*SendEmailServiceHandlerMockRegisterMessageParams
	mutex    sync.RWMutex
}

// SendEmailServiceHandlerMockRegisterMessageExpectation specifies expectation struct of the SendEmailServiceHandler.RegisterMessage
type SendEmailServiceHandlerMockRegisterMessageExpectation struct {
	mock    *SendEmailServiceHandlerMock
	params  *SendEmailServiceHandlerMockRegisterMessageParams
	results *SendEmailServiceHandlerMockRegisterMessageResults
	Counter uint64
}

// SendEmailServiceHandlerMockRegisterMessageParams contains parameters of the SendEmailServiceHandler.RegisterMessage
type SendEmailServiceHandlerMockRegisterMessageParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.RegisterMessageRequest]
}

// SendEmailServiceHandlerMockRegisterMessageResults contains results of the SendEmailServiceHandler.RegisterMessage
type SendEmailServiceHandlerMockRegisterMessageResults struct {
	pp2 *connect_go.Response[v1.RegisterMessageResponse]
	err error
}

// Expect sets up expected params for SendEmailServiceHandler.RegisterMessage
func (mmRegisterMessage *mSendEmailServiceHandlerMockRegisterMessage) Expect(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest]) *mSendEmailServiceHandlerMockRegisterMessage {
	if mmRegisterMessage.mock.funcRegisterMessage != nil {
		mmRegisterMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.RegisterMessage mock is already set by Set")
	}

	if mmRegisterMessage.defaultExpectation == nil {
		mmRegisterMessage.defaultExpectation = &SendEmailServiceHandlerMockRegisterMessageExpectation{}
	}

	mmRegisterMessage.defaultExpectation.params = &SendEmailServiceHandlerMockRegisterMessageParams{ctx, pp1}
	for _, e := range mmRegisterMessage.expectations {
		if minimock.Equal(e.params, mmRegisterMessage.defaultExpectation.params) {
			mmRegisterMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterMessage.defaultExpectation.params)
		}
	}

	return mmRegisterMessage
}

// Inspect accepts an inspector function that has same arguments as the SendEmailServiceHandler.RegisterMessage
func (mmRegisterMessage *mSendEmailServiceHandlerMockRegisterMessage) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest])) *mSendEmailServiceHandlerMockRegisterMessage {
	if mmRegisterMessage.mock.inspectFuncRegisterMessage != nil {
		mmRegisterMessage.mock.t.Fatalf("Inspect function is already set for SendEmailServiceHandlerMock.RegisterMessage")
	}

	mmRegisterMessage.mock.inspectFuncRegisterMessage = f

	return mmRegisterMessage
}

// Return sets up results that will be returned by SendEmailServiceHandler.RegisterMessage
func (mmRegisterMessage *mSendEmailServiceHandlerMockRegisterMessage) Return(pp2 *connect_go.Response[v1.RegisterMessageResponse], err error) *SendEmailServiceHandlerMock {
	if mmRegisterMessage.mock.funcRegisterMessage != nil {
		mmRegisterMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.RegisterMessage mock is already set by Set")
	}

	if mmRegisterMessage.defaultExpectation == nil {
		mmRegisterMessage.defaultExpectation = &SendEmailServiceHandlerMockRegisterMessageExpectation{mock: mmRegisterMessage.mock}
	}
	mmRegisterMessage.defaultExpectation.results = &SendEmailServiceHandlerMockRegisterMessageResults{pp2, err}
	return mmRegisterMessage.mock
}

// Set uses given function f to mock the SendEmailServiceHandler.RegisterMessage method
func (mmRegisterMessage *mSendEmailServiceHandlerMockRegisterMessage) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest]) (pp2 *connect_go.Response[v1.RegisterMessageResponse], err error)) *SendEmailServiceHandlerMock {
	if mmRegisterMessage.defaultExpectation != nil {
		mmRegisterMessage.mock.t.Fatalf("Default expectation is already set for the SendEmailServiceHandler.RegisterMessage method")
	}

	if len(mmRegisterMessage.expectations) > 0 {
		mmRegisterMessage.mock.t.Fatalf("Some expectations are already set for the SendEmailServiceHandler.RegisterMessage method")
	}

	mmRegisterMessage.mock.funcRegisterMessage = f
	return mmRegisterMessage.mock
}

// When sets expectation for the SendEmailServiceHandler.RegisterMessage which will trigger the result defined by the following
// Then helper
func (mmRegisterMessage *mSendEmailServiceHandlerMockRegisterMessage) When(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest]) *SendEmailServiceHandlerMockRegisterMessageExpectation {
	if mmRegisterMessage.mock.funcRegisterMessage != nil {
		mmRegisterMessage.mock.t.Fatalf("SendEmailServiceHandlerMock.RegisterMessage mock is already set by Set")
	}

	expectation := &SendEmailServiceHandlerMockRegisterMessageExpectation{
		mock:   mmRegisterMessage.mock,
		params: &SendEmailServiceHandlerMockRegisterMessageParams{ctx, pp1},
	}
	mmRegisterMessage.expectations = append(mmRegisterMessage.expectations, expectation)
	return expectation
}

// Then sets up SendEmailServiceHandler.RegisterMessage return parameters for the expectation previously defined by the When method
func (e *SendEmailServiceHandlerMockRegisterMessageExpectation) Then(pp2 *connect_go.Response[v1.RegisterMessageResponse], err error) *SendEmailServiceHandlerMock {
	e.results = &SendEmailServiceHandlerMockRegisterMessageResults{pp2, err}
	return e.mock
}

// RegisterMessage implements SendEmailServiceHandler
func (mmRegisterMessage *SendEmailServiceHandlerMock) RegisterMessage(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest]) (pp2 *connect_go.Response[v1.RegisterMessageResponse], err error) {
	mm_atomic.AddUint64(&mmRegisterMessage.beforeRegisterMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterMessage.afterRegisterMessageCounter, 1)

	if mmRegisterMessage.inspectFuncRegisterMessage != nil {
		mmRegisterMessage.inspectFuncRegisterMessage(ctx, pp1)
	}

	mm_params := &SendEmailServiceHandlerMockRegisterMessageParams{ctx, pp1}

	// Record call args
	mmRegisterMessage.RegisterMessageMock.mutex.Lock()
	mmRegisterMessage.RegisterMessageMock.callArgs = append(mmRegisterMessage.RegisterMessageMock.callArgs, mm_params)
	mmRegisterMessage.RegisterMessageMock.mutex.Unlock()

	for _, e := range mmRegisterMessage.RegisterMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRegisterMessage.RegisterMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterMessage.RegisterMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterMessage.RegisterMessageMock.defaultExpectation.params
		mm_got := SendEmailServiceHandlerMockRegisterMessageParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterMessage.t.Errorf("SendEmailServiceHandlerMock.RegisterMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterMessage.RegisterMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterMessage.t.Fatal("No results are set for the SendEmailServiceHandlerMock.RegisterMessage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRegisterMessage.funcRegisterMessage != nil {
		return mmRegisterMessage.funcRegisterMessage(ctx, pp1)
	}
	mmRegisterMessage.t.Fatalf("Unexpected call to SendEmailServiceHandlerMock.RegisterMessage. %v %v", ctx, pp1)
	return
}

// RegisterMessageAfterCounter returns a count of finished SendEmailServiceHandlerMock.RegisterMessage invocations
func (mmRegisterMessage *SendEmailServiceHandlerMock) RegisterMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterMessage.afterRegisterMessageCounter)
}

// RegisterMessageBeforeCounter returns a count of SendEmailServiceHandlerMock.RegisterMessage invocations
func (mmRegisterMessage *SendEmailServiceHandlerMock) RegisterMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterMessage.beforeRegisterMessageCounter)
}

// Calls returns a list of arguments used in each call to SendEmailServiceHandlerMock.RegisterMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterMessage *mSendEmailServiceHandlerMockRegisterMessage) Calls() []*SendEmailServiceHandlerMockRegisterMessageParams {
	mmRegisterMessage.mutex.RLock()

	argCopy := make([]*SendEmailServiceHandlerMockRegisterMessageParams, len(mmRegisterMessage.callArgs))
	copy(argCopy, mmRegisterMessage.callArgs)

	mmRegisterMessage.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterMessageDone returns true if the count of the RegisterMessage invocations corresponds
// the number of defined expectations
func (m *SendEmailServiceHandlerMock) MinimockRegisterMessageDone() bool {
	for _, e := range m.RegisterMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterMessage != nil && mm_atomic.LoadUint64(&m.afterRegisterMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterMessageInspect logs each unmet expectation
func (m *SendEmailServiceHandlerMock) MinimockRegisterMessageInspect() {
	for _, e := range m.RegisterMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SendEmailServiceHandlerMock.RegisterMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterMessageCounter) < 1 {
		if m.RegisterMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SendEmailServiceHandlerMock.RegisterMessage")
		} else {
			m.t.Errorf("Expected call to SendEmailServiceHandlerMock.RegisterMessage with params: %#v", *m.RegisterMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterMessage != nil && mm_atomic.LoadUint64(&m.afterRegisterMessageCounter) < 1 {
		m.t.Error("Expected call to SendEmailServiceHandlerMock.RegisterMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SendEmailServiceHandlerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockInviteUserMessageInspect()

		m.MinimockPasswordChangeMessageInspect()

		m.MinimockPasswordRecoveryMessageInspect()

		m.MinimockRegisterMessageInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SendEmailServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SendEmailServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockInviteUserMessageDone() &&
		m.MinimockPasswordChangeMessageDone() &&
		m.MinimockPasswordRecoveryMessageDone() &&
		m.MinimockRegisterMessageDone()
}
