package send_emailv1connect

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/koblas/grpc-todo/gen/core/send_email/v1/send_emailv1connect.SendEmailServiceClient -o ./send_email_service_client_mock.go -n SendEmailServiceClientMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	connect_go "github.com/bufbuild/connect-go"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/koblas/grpc-todo/gen/core/send_email/v1"
)

// SendEmailServiceClientMock implements SendEmailServiceClient
type SendEmailServiceClientMock struct {
	t minimock.Tester

	funcInviteUserMessage          func(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest]) (pp2 *connect_go.Response[v1.InviteUserMessageResponse], err error)
	inspectFuncInviteUserMessage   func(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest])
	afterInviteUserMessageCounter  uint64
	beforeInviteUserMessageCounter uint64
	InviteUserMessageMock          mSendEmailServiceClientMockInviteUserMessage

	funcPasswordChangeMessage          func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]) (pp2 *connect_go.Response[v1.PasswordChangeMessageResponse], err error)
	inspectFuncPasswordChangeMessage   func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest])
	afterPasswordChangeMessageCounter  uint64
	beforePasswordChangeMessageCounter uint64
	PasswordChangeMessageMock          mSendEmailServiceClientMockPasswordChangeMessage

	funcPasswordRecoveryMessage          func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]) (pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse], err error)
	inspectFuncPasswordRecoveryMessage   func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest])
	afterPasswordRecoveryMessageCounter  uint64
	beforePasswordRecoveryMessageCounter uint64
	PasswordRecoveryMessageMock          mSendEmailServiceClientMockPasswordRecoveryMessage

	funcRegisterMessage          func(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest]) (pp2 *connect_go.Response[v1.RegisterMessageResponse], err error)
	inspectFuncRegisterMessage   func(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest])
	afterRegisterMessageCounter  uint64
	beforeRegisterMessageCounter uint64
	RegisterMessageMock          mSendEmailServiceClientMockRegisterMessage
}

// NewSendEmailServiceClientMock returns a mock for SendEmailServiceClient
func NewSendEmailServiceClientMock(t minimock.Tester) *SendEmailServiceClientMock {
	m := &SendEmailServiceClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.InviteUserMessageMock = mSendEmailServiceClientMockInviteUserMessage{mock: m}
	m.InviteUserMessageMock.callArgs = []*SendEmailServiceClientMockInviteUserMessageParams{}

	m.PasswordChangeMessageMock = mSendEmailServiceClientMockPasswordChangeMessage{mock: m}
	m.PasswordChangeMessageMock.callArgs = []*SendEmailServiceClientMockPasswordChangeMessageParams{}

	m.PasswordRecoveryMessageMock = mSendEmailServiceClientMockPasswordRecoveryMessage{mock: m}
	m.PasswordRecoveryMessageMock.callArgs = []*SendEmailServiceClientMockPasswordRecoveryMessageParams{}

	m.RegisterMessageMock = mSendEmailServiceClientMockRegisterMessage{mock: m}
	m.RegisterMessageMock.callArgs = []*SendEmailServiceClientMockRegisterMessageParams{}

	return m
}

type mSendEmailServiceClientMockInviteUserMessage struct {
	mock               *SendEmailServiceClientMock
	defaultExpectation *SendEmailServiceClientMockInviteUserMessageExpectation
	expectations       []*SendEmailServiceClientMockInviteUserMessageExpectation

	callArgs []*SendEmailServiceClientMockInviteUserMessageParams
	mutex    sync.RWMutex
}

// SendEmailServiceClientMockInviteUserMessageExpectation specifies expectation struct of the SendEmailServiceClient.InviteUserMessage
type SendEmailServiceClientMockInviteUserMessageExpectation struct {
	mock    *SendEmailServiceClientMock
	params  *SendEmailServiceClientMockInviteUserMessageParams
	results *SendEmailServiceClientMockInviteUserMessageResults
	Counter uint64
}

// SendEmailServiceClientMockInviteUserMessageParams contains parameters of the SendEmailServiceClient.InviteUserMessage
type SendEmailServiceClientMockInviteUserMessageParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.InviteUserMessageRequest]
}

// SendEmailServiceClientMockInviteUserMessageResults contains results of the SendEmailServiceClient.InviteUserMessage
type SendEmailServiceClientMockInviteUserMessageResults struct {
	pp2 *connect_go.Response[v1.InviteUserMessageResponse]
	err error
}

// Expect sets up expected params for SendEmailServiceClient.InviteUserMessage
func (mmInviteUserMessage *mSendEmailServiceClientMockInviteUserMessage) Expect(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest]) *mSendEmailServiceClientMockInviteUserMessage {
	if mmInviteUserMessage.mock.funcInviteUserMessage != nil {
		mmInviteUserMessage.mock.t.Fatalf("SendEmailServiceClientMock.InviteUserMessage mock is already set by Set")
	}

	if mmInviteUserMessage.defaultExpectation == nil {
		mmInviteUserMessage.defaultExpectation = &SendEmailServiceClientMockInviteUserMessageExpectation{}
	}

	mmInviteUserMessage.defaultExpectation.params = &SendEmailServiceClientMockInviteUserMessageParams{ctx, pp1}
	for _, e := range mmInviteUserMessage.expectations {
		if minimock.Equal(e.params, mmInviteUserMessage.defaultExpectation.params) {
			mmInviteUserMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInviteUserMessage.defaultExpectation.params)
		}
	}

	return mmInviteUserMessage
}

// Inspect accepts an inspector function that has same arguments as the SendEmailServiceClient.InviteUserMessage
func (mmInviteUserMessage *mSendEmailServiceClientMockInviteUserMessage) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest])) *mSendEmailServiceClientMockInviteUserMessage {
	if mmInviteUserMessage.mock.inspectFuncInviteUserMessage != nil {
		mmInviteUserMessage.mock.t.Fatalf("Inspect function is already set for SendEmailServiceClientMock.InviteUserMessage")
	}

	mmInviteUserMessage.mock.inspectFuncInviteUserMessage = f

	return mmInviteUserMessage
}

// Return sets up results that will be returned by SendEmailServiceClient.InviteUserMessage
func (mmInviteUserMessage *mSendEmailServiceClientMockInviteUserMessage) Return(pp2 *connect_go.Response[v1.InviteUserMessageResponse], err error) *SendEmailServiceClientMock {
	if mmInviteUserMessage.mock.funcInviteUserMessage != nil {
		mmInviteUserMessage.mock.t.Fatalf("SendEmailServiceClientMock.InviteUserMessage mock is already set by Set")
	}

	if mmInviteUserMessage.defaultExpectation == nil {
		mmInviteUserMessage.defaultExpectation = &SendEmailServiceClientMockInviteUserMessageExpectation{mock: mmInviteUserMessage.mock}
	}
	mmInviteUserMessage.defaultExpectation.results = &SendEmailServiceClientMockInviteUserMessageResults{pp2, err}
	return mmInviteUserMessage.mock
}

// Set uses given function f to mock the SendEmailServiceClient.InviteUserMessage method
func (mmInviteUserMessage *mSendEmailServiceClientMockInviteUserMessage) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest]) (pp2 *connect_go.Response[v1.InviteUserMessageResponse], err error)) *SendEmailServiceClientMock {
	if mmInviteUserMessage.defaultExpectation != nil {
		mmInviteUserMessage.mock.t.Fatalf("Default expectation is already set for the SendEmailServiceClient.InviteUserMessage method")
	}

	if len(mmInviteUserMessage.expectations) > 0 {
		mmInviteUserMessage.mock.t.Fatalf("Some expectations are already set for the SendEmailServiceClient.InviteUserMessage method")
	}

	mmInviteUserMessage.mock.funcInviteUserMessage = f
	return mmInviteUserMessage.mock
}

// When sets expectation for the SendEmailServiceClient.InviteUserMessage which will trigger the result defined by the following
// Then helper
func (mmInviteUserMessage *mSendEmailServiceClientMockInviteUserMessage) When(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest]) *SendEmailServiceClientMockInviteUserMessageExpectation {
	if mmInviteUserMessage.mock.funcInviteUserMessage != nil {
		mmInviteUserMessage.mock.t.Fatalf("SendEmailServiceClientMock.InviteUserMessage mock is already set by Set")
	}

	expectation := &SendEmailServiceClientMockInviteUserMessageExpectation{
		mock:   mmInviteUserMessage.mock,
		params: &SendEmailServiceClientMockInviteUserMessageParams{ctx, pp1},
	}
	mmInviteUserMessage.expectations = append(mmInviteUserMessage.expectations, expectation)
	return expectation
}

// Then sets up SendEmailServiceClient.InviteUserMessage return parameters for the expectation previously defined by the When method
func (e *SendEmailServiceClientMockInviteUserMessageExpectation) Then(pp2 *connect_go.Response[v1.InviteUserMessageResponse], err error) *SendEmailServiceClientMock {
	e.results = &SendEmailServiceClientMockInviteUserMessageResults{pp2, err}
	return e.mock
}

// InviteUserMessage implements SendEmailServiceClient
func (mmInviteUserMessage *SendEmailServiceClientMock) InviteUserMessage(ctx context.Context, pp1 *connect_go.Request[v1.InviteUserMessageRequest]) (pp2 *connect_go.Response[v1.InviteUserMessageResponse], err error) {
	mm_atomic.AddUint64(&mmInviteUserMessage.beforeInviteUserMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmInviteUserMessage.afterInviteUserMessageCounter, 1)

	if mmInviteUserMessage.inspectFuncInviteUserMessage != nil {
		mmInviteUserMessage.inspectFuncInviteUserMessage(ctx, pp1)
	}

	mm_params := &SendEmailServiceClientMockInviteUserMessageParams{ctx, pp1}

	// Record call args
	mmInviteUserMessage.InviteUserMessageMock.mutex.Lock()
	mmInviteUserMessage.InviteUserMessageMock.callArgs = append(mmInviteUserMessage.InviteUserMessageMock.callArgs, mm_params)
	mmInviteUserMessage.InviteUserMessageMock.mutex.Unlock()

	for _, e := range mmInviteUserMessage.InviteUserMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmInviteUserMessage.InviteUserMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInviteUserMessage.InviteUserMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmInviteUserMessage.InviteUserMessageMock.defaultExpectation.params
		mm_got := SendEmailServiceClientMockInviteUserMessageParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInviteUserMessage.t.Errorf("SendEmailServiceClientMock.InviteUserMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInviteUserMessage.InviteUserMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmInviteUserMessage.t.Fatal("No results are set for the SendEmailServiceClientMock.InviteUserMessage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmInviteUserMessage.funcInviteUserMessage != nil {
		return mmInviteUserMessage.funcInviteUserMessage(ctx, pp1)
	}
	mmInviteUserMessage.t.Fatalf("Unexpected call to SendEmailServiceClientMock.InviteUserMessage. %v %v", ctx, pp1)
	return
}

// InviteUserMessageAfterCounter returns a count of finished SendEmailServiceClientMock.InviteUserMessage invocations
func (mmInviteUserMessage *SendEmailServiceClientMock) InviteUserMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInviteUserMessage.afterInviteUserMessageCounter)
}

// InviteUserMessageBeforeCounter returns a count of SendEmailServiceClientMock.InviteUserMessage invocations
func (mmInviteUserMessage *SendEmailServiceClientMock) InviteUserMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInviteUserMessage.beforeInviteUserMessageCounter)
}

// Calls returns a list of arguments used in each call to SendEmailServiceClientMock.InviteUserMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInviteUserMessage *mSendEmailServiceClientMockInviteUserMessage) Calls() []*SendEmailServiceClientMockInviteUserMessageParams {
	mmInviteUserMessage.mutex.RLock()

	argCopy := make([]*SendEmailServiceClientMockInviteUserMessageParams, len(mmInviteUserMessage.callArgs))
	copy(argCopy, mmInviteUserMessage.callArgs)

	mmInviteUserMessage.mutex.RUnlock()

	return argCopy
}

// MinimockInviteUserMessageDone returns true if the count of the InviteUserMessage invocations corresponds
// the number of defined expectations
func (m *SendEmailServiceClientMock) MinimockInviteUserMessageDone() bool {
	for _, e := range m.InviteUserMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InviteUserMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInviteUserMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInviteUserMessage != nil && mm_atomic.LoadUint64(&m.afterInviteUserMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockInviteUserMessageInspect logs each unmet expectation
func (m *SendEmailServiceClientMock) MinimockInviteUserMessageInspect() {
	for _, e := range m.InviteUserMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SendEmailServiceClientMock.InviteUserMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InviteUserMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInviteUserMessageCounter) < 1 {
		if m.InviteUserMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SendEmailServiceClientMock.InviteUserMessage")
		} else {
			m.t.Errorf("Expected call to SendEmailServiceClientMock.InviteUserMessage with params: %#v", *m.InviteUserMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInviteUserMessage != nil && mm_atomic.LoadUint64(&m.afterInviteUserMessageCounter) < 1 {
		m.t.Error("Expected call to SendEmailServiceClientMock.InviteUserMessage")
	}
}

type mSendEmailServiceClientMockPasswordChangeMessage struct {
	mock               *SendEmailServiceClientMock
	defaultExpectation *SendEmailServiceClientMockPasswordChangeMessageExpectation
	expectations       []*SendEmailServiceClientMockPasswordChangeMessageExpectation

	callArgs []*SendEmailServiceClientMockPasswordChangeMessageParams
	mutex    sync.RWMutex
}

// SendEmailServiceClientMockPasswordChangeMessageExpectation specifies expectation struct of the SendEmailServiceClient.PasswordChangeMessage
type SendEmailServiceClientMockPasswordChangeMessageExpectation struct {
	mock    *SendEmailServiceClientMock
	params  *SendEmailServiceClientMockPasswordChangeMessageParams
	results *SendEmailServiceClientMockPasswordChangeMessageResults
	Counter uint64
}

// SendEmailServiceClientMockPasswordChangeMessageParams contains parameters of the SendEmailServiceClient.PasswordChangeMessage
type SendEmailServiceClientMockPasswordChangeMessageParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]
}

// SendEmailServiceClientMockPasswordChangeMessageResults contains results of the SendEmailServiceClient.PasswordChangeMessage
type SendEmailServiceClientMockPasswordChangeMessageResults struct {
	pp2 *connect_go.Response[v1.PasswordChangeMessageResponse]
	err error
}

// Expect sets up expected params for SendEmailServiceClient.PasswordChangeMessage
func (mmPasswordChangeMessage *mSendEmailServiceClientMockPasswordChangeMessage) Expect(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]) *mSendEmailServiceClientMockPasswordChangeMessage {
	if mmPasswordChangeMessage.mock.funcPasswordChangeMessage != nil {
		mmPasswordChangeMessage.mock.t.Fatalf("SendEmailServiceClientMock.PasswordChangeMessage mock is already set by Set")
	}

	if mmPasswordChangeMessage.defaultExpectation == nil {
		mmPasswordChangeMessage.defaultExpectation = &SendEmailServiceClientMockPasswordChangeMessageExpectation{}
	}

	mmPasswordChangeMessage.defaultExpectation.params = &SendEmailServiceClientMockPasswordChangeMessageParams{ctx, pp1}
	for _, e := range mmPasswordChangeMessage.expectations {
		if minimock.Equal(e.params, mmPasswordChangeMessage.defaultExpectation.params) {
			mmPasswordChangeMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPasswordChangeMessage.defaultExpectation.params)
		}
	}

	return mmPasswordChangeMessage
}

// Inspect accepts an inspector function that has same arguments as the SendEmailServiceClient.PasswordChangeMessage
func (mmPasswordChangeMessage *mSendEmailServiceClientMockPasswordChangeMessage) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest])) *mSendEmailServiceClientMockPasswordChangeMessage {
	if mmPasswordChangeMessage.mock.inspectFuncPasswordChangeMessage != nil {
		mmPasswordChangeMessage.mock.t.Fatalf("Inspect function is already set for SendEmailServiceClientMock.PasswordChangeMessage")
	}

	mmPasswordChangeMessage.mock.inspectFuncPasswordChangeMessage = f

	return mmPasswordChangeMessage
}

// Return sets up results that will be returned by SendEmailServiceClient.PasswordChangeMessage
func (mmPasswordChangeMessage *mSendEmailServiceClientMockPasswordChangeMessage) Return(pp2 *connect_go.Response[v1.PasswordChangeMessageResponse], err error) *SendEmailServiceClientMock {
	if mmPasswordChangeMessage.mock.funcPasswordChangeMessage != nil {
		mmPasswordChangeMessage.mock.t.Fatalf("SendEmailServiceClientMock.PasswordChangeMessage mock is already set by Set")
	}

	if mmPasswordChangeMessage.defaultExpectation == nil {
		mmPasswordChangeMessage.defaultExpectation = &SendEmailServiceClientMockPasswordChangeMessageExpectation{mock: mmPasswordChangeMessage.mock}
	}
	mmPasswordChangeMessage.defaultExpectation.results = &SendEmailServiceClientMockPasswordChangeMessageResults{pp2, err}
	return mmPasswordChangeMessage.mock
}

// Set uses given function f to mock the SendEmailServiceClient.PasswordChangeMessage method
func (mmPasswordChangeMessage *mSendEmailServiceClientMockPasswordChangeMessage) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]) (pp2 *connect_go.Response[v1.PasswordChangeMessageResponse], err error)) *SendEmailServiceClientMock {
	if mmPasswordChangeMessage.defaultExpectation != nil {
		mmPasswordChangeMessage.mock.t.Fatalf("Default expectation is already set for the SendEmailServiceClient.PasswordChangeMessage method")
	}

	if len(mmPasswordChangeMessage.expectations) > 0 {
		mmPasswordChangeMessage.mock.t.Fatalf("Some expectations are already set for the SendEmailServiceClient.PasswordChangeMessage method")
	}

	mmPasswordChangeMessage.mock.funcPasswordChangeMessage = f
	return mmPasswordChangeMessage.mock
}

// When sets expectation for the SendEmailServiceClient.PasswordChangeMessage which will trigger the result defined by the following
// Then helper
func (mmPasswordChangeMessage *mSendEmailServiceClientMockPasswordChangeMessage) When(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]) *SendEmailServiceClientMockPasswordChangeMessageExpectation {
	if mmPasswordChangeMessage.mock.funcPasswordChangeMessage != nil {
		mmPasswordChangeMessage.mock.t.Fatalf("SendEmailServiceClientMock.PasswordChangeMessage mock is already set by Set")
	}

	expectation := &SendEmailServiceClientMockPasswordChangeMessageExpectation{
		mock:   mmPasswordChangeMessage.mock,
		params: &SendEmailServiceClientMockPasswordChangeMessageParams{ctx, pp1},
	}
	mmPasswordChangeMessage.expectations = append(mmPasswordChangeMessage.expectations, expectation)
	return expectation
}

// Then sets up SendEmailServiceClient.PasswordChangeMessage return parameters for the expectation previously defined by the When method
func (e *SendEmailServiceClientMockPasswordChangeMessageExpectation) Then(pp2 *connect_go.Response[v1.PasswordChangeMessageResponse], err error) *SendEmailServiceClientMock {
	e.results = &SendEmailServiceClientMockPasswordChangeMessageResults{pp2, err}
	return e.mock
}

// PasswordChangeMessage implements SendEmailServiceClient
func (mmPasswordChangeMessage *SendEmailServiceClientMock) PasswordChangeMessage(ctx context.Context, pp1 *connect_go.Request[v1.PasswordChangeMessageRequest]) (pp2 *connect_go.Response[v1.PasswordChangeMessageResponse], err error) {
	mm_atomic.AddUint64(&mmPasswordChangeMessage.beforePasswordChangeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmPasswordChangeMessage.afterPasswordChangeMessageCounter, 1)

	if mmPasswordChangeMessage.inspectFuncPasswordChangeMessage != nil {
		mmPasswordChangeMessage.inspectFuncPasswordChangeMessage(ctx, pp1)
	}

	mm_params := &SendEmailServiceClientMockPasswordChangeMessageParams{ctx, pp1}

	// Record call args
	mmPasswordChangeMessage.PasswordChangeMessageMock.mutex.Lock()
	mmPasswordChangeMessage.PasswordChangeMessageMock.callArgs = append(mmPasswordChangeMessage.PasswordChangeMessageMock.callArgs, mm_params)
	mmPasswordChangeMessage.PasswordChangeMessageMock.mutex.Unlock()

	for _, e := range mmPasswordChangeMessage.PasswordChangeMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmPasswordChangeMessage.PasswordChangeMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPasswordChangeMessage.PasswordChangeMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmPasswordChangeMessage.PasswordChangeMessageMock.defaultExpectation.params
		mm_got := SendEmailServiceClientMockPasswordChangeMessageParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPasswordChangeMessage.t.Errorf("SendEmailServiceClientMock.PasswordChangeMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPasswordChangeMessage.PasswordChangeMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmPasswordChangeMessage.t.Fatal("No results are set for the SendEmailServiceClientMock.PasswordChangeMessage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmPasswordChangeMessage.funcPasswordChangeMessage != nil {
		return mmPasswordChangeMessage.funcPasswordChangeMessage(ctx, pp1)
	}
	mmPasswordChangeMessage.t.Fatalf("Unexpected call to SendEmailServiceClientMock.PasswordChangeMessage. %v %v", ctx, pp1)
	return
}

// PasswordChangeMessageAfterCounter returns a count of finished SendEmailServiceClientMock.PasswordChangeMessage invocations
func (mmPasswordChangeMessage *SendEmailServiceClientMock) PasswordChangeMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPasswordChangeMessage.afterPasswordChangeMessageCounter)
}

// PasswordChangeMessageBeforeCounter returns a count of SendEmailServiceClientMock.PasswordChangeMessage invocations
func (mmPasswordChangeMessage *SendEmailServiceClientMock) PasswordChangeMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPasswordChangeMessage.beforePasswordChangeMessageCounter)
}

// Calls returns a list of arguments used in each call to SendEmailServiceClientMock.PasswordChangeMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPasswordChangeMessage *mSendEmailServiceClientMockPasswordChangeMessage) Calls() []*SendEmailServiceClientMockPasswordChangeMessageParams {
	mmPasswordChangeMessage.mutex.RLock()

	argCopy := make([]*SendEmailServiceClientMockPasswordChangeMessageParams, len(mmPasswordChangeMessage.callArgs))
	copy(argCopy, mmPasswordChangeMessage.callArgs)

	mmPasswordChangeMessage.mutex.RUnlock()

	return argCopy
}

// MinimockPasswordChangeMessageDone returns true if the count of the PasswordChangeMessage invocations corresponds
// the number of defined expectations
func (m *SendEmailServiceClientMock) MinimockPasswordChangeMessageDone() bool {
	for _, e := range m.PasswordChangeMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PasswordChangeMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPasswordChangeMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPasswordChangeMessage != nil && mm_atomic.LoadUint64(&m.afterPasswordChangeMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockPasswordChangeMessageInspect logs each unmet expectation
func (m *SendEmailServiceClientMock) MinimockPasswordChangeMessageInspect() {
	for _, e := range m.PasswordChangeMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SendEmailServiceClientMock.PasswordChangeMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PasswordChangeMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPasswordChangeMessageCounter) < 1 {
		if m.PasswordChangeMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SendEmailServiceClientMock.PasswordChangeMessage")
		} else {
			m.t.Errorf("Expected call to SendEmailServiceClientMock.PasswordChangeMessage with params: %#v", *m.PasswordChangeMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPasswordChangeMessage != nil && mm_atomic.LoadUint64(&m.afterPasswordChangeMessageCounter) < 1 {
		m.t.Error("Expected call to SendEmailServiceClientMock.PasswordChangeMessage")
	}
}

type mSendEmailServiceClientMockPasswordRecoveryMessage struct {
	mock               *SendEmailServiceClientMock
	defaultExpectation *SendEmailServiceClientMockPasswordRecoveryMessageExpectation
	expectations       []*SendEmailServiceClientMockPasswordRecoveryMessageExpectation

	callArgs []*SendEmailServiceClientMockPasswordRecoveryMessageParams
	mutex    sync.RWMutex
}

// SendEmailServiceClientMockPasswordRecoveryMessageExpectation specifies expectation struct of the SendEmailServiceClient.PasswordRecoveryMessage
type SendEmailServiceClientMockPasswordRecoveryMessageExpectation struct {
	mock    *SendEmailServiceClientMock
	params  *SendEmailServiceClientMockPasswordRecoveryMessageParams
	results *SendEmailServiceClientMockPasswordRecoveryMessageResults
	Counter uint64
}

// SendEmailServiceClientMockPasswordRecoveryMessageParams contains parameters of the SendEmailServiceClient.PasswordRecoveryMessage
type SendEmailServiceClientMockPasswordRecoveryMessageParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]
}

// SendEmailServiceClientMockPasswordRecoveryMessageResults contains results of the SendEmailServiceClient.PasswordRecoveryMessage
type SendEmailServiceClientMockPasswordRecoveryMessageResults struct {
	pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse]
	err error
}

// Expect sets up expected params for SendEmailServiceClient.PasswordRecoveryMessage
func (mmPasswordRecoveryMessage *mSendEmailServiceClientMockPasswordRecoveryMessage) Expect(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]) *mSendEmailServiceClientMockPasswordRecoveryMessage {
	if mmPasswordRecoveryMessage.mock.funcPasswordRecoveryMessage != nil {
		mmPasswordRecoveryMessage.mock.t.Fatalf("SendEmailServiceClientMock.PasswordRecoveryMessage mock is already set by Set")
	}

	if mmPasswordRecoveryMessage.defaultExpectation == nil {
		mmPasswordRecoveryMessage.defaultExpectation = &SendEmailServiceClientMockPasswordRecoveryMessageExpectation{}
	}

	mmPasswordRecoveryMessage.defaultExpectation.params = &SendEmailServiceClientMockPasswordRecoveryMessageParams{ctx, pp1}
	for _, e := range mmPasswordRecoveryMessage.expectations {
		if minimock.Equal(e.params, mmPasswordRecoveryMessage.defaultExpectation.params) {
			mmPasswordRecoveryMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPasswordRecoveryMessage.defaultExpectation.params)
		}
	}

	return mmPasswordRecoveryMessage
}

// Inspect accepts an inspector function that has same arguments as the SendEmailServiceClient.PasswordRecoveryMessage
func (mmPasswordRecoveryMessage *mSendEmailServiceClientMockPasswordRecoveryMessage) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest])) *mSendEmailServiceClientMockPasswordRecoveryMessage {
	if mmPasswordRecoveryMessage.mock.inspectFuncPasswordRecoveryMessage != nil {
		mmPasswordRecoveryMessage.mock.t.Fatalf("Inspect function is already set for SendEmailServiceClientMock.PasswordRecoveryMessage")
	}

	mmPasswordRecoveryMessage.mock.inspectFuncPasswordRecoveryMessage = f

	return mmPasswordRecoveryMessage
}

// Return sets up results that will be returned by SendEmailServiceClient.PasswordRecoveryMessage
func (mmPasswordRecoveryMessage *mSendEmailServiceClientMockPasswordRecoveryMessage) Return(pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse], err error) *SendEmailServiceClientMock {
	if mmPasswordRecoveryMessage.mock.funcPasswordRecoveryMessage != nil {
		mmPasswordRecoveryMessage.mock.t.Fatalf("SendEmailServiceClientMock.PasswordRecoveryMessage mock is already set by Set")
	}

	if mmPasswordRecoveryMessage.defaultExpectation == nil {
		mmPasswordRecoveryMessage.defaultExpectation = &SendEmailServiceClientMockPasswordRecoveryMessageExpectation{mock: mmPasswordRecoveryMessage.mock}
	}
	mmPasswordRecoveryMessage.defaultExpectation.results = &SendEmailServiceClientMockPasswordRecoveryMessageResults{pp2, err}
	return mmPasswordRecoveryMessage.mock
}

// Set uses given function f to mock the SendEmailServiceClient.PasswordRecoveryMessage method
func (mmPasswordRecoveryMessage *mSendEmailServiceClientMockPasswordRecoveryMessage) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]) (pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse], err error)) *SendEmailServiceClientMock {
	if mmPasswordRecoveryMessage.defaultExpectation != nil {
		mmPasswordRecoveryMessage.mock.t.Fatalf("Default expectation is already set for the SendEmailServiceClient.PasswordRecoveryMessage method")
	}

	if len(mmPasswordRecoveryMessage.expectations) > 0 {
		mmPasswordRecoveryMessage.mock.t.Fatalf("Some expectations are already set for the SendEmailServiceClient.PasswordRecoveryMessage method")
	}

	mmPasswordRecoveryMessage.mock.funcPasswordRecoveryMessage = f
	return mmPasswordRecoveryMessage.mock
}

// When sets expectation for the SendEmailServiceClient.PasswordRecoveryMessage which will trigger the result defined by the following
// Then helper
func (mmPasswordRecoveryMessage *mSendEmailServiceClientMockPasswordRecoveryMessage) When(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]) *SendEmailServiceClientMockPasswordRecoveryMessageExpectation {
	if mmPasswordRecoveryMessage.mock.funcPasswordRecoveryMessage != nil {
		mmPasswordRecoveryMessage.mock.t.Fatalf("SendEmailServiceClientMock.PasswordRecoveryMessage mock is already set by Set")
	}

	expectation := &SendEmailServiceClientMockPasswordRecoveryMessageExpectation{
		mock:   mmPasswordRecoveryMessage.mock,
		params: &SendEmailServiceClientMockPasswordRecoveryMessageParams{ctx, pp1},
	}
	mmPasswordRecoveryMessage.expectations = append(mmPasswordRecoveryMessage.expectations, expectation)
	return expectation
}

// Then sets up SendEmailServiceClient.PasswordRecoveryMessage return parameters for the expectation previously defined by the When method
func (e *SendEmailServiceClientMockPasswordRecoveryMessageExpectation) Then(pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse], err error) *SendEmailServiceClientMock {
	e.results = &SendEmailServiceClientMockPasswordRecoveryMessageResults{pp2, err}
	return e.mock
}

// PasswordRecoveryMessage implements SendEmailServiceClient
func (mmPasswordRecoveryMessage *SendEmailServiceClientMock) PasswordRecoveryMessage(ctx context.Context, pp1 *connect_go.Request[v1.PasswordRecoveryMessageRequest]) (pp2 *connect_go.Response[v1.PasswordRecoveryMessageResponse], err error) {
	mm_atomic.AddUint64(&mmPasswordRecoveryMessage.beforePasswordRecoveryMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmPasswordRecoveryMessage.afterPasswordRecoveryMessageCounter, 1)

	if mmPasswordRecoveryMessage.inspectFuncPasswordRecoveryMessage != nil {
		mmPasswordRecoveryMessage.inspectFuncPasswordRecoveryMessage(ctx, pp1)
	}

	mm_params := &SendEmailServiceClientMockPasswordRecoveryMessageParams{ctx, pp1}

	// Record call args
	mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.mutex.Lock()
	mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.callArgs = append(mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.callArgs, mm_params)
	mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.mutex.Unlock()

	for _, e := range mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.defaultExpectation.params
		mm_got := SendEmailServiceClientMockPasswordRecoveryMessageParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPasswordRecoveryMessage.t.Errorf("SendEmailServiceClientMock.PasswordRecoveryMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPasswordRecoveryMessage.PasswordRecoveryMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmPasswordRecoveryMessage.t.Fatal("No results are set for the SendEmailServiceClientMock.PasswordRecoveryMessage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmPasswordRecoveryMessage.funcPasswordRecoveryMessage != nil {
		return mmPasswordRecoveryMessage.funcPasswordRecoveryMessage(ctx, pp1)
	}
	mmPasswordRecoveryMessage.t.Fatalf("Unexpected call to SendEmailServiceClientMock.PasswordRecoveryMessage. %v %v", ctx, pp1)
	return
}

// PasswordRecoveryMessageAfterCounter returns a count of finished SendEmailServiceClientMock.PasswordRecoveryMessage invocations
func (mmPasswordRecoveryMessage *SendEmailServiceClientMock) PasswordRecoveryMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPasswordRecoveryMessage.afterPasswordRecoveryMessageCounter)
}

// PasswordRecoveryMessageBeforeCounter returns a count of SendEmailServiceClientMock.PasswordRecoveryMessage invocations
func (mmPasswordRecoveryMessage *SendEmailServiceClientMock) PasswordRecoveryMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPasswordRecoveryMessage.beforePasswordRecoveryMessageCounter)
}

// Calls returns a list of arguments used in each call to SendEmailServiceClientMock.PasswordRecoveryMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPasswordRecoveryMessage *mSendEmailServiceClientMockPasswordRecoveryMessage) Calls() []*SendEmailServiceClientMockPasswordRecoveryMessageParams {
	mmPasswordRecoveryMessage.mutex.RLock()

	argCopy := make([]*SendEmailServiceClientMockPasswordRecoveryMessageParams, len(mmPasswordRecoveryMessage.callArgs))
	copy(argCopy, mmPasswordRecoveryMessage.callArgs)

	mmPasswordRecoveryMessage.mutex.RUnlock()

	return argCopy
}

// MinimockPasswordRecoveryMessageDone returns true if the count of the PasswordRecoveryMessage invocations corresponds
// the number of defined expectations
func (m *SendEmailServiceClientMock) MinimockPasswordRecoveryMessageDone() bool {
	for _, e := range m.PasswordRecoveryMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PasswordRecoveryMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPasswordRecoveryMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPasswordRecoveryMessage != nil && mm_atomic.LoadUint64(&m.afterPasswordRecoveryMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockPasswordRecoveryMessageInspect logs each unmet expectation
func (m *SendEmailServiceClientMock) MinimockPasswordRecoveryMessageInspect() {
	for _, e := range m.PasswordRecoveryMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SendEmailServiceClientMock.PasswordRecoveryMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PasswordRecoveryMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPasswordRecoveryMessageCounter) < 1 {
		if m.PasswordRecoveryMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SendEmailServiceClientMock.PasswordRecoveryMessage")
		} else {
			m.t.Errorf("Expected call to SendEmailServiceClientMock.PasswordRecoveryMessage with params: %#v", *m.PasswordRecoveryMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPasswordRecoveryMessage != nil && mm_atomic.LoadUint64(&m.afterPasswordRecoveryMessageCounter) < 1 {
		m.t.Error("Expected call to SendEmailServiceClientMock.PasswordRecoveryMessage")
	}
}

type mSendEmailServiceClientMockRegisterMessage struct {
	mock               *SendEmailServiceClientMock
	defaultExpectation *SendEmailServiceClientMockRegisterMessageExpectation
	expectations       []*SendEmailServiceClientMockRegisterMessageExpectation

	callArgs []*SendEmailServiceClientMockRegisterMessageParams
	mutex    sync.RWMutex
}

// SendEmailServiceClientMockRegisterMessageExpectation specifies expectation struct of the SendEmailServiceClient.RegisterMessage
type SendEmailServiceClientMockRegisterMessageExpectation struct {
	mock    *SendEmailServiceClientMock
	params  *SendEmailServiceClientMockRegisterMessageParams
	results *SendEmailServiceClientMockRegisterMessageResults
	Counter uint64
}

// SendEmailServiceClientMockRegisterMessageParams contains parameters of the SendEmailServiceClient.RegisterMessage
type SendEmailServiceClientMockRegisterMessageParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.RegisterMessageRequest]
}

// SendEmailServiceClientMockRegisterMessageResults contains results of the SendEmailServiceClient.RegisterMessage
type SendEmailServiceClientMockRegisterMessageResults struct {
	pp2 *connect_go.Response[v1.RegisterMessageResponse]
	err error
}

// Expect sets up expected params for SendEmailServiceClient.RegisterMessage
func (mmRegisterMessage *mSendEmailServiceClientMockRegisterMessage) Expect(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest]) *mSendEmailServiceClientMockRegisterMessage {
	if mmRegisterMessage.mock.funcRegisterMessage != nil {
		mmRegisterMessage.mock.t.Fatalf("SendEmailServiceClientMock.RegisterMessage mock is already set by Set")
	}

	if mmRegisterMessage.defaultExpectation == nil {
		mmRegisterMessage.defaultExpectation = &SendEmailServiceClientMockRegisterMessageExpectation{}
	}

	mmRegisterMessage.defaultExpectation.params = &SendEmailServiceClientMockRegisterMessageParams{ctx, pp1}
	for _, e := range mmRegisterMessage.expectations {
		if minimock.Equal(e.params, mmRegisterMessage.defaultExpectation.params) {
			mmRegisterMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterMessage.defaultExpectation.params)
		}
	}

	return mmRegisterMessage
}

// Inspect accepts an inspector function that has same arguments as the SendEmailServiceClient.RegisterMessage
func (mmRegisterMessage *mSendEmailServiceClientMockRegisterMessage) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest])) *mSendEmailServiceClientMockRegisterMessage {
	if mmRegisterMessage.mock.inspectFuncRegisterMessage != nil {
		mmRegisterMessage.mock.t.Fatalf("Inspect function is already set for SendEmailServiceClientMock.RegisterMessage")
	}

	mmRegisterMessage.mock.inspectFuncRegisterMessage = f

	return mmRegisterMessage
}

// Return sets up results that will be returned by SendEmailServiceClient.RegisterMessage
func (mmRegisterMessage *mSendEmailServiceClientMockRegisterMessage) Return(pp2 *connect_go.Response[v1.RegisterMessageResponse], err error) *SendEmailServiceClientMock {
	if mmRegisterMessage.mock.funcRegisterMessage != nil {
		mmRegisterMessage.mock.t.Fatalf("SendEmailServiceClientMock.RegisterMessage mock is already set by Set")
	}

	if mmRegisterMessage.defaultExpectation == nil {
		mmRegisterMessage.defaultExpectation = &SendEmailServiceClientMockRegisterMessageExpectation{mock: mmRegisterMessage.mock}
	}
	mmRegisterMessage.defaultExpectation.results = &SendEmailServiceClientMockRegisterMessageResults{pp2, err}
	return mmRegisterMessage.mock
}

// Set uses given function f to mock the SendEmailServiceClient.RegisterMessage method
func (mmRegisterMessage *mSendEmailServiceClientMockRegisterMessage) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest]) (pp2 *connect_go.Response[v1.RegisterMessageResponse], err error)) *SendEmailServiceClientMock {
	if mmRegisterMessage.defaultExpectation != nil {
		mmRegisterMessage.mock.t.Fatalf("Default expectation is already set for the SendEmailServiceClient.RegisterMessage method")
	}

	if len(mmRegisterMessage.expectations) > 0 {
		mmRegisterMessage.mock.t.Fatalf("Some expectations are already set for the SendEmailServiceClient.RegisterMessage method")
	}

	mmRegisterMessage.mock.funcRegisterMessage = f
	return mmRegisterMessage.mock
}

// When sets expectation for the SendEmailServiceClient.RegisterMessage which will trigger the result defined by the following
// Then helper
func (mmRegisterMessage *mSendEmailServiceClientMockRegisterMessage) When(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest]) *SendEmailServiceClientMockRegisterMessageExpectation {
	if mmRegisterMessage.mock.funcRegisterMessage != nil {
		mmRegisterMessage.mock.t.Fatalf("SendEmailServiceClientMock.RegisterMessage mock is already set by Set")
	}

	expectation := &SendEmailServiceClientMockRegisterMessageExpectation{
		mock:   mmRegisterMessage.mock,
		params: &SendEmailServiceClientMockRegisterMessageParams{ctx, pp1},
	}
	mmRegisterMessage.expectations = append(mmRegisterMessage.expectations, expectation)
	return expectation
}

// Then sets up SendEmailServiceClient.RegisterMessage return parameters for the expectation previously defined by the When method
func (e *SendEmailServiceClientMockRegisterMessageExpectation) Then(pp2 *connect_go.Response[v1.RegisterMessageResponse], err error) *SendEmailServiceClientMock {
	e.results = &SendEmailServiceClientMockRegisterMessageResults{pp2, err}
	return e.mock
}

// RegisterMessage implements SendEmailServiceClient
func (mmRegisterMessage *SendEmailServiceClientMock) RegisterMessage(ctx context.Context, pp1 *connect_go.Request[v1.RegisterMessageRequest]) (pp2 *connect_go.Response[v1.RegisterMessageResponse], err error) {
	mm_atomic.AddUint64(&mmRegisterMessage.beforeRegisterMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterMessage.afterRegisterMessageCounter, 1)

	if mmRegisterMessage.inspectFuncRegisterMessage != nil {
		mmRegisterMessage.inspectFuncRegisterMessage(ctx, pp1)
	}

	mm_params := &SendEmailServiceClientMockRegisterMessageParams{ctx, pp1}

	// Record call args
	mmRegisterMessage.RegisterMessageMock.mutex.Lock()
	mmRegisterMessage.RegisterMessageMock.callArgs = append(mmRegisterMessage.RegisterMessageMock.callArgs, mm_params)
	mmRegisterMessage.RegisterMessageMock.mutex.Unlock()

	for _, e := range mmRegisterMessage.RegisterMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRegisterMessage.RegisterMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterMessage.RegisterMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterMessage.RegisterMessageMock.defaultExpectation.params
		mm_got := SendEmailServiceClientMockRegisterMessageParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterMessage.t.Errorf("SendEmailServiceClientMock.RegisterMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterMessage.RegisterMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterMessage.t.Fatal("No results are set for the SendEmailServiceClientMock.RegisterMessage")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRegisterMessage.funcRegisterMessage != nil {
		return mmRegisterMessage.funcRegisterMessage(ctx, pp1)
	}
	mmRegisterMessage.t.Fatalf("Unexpected call to SendEmailServiceClientMock.RegisterMessage. %v %v", ctx, pp1)
	return
}

// RegisterMessageAfterCounter returns a count of finished SendEmailServiceClientMock.RegisterMessage invocations
func (mmRegisterMessage *SendEmailServiceClientMock) RegisterMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterMessage.afterRegisterMessageCounter)
}

// RegisterMessageBeforeCounter returns a count of SendEmailServiceClientMock.RegisterMessage invocations
func (mmRegisterMessage *SendEmailServiceClientMock) RegisterMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterMessage.beforeRegisterMessageCounter)
}

// Calls returns a list of arguments used in each call to SendEmailServiceClientMock.RegisterMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterMessage *mSendEmailServiceClientMockRegisterMessage) Calls() []*SendEmailServiceClientMockRegisterMessageParams {
	mmRegisterMessage.mutex.RLock()

	argCopy := make([]*SendEmailServiceClientMockRegisterMessageParams, len(mmRegisterMessage.callArgs))
	copy(argCopy, mmRegisterMessage.callArgs)

	mmRegisterMessage.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterMessageDone returns true if the count of the RegisterMessage invocations corresponds
// the number of defined expectations
func (m *SendEmailServiceClientMock) MinimockRegisterMessageDone() bool {
	for _, e := range m.RegisterMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterMessage != nil && mm_atomic.LoadUint64(&m.afterRegisterMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterMessageInspect logs each unmet expectation
func (m *SendEmailServiceClientMock) MinimockRegisterMessageInspect() {
	for _, e := range m.RegisterMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SendEmailServiceClientMock.RegisterMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterMessageCounter) < 1 {
		if m.RegisterMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SendEmailServiceClientMock.RegisterMessage")
		} else {
			m.t.Errorf("Expected call to SendEmailServiceClientMock.RegisterMessage with params: %#v", *m.RegisterMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterMessage != nil && mm_atomic.LoadUint64(&m.afterRegisterMessageCounter) < 1 {
		m.t.Error("Expected call to SendEmailServiceClientMock.RegisterMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SendEmailServiceClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockInviteUserMessageInspect()

		m.MinimockPasswordChangeMessageInspect()

		m.MinimockPasswordRecoveryMessageInspect()

		m.MinimockRegisterMessageInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SendEmailServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SendEmailServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockInviteUserMessageDone() &&
		m.MinimockPasswordChangeMessageDone() &&
		m.MinimockPasswordRecoveryMessageDone() &&
		m.MinimockRegisterMessageDone()
}
