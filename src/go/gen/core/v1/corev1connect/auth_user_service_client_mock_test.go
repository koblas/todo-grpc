package corev1connect

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/koblas/grpc-todo/gen/core/v1/corev1connect.AuthUserServiceClient -o ./auth_user_service_client_mock_test.go -n AuthUserServiceClientMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	connect_go "github.com/bufbuild/connect-go"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/koblas/grpc-todo/gen/core/v1"
)

// AuthUserServiceClientMock implements AuthUserServiceClient
type AuthUserServiceClientMock struct {
	t minimock.Tester

	funcGetAuthUrl          func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse], err error)
	inspectFuncGetAuthUrl   func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest])
	afterGetAuthUrlCounter  uint64
	beforeGetAuthUrlCounter uint64
	GetAuthUrlMock          mAuthUserServiceClientMockGetAuthUrl

	funcListAssociations          func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse], err error)
	inspectFuncListAssociations   func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest])
	afterListAssociationsCounter  uint64
	beforeListAssociationsCounter uint64
	ListAssociationsMock          mAuthUserServiceClientMockListAssociations

	funcRemoveAssociation          func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse], err error)
	inspectFuncRemoveAssociation   func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest])
	afterRemoveAssociationCounter  uint64
	beforeRemoveAssociationCounter uint64
	RemoveAssociationMock          mAuthUserServiceClientMockRemoveAssociation

	funcUpsertUser          func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse], err error)
	inspectFuncUpsertUser   func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest])
	afterUpsertUserCounter  uint64
	beforeUpsertUserCounter uint64
	UpsertUserMock          mAuthUserServiceClientMockUpsertUser
}

// NewAuthUserServiceClientMock returns a mock for AuthUserServiceClient
func NewAuthUserServiceClientMock(t minimock.Tester) *AuthUserServiceClientMock {
	m := &AuthUserServiceClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAuthUrlMock = mAuthUserServiceClientMockGetAuthUrl{mock: m}
	m.GetAuthUrlMock.callArgs = []*AuthUserServiceClientMockGetAuthUrlParams{}

	m.ListAssociationsMock = mAuthUserServiceClientMockListAssociations{mock: m}
	m.ListAssociationsMock.callArgs = []*AuthUserServiceClientMockListAssociationsParams{}

	m.RemoveAssociationMock = mAuthUserServiceClientMockRemoveAssociation{mock: m}
	m.RemoveAssociationMock.callArgs = []*AuthUserServiceClientMockRemoveAssociationParams{}

	m.UpsertUserMock = mAuthUserServiceClientMockUpsertUser{mock: m}
	m.UpsertUserMock.callArgs = []*AuthUserServiceClientMockUpsertUserParams{}

	return m
}

type mAuthUserServiceClientMockGetAuthUrl struct {
	mock               *AuthUserServiceClientMock
	defaultExpectation *AuthUserServiceClientMockGetAuthUrlExpectation
	expectations       []*AuthUserServiceClientMockGetAuthUrlExpectation

	callArgs []*AuthUserServiceClientMockGetAuthUrlParams
	mutex    sync.RWMutex
}

// AuthUserServiceClientMockGetAuthUrlExpectation specifies expectation struct of the AuthUserServiceClient.GetAuthUrl
type AuthUserServiceClientMockGetAuthUrlExpectation struct {
	mock    *AuthUserServiceClientMock
	params  *AuthUserServiceClientMockGetAuthUrlParams
	results *AuthUserServiceClientMockGetAuthUrlResults
	Counter uint64
}

// AuthUserServiceClientMockGetAuthUrlParams contains parameters of the AuthUserServiceClient.GetAuthUrl
type AuthUserServiceClientMockGetAuthUrlParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]
}

// AuthUserServiceClientMockGetAuthUrlResults contains results of the AuthUserServiceClient.GetAuthUrl
type AuthUserServiceClientMockGetAuthUrlResults struct {
	pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse]
	err error
}

// Expect sets up expected params for AuthUserServiceClient.GetAuthUrl
func (mmGetAuthUrl *mAuthUserServiceClientMockGetAuthUrl) Expect(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]) *mAuthUserServiceClientMockGetAuthUrl {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("AuthUserServiceClientMock.GetAuthUrl mock is already set by Set")
	}

	if mmGetAuthUrl.defaultExpectation == nil {
		mmGetAuthUrl.defaultExpectation = &AuthUserServiceClientMockGetAuthUrlExpectation{}
	}

	mmGetAuthUrl.defaultExpectation.params = &AuthUserServiceClientMockGetAuthUrlParams{ctx, pp1}
	for _, e := range mmGetAuthUrl.expectations {
		if minimock.Equal(e.params, mmGetAuthUrl.defaultExpectation.params) {
			mmGetAuthUrl.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAuthUrl.defaultExpectation.params)
		}
	}

	return mmGetAuthUrl
}

// Inspect accepts an inspector function that has same arguments as the AuthUserServiceClient.GetAuthUrl
func (mmGetAuthUrl *mAuthUserServiceClientMockGetAuthUrl) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest])) *mAuthUserServiceClientMockGetAuthUrl {
	if mmGetAuthUrl.mock.inspectFuncGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("Inspect function is already set for AuthUserServiceClientMock.GetAuthUrl")
	}

	mmGetAuthUrl.mock.inspectFuncGetAuthUrl = f

	return mmGetAuthUrl
}

// Return sets up results that will be returned by AuthUserServiceClient.GetAuthUrl
func (mmGetAuthUrl *mAuthUserServiceClientMockGetAuthUrl) Return(pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse], err error) *AuthUserServiceClientMock {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("AuthUserServiceClientMock.GetAuthUrl mock is already set by Set")
	}

	if mmGetAuthUrl.defaultExpectation == nil {
		mmGetAuthUrl.defaultExpectation = &AuthUserServiceClientMockGetAuthUrlExpectation{mock: mmGetAuthUrl.mock}
	}
	mmGetAuthUrl.defaultExpectation.results = &AuthUserServiceClientMockGetAuthUrlResults{pp2, err}
	return mmGetAuthUrl.mock
}

// Set uses given function f to mock the AuthUserServiceClient.GetAuthUrl method
func (mmGetAuthUrl *mAuthUserServiceClientMockGetAuthUrl) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse], err error)) *AuthUserServiceClientMock {
	if mmGetAuthUrl.defaultExpectation != nil {
		mmGetAuthUrl.mock.t.Fatalf("Default expectation is already set for the AuthUserServiceClient.GetAuthUrl method")
	}

	if len(mmGetAuthUrl.expectations) > 0 {
		mmGetAuthUrl.mock.t.Fatalf("Some expectations are already set for the AuthUserServiceClient.GetAuthUrl method")
	}

	mmGetAuthUrl.mock.funcGetAuthUrl = f
	return mmGetAuthUrl.mock
}

// When sets expectation for the AuthUserServiceClient.GetAuthUrl which will trigger the result defined by the following
// Then helper
func (mmGetAuthUrl *mAuthUserServiceClientMockGetAuthUrl) When(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]) *AuthUserServiceClientMockGetAuthUrlExpectation {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("AuthUserServiceClientMock.GetAuthUrl mock is already set by Set")
	}

	expectation := &AuthUserServiceClientMockGetAuthUrlExpectation{
		mock:   mmGetAuthUrl.mock,
		params: &AuthUserServiceClientMockGetAuthUrlParams{ctx, pp1},
	}
	mmGetAuthUrl.expectations = append(mmGetAuthUrl.expectations, expectation)
	return expectation
}

// Then sets up AuthUserServiceClient.GetAuthUrl return parameters for the expectation previously defined by the When method
func (e *AuthUserServiceClientMockGetAuthUrlExpectation) Then(pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse], err error) *AuthUserServiceClientMock {
	e.results = &AuthUserServiceClientMockGetAuthUrlResults{pp2, err}
	return e.mock
}

// GetAuthUrl implements AuthUserServiceClient
func (mmGetAuthUrl *AuthUserServiceClientMock) GetAuthUrl(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse], err error) {
	mm_atomic.AddUint64(&mmGetAuthUrl.beforeGetAuthUrlCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAuthUrl.afterGetAuthUrlCounter, 1)

	if mmGetAuthUrl.inspectFuncGetAuthUrl != nil {
		mmGetAuthUrl.inspectFuncGetAuthUrl(ctx, pp1)
	}

	mm_params := &AuthUserServiceClientMockGetAuthUrlParams{ctx, pp1}

	// Record call args
	mmGetAuthUrl.GetAuthUrlMock.mutex.Lock()
	mmGetAuthUrl.GetAuthUrlMock.callArgs = append(mmGetAuthUrl.GetAuthUrlMock.callArgs, mm_params)
	mmGetAuthUrl.GetAuthUrlMock.mutex.Unlock()

	for _, e := range mmGetAuthUrl.GetAuthUrlMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetAuthUrl.GetAuthUrlMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.params
		mm_got := AuthUserServiceClientMockGetAuthUrlParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAuthUrl.t.Errorf("AuthUserServiceClientMock.GetAuthUrl got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAuthUrl.t.Fatal("No results are set for the AuthUserServiceClientMock.GetAuthUrl")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetAuthUrl.funcGetAuthUrl != nil {
		return mmGetAuthUrl.funcGetAuthUrl(ctx, pp1)
	}
	mmGetAuthUrl.t.Fatalf("Unexpected call to AuthUserServiceClientMock.GetAuthUrl. %v %v", ctx, pp1)
	return
}

// GetAuthUrlAfterCounter returns a count of finished AuthUserServiceClientMock.GetAuthUrl invocations
func (mmGetAuthUrl *AuthUserServiceClientMock) GetAuthUrlAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthUrl.afterGetAuthUrlCounter)
}

// GetAuthUrlBeforeCounter returns a count of AuthUserServiceClientMock.GetAuthUrl invocations
func (mmGetAuthUrl *AuthUserServiceClientMock) GetAuthUrlBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthUrl.beforeGetAuthUrlCounter)
}

// Calls returns a list of arguments used in each call to AuthUserServiceClientMock.GetAuthUrl.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAuthUrl *mAuthUserServiceClientMockGetAuthUrl) Calls() []*AuthUserServiceClientMockGetAuthUrlParams {
	mmGetAuthUrl.mutex.RLock()

	argCopy := make([]*AuthUserServiceClientMockGetAuthUrlParams, len(mmGetAuthUrl.callArgs))
	copy(argCopy, mmGetAuthUrl.callArgs)

	mmGetAuthUrl.mutex.RUnlock()

	return argCopy
}

// MinimockGetAuthUrlDone returns true if the count of the GetAuthUrl invocations corresponds
// the number of defined expectations
func (m *AuthUserServiceClientMock) MinimockGetAuthUrlDone() bool {
	for _, e := range m.GetAuthUrlMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthUrlMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthUrl != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAuthUrlInspect logs each unmet expectation
func (m *AuthUserServiceClientMock) MinimockGetAuthUrlInspect() {
	for _, e := range m.GetAuthUrlMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUserServiceClientMock.GetAuthUrl with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthUrlMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		if m.GetAuthUrlMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthUserServiceClientMock.GetAuthUrl")
		} else {
			m.t.Errorf("Expected call to AuthUserServiceClientMock.GetAuthUrl with params: %#v", *m.GetAuthUrlMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthUrl != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		m.t.Error("Expected call to AuthUserServiceClientMock.GetAuthUrl")
	}
}

type mAuthUserServiceClientMockListAssociations struct {
	mock               *AuthUserServiceClientMock
	defaultExpectation *AuthUserServiceClientMockListAssociationsExpectation
	expectations       []*AuthUserServiceClientMockListAssociationsExpectation

	callArgs []*AuthUserServiceClientMockListAssociationsParams
	mutex    sync.RWMutex
}

// AuthUserServiceClientMockListAssociationsExpectation specifies expectation struct of the AuthUserServiceClient.ListAssociations
type AuthUserServiceClientMockListAssociationsExpectation struct {
	mock    *AuthUserServiceClientMock
	params  *AuthUserServiceClientMockListAssociationsParams
	results *AuthUserServiceClientMockListAssociationsResults
	Counter uint64
}

// AuthUserServiceClientMockListAssociationsParams contains parameters of the AuthUserServiceClient.ListAssociations
type AuthUserServiceClientMockListAssociationsParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]
}

// AuthUserServiceClientMockListAssociationsResults contains results of the AuthUserServiceClient.ListAssociations
type AuthUserServiceClientMockListAssociationsResults struct {
	pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse]
	err error
}

// Expect sets up expected params for AuthUserServiceClient.ListAssociations
func (mmListAssociations *mAuthUserServiceClientMockListAssociations) Expect(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]) *mAuthUserServiceClientMockListAssociations {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("AuthUserServiceClientMock.ListAssociations mock is already set by Set")
	}

	if mmListAssociations.defaultExpectation == nil {
		mmListAssociations.defaultExpectation = &AuthUserServiceClientMockListAssociationsExpectation{}
	}

	mmListAssociations.defaultExpectation.params = &AuthUserServiceClientMockListAssociationsParams{ctx, pp1}
	for _, e := range mmListAssociations.expectations {
		if minimock.Equal(e.params, mmListAssociations.defaultExpectation.params) {
			mmListAssociations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAssociations.defaultExpectation.params)
		}
	}

	return mmListAssociations
}

// Inspect accepts an inspector function that has same arguments as the AuthUserServiceClient.ListAssociations
func (mmListAssociations *mAuthUserServiceClientMockListAssociations) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest])) *mAuthUserServiceClientMockListAssociations {
	if mmListAssociations.mock.inspectFuncListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("Inspect function is already set for AuthUserServiceClientMock.ListAssociations")
	}

	mmListAssociations.mock.inspectFuncListAssociations = f

	return mmListAssociations
}

// Return sets up results that will be returned by AuthUserServiceClient.ListAssociations
func (mmListAssociations *mAuthUserServiceClientMockListAssociations) Return(pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse], err error) *AuthUserServiceClientMock {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("AuthUserServiceClientMock.ListAssociations mock is already set by Set")
	}

	if mmListAssociations.defaultExpectation == nil {
		mmListAssociations.defaultExpectation = &AuthUserServiceClientMockListAssociationsExpectation{mock: mmListAssociations.mock}
	}
	mmListAssociations.defaultExpectation.results = &AuthUserServiceClientMockListAssociationsResults{pp2, err}
	return mmListAssociations.mock
}

// Set uses given function f to mock the AuthUserServiceClient.ListAssociations method
func (mmListAssociations *mAuthUserServiceClientMockListAssociations) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse], err error)) *AuthUserServiceClientMock {
	if mmListAssociations.defaultExpectation != nil {
		mmListAssociations.mock.t.Fatalf("Default expectation is already set for the AuthUserServiceClient.ListAssociations method")
	}

	if len(mmListAssociations.expectations) > 0 {
		mmListAssociations.mock.t.Fatalf("Some expectations are already set for the AuthUserServiceClient.ListAssociations method")
	}

	mmListAssociations.mock.funcListAssociations = f
	return mmListAssociations.mock
}

// When sets expectation for the AuthUserServiceClient.ListAssociations which will trigger the result defined by the following
// Then helper
func (mmListAssociations *mAuthUserServiceClientMockListAssociations) When(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]) *AuthUserServiceClientMockListAssociationsExpectation {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("AuthUserServiceClientMock.ListAssociations mock is already set by Set")
	}

	expectation := &AuthUserServiceClientMockListAssociationsExpectation{
		mock:   mmListAssociations.mock,
		params: &AuthUserServiceClientMockListAssociationsParams{ctx, pp1},
	}
	mmListAssociations.expectations = append(mmListAssociations.expectations, expectation)
	return expectation
}

// Then sets up AuthUserServiceClient.ListAssociations return parameters for the expectation previously defined by the When method
func (e *AuthUserServiceClientMockListAssociationsExpectation) Then(pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse], err error) *AuthUserServiceClientMock {
	e.results = &AuthUserServiceClientMockListAssociationsResults{pp2, err}
	return e.mock
}

// ListAssociations implements AuthUserServiceClient
func (mmListAssociations *AuthUserServiceClientMock) ListAssociations(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse], err error) {
	mm_atomic.AddUint64(&mmListAssociations.beforeListAssociationsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAssociations.afterListAssociationsCounter, 1)

	if mmListAssociations.inspectFuncListAssociations != nil {
		mmListAssociations.inspectFuncListAssociations(ctx, pp1)
	}

	mm_params := &AuthUserServiceClientMockListAssociationsParams{ctx, pp1}

	// Record call args
	mmListAssociations.ListAssociationsMock.mutex.Lock()
	mmListAssociations.ListAssociationsMock.callArgs = append(mmListAssociations.ListAssociationsMock.callArgs, mm_params)
	mmListAssociations.ListAssociationsMock.mutex.Unlock()

	for _, e := range mmListAssociations.ListAssociationsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListAssociations.ListAssociationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAssociations.ListAssociationsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAssociations.ListAssociationsMock.defaultExpectation.params
		mm_got := AuthUserServiceClientMockListAssociationsParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAssociations.t.Errorf("AuthUserServiceClientMock.ListAssociations got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAssociations.ListAssociationsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAssociations.t.Fatal("No results are set for the AuthUserServiceClientMock.ListAssociations")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListAssociations.funcListAssociations != nil {
		return mmListAssociations.funcListAssociations(ctx, pp1)
	}
	mmListAssociations.t.Fatalf("Unexpected call to AuthUserServiceClientMock.ListAssociations. %v %v", ctx, pp1)
	return
}

// ListAssociationsAfterCounter returns a count of finished AuthUserServiceClientMock.ListAssociations invocations
func (mmListAssociations *AuthUserServiceClientMock) ListAssociationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAssociations.afterListAssociationsCounter)
}

// ListAssociationsBeforeCounter returns a count of AuthUserServiceClientMock.ListAssociations invocations
func (mmListAssociations *AuthUserServiceClientMock) ListAssociationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAssociations.beforeListAssociationsCounter)
}

// Calls returns a list of arguments used in each call to AuthUserServiceClientMock.ListAssociations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAssociations *mAuthUserServiceClientMockListAssociations) Calls() []*AuthUserServiceClientMockListAssociationsParams {
	mmListAssociations.mutex.RLock()

	argCopy := make([]*AuthUserServiceClientMockListAssociationsParams, len(mmListAssociations.callArgs))
	copy(argCopy, mmListAssociations.callArgs)

	mmListAssociations.mutex.RUnlock()

	return argCopy
}

// MinimockListAssociationsDone returns true if the count of the ListAssociations invocations corresponds
// the number of defined expectations
func (m *AuthUserServiceClientMock) MinimockListAssociationsDone() bool {
	for _, e := range m.ListAssociationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListAssociationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAssociations != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListAssociationsInspect logs each unmet expectation
func (m *AuthUserServiceClientMock) MinimockListAssociationsInspect() {
	for _, e := range m.ListAssociationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUserServiceClientMock.ListAssociations with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListAssociationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		if m.ListAssociationsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthUserServiceClientMock.ListAssociations")
		} else {
			m.t.Errorf("Expected call to AuthUserServiceClientMock.ListAssociations with params: %#v", *m.ListAssociationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAssociations != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		m.t.Error("Expected call to AuthUserServiceClientMock.ListAssociations")
	}
}

type mAuthUserServiceClientMockRemoveAssociation struct {
	mock               *AuthUserServiceClientMock
	defaultExpectation *AuthUserServiceClientMockRemoveAssociationExpectation
	expectations       []*AuthUserServiceClientMockRemoveAssociationExpectation

	callArgs []*AuthUserServiceClientMockRemoveAssociationParams
	mutex    sync.RWMutex
}

// AuthUserServiceClientMockRemoveAssociationExpectation specifies expectation struct of the AuthUserServiceClient.RemoveAssociation
type AuthUserServiceClientMockRemoveAssociationExpectation struct {
	mock    *AuthUserServiceClientMock
	params  *AuthUserServiceClientMockRemoveAssociationParams
	results *AuthUserServiceClientMockRemoveAssociationResults
	Counter uint64
}

// AuthUserServiceClientMockRemoveAssociationParams contains parameters of the AuthUserServiceClient.RemoveAssociation
type AuthUserServiceClientMockRemoveAssociationParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]
}

// AuthUserServiceClientMockRemoveAssociationResults contains results of the AuthUserServiceClient.RemoveAssociation
type AuthUserServiceClientMockRemoveAssociationResults struct {
	pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse]
	err error
}

// Expect sets up expected params for AuthUserServiceClient.RemoveAssociation
func (mmRemoveAssociation *mAuthUserServiceClientMockRemoveAssociation) Expect(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]) *mAuthUserServiceClientMockRemoveAssociation {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("AuthUserServiceClientMock.RemoveAssociation mock is already set by Set")
	}

	if mmRemoveAssociation.defaultExpectation == nil {
		mmRemoveAssociation.defaultExpectation = &AuthUserServiceClientMockRemoveAssociationExpectation{}
	}

	mmRemoveAssociation.defaultExpectation.params = &AuthUserServiceClientMockRemoveAssociationParams{ctx, pp1}
	for _, e := range mmRemoveAssociation.expectations {
		if minimock.Equal(e.params, mmRemoveAssociation.defaultExpectation.params) {
			mmRemoveAssociation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAssociation.defaultExpectation.params)
		}
	}

	return mmRemoveAssociation
}

// Inspect accepts an inspector function that has same arguments as the AuthUserServiceClient.RemoveAssociation
func (mmRemoveAssociation *mAuthUserServiceClientMockRemoveAssociation) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest])) *mAuthUserServiceClientMockRemoveAssociation {
	if mmRemoveAssociation.mock.inspectFuncRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("Inspect function is already set for AuthUserServiceClientMock.RemoveAssociation")
	}

	mmRemoveAssociation.mock.inspectFuncRemoveAssociation = f

	return mmRemoveAssociation
}

// Return sets up results that will be returned by AuthUserServiceClient.RemoveAssociation
func (mmRemoveAssociation *mAuthUserServiceClientMockRemoveAssociation) Return(pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse], err error) *AuthUserServiceClientMock {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("AuthUserServiceClientMock.RemoveAssociation mock is already set by Set")
	}

	if mmRemoveAssociation.defaultExpectation == nil {
		mmRemoveAssociation.defaultExpectation = &AuthUserServiceClientMockRemoveAssociationExpectation{mock: mmRemoveAssociation.mock}
	}
	mmRemoveAssociation.defaultExpectation.results = &AuthUserServiceClientMockRemoveAssociationResults{pp2, err}
	return mmRemoveAssociation.mock
}

// Set uses given function f to mock the AuthUserServiceClient.RemoveAssociation method
func (mmRemoveAssociation *mAuthUserServiceClientMockRemoveAssociation) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse], err error)) *AuthUserServiceClientMock {
	if mmRemoveAssociation.defaultExpectation != nil {
		mmRemoveAssociation.mock.t.Fatalf("Default expectation is already set for the AuthUserServiceClient.RemoveAssociation method")
	}

	if len(mmRemoveAssociation.expectations) > 0 {
		mmRemoveAssociation.mock.t.Fatalf("Some expectations are already set for the AuthUserServiceClient.RemoveAssociation method")
	}

	mmRemoveAssociation.mock.funcRemoveAssociation = f
	return mmRemoveAssociation.mock
}

// When sets expectation for the AuthUserServiceClient.RemoveAssociation which will trigger the result defined by the following
// Then helper
func (mmRemoveAssociation *mAuthUserServiceClientMockRemoveAssociation) When(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]) *AuthUserServiceClientMockRemoveAssociationExpectation {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("AuthUserServiceClientMock.RemoveAssociation mock is already set by Set")
	}

	expectation := &AuthUserServiceClientMockRemoveAssociationExpectation{
		mock:   mmRemoveAssociation.mock,
		params: &AuthUserServiceClientMockRemoveAssociationParams{ctx, pp1},
	}
	mmRemoveAssociation.expectations = append(mmRemoveAssociation.expectations, expectation)
	return expectation
}

// Then sets up AuthUserServiceClient.RemoveAssociation return parameters for the expectation previously defined by the When method
func (e *AuthUserServiceClientMockRemoveAssociationExpectation) Then(pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse], err error) *AuthUserServiceClientMock {
	e.results = &AuthUserServiceClientMockRemoveAssociationResults{pp2, err}
	return e.mock
}

// RemoveAssociation implements AuthUserServiceClient
func (mmRemoveAssociation *AuthUserServiceClientMock) RemoveAssociation(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveAssociation.beforeRemoveAssociationCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAssociation.afterRemoveAssociationCounter, 1)

	if mmRemoveAssociation.inspectFuncRemoveAssociation != nil {
		mmRemoveAssociation.inspectFuncRemoveAssociation(ctx, pp1)
	}

	mm_params := &AuthUserServiceClientMockRemoveAssociationParams{ctx, pp1}

	// Record call args
	mmRemoveAssociation.RemoveAssociationMock.mutex.Lock()
	mmRemoveAssociation.RemoveAssociationMock.callArgs = append(mmRemoveAssociation.RemoveAssociationMock.callArgs, mm_params)
	mmRemoveAssociation.RemoveAssociationMock.mutex.Unlock()

	for _, e := range mmRemoveAssociation.RemoveAssociationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveAssociation.RemoveAssociationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.params
		mm_got := AuthUserServiceClientMockRemoveAssociationParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveAssociation.t.Errorf("AuthUserServiceClientMock.RemoveAssociation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAssociation.t.Fatal("No results are set for the AuthUserServiceClientMock.RemoveAssociation")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveAssociation.funcRemoveAssociation != nil {
		return mmRemoveAssociation.funcRemoveAssociation(ctx, pp1)
	}
	mmRemoveAssociation.t.Fatalf("Unexpected call to AuthUserServiceClientMock.RemoveAssociation. %v %v", ctx, pp1)
	return
}

// RemoveAssociationAfterCounter returns a count of finished AuthUserServiceClientMock.RemoveAssociation invocations
func (mmRemoveAssociation *AuthUserServiceClientMock) RemoveAssociationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAssociation.afterRemoveAssociationCounter)
}

// RemoveAssociationBeforeCounter returns a count of AuthUserServiceClientMock.RemoveAssociation invocations
func (mmRemoveAssociation *AuthUserServiceClientMock) RemoveAssociationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAssociation.beforeRemoveAssociationCounter)
}

// Calls returns a list of arguments used in each call to AuthUserServiceClientMock.RemoveAssociation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAssociation *mAuthUserServiceClientMockRemoveAssociation) Calls() []*AuthUserServiceClientMockRemoveAssociationParams {
	mmRemoveAssociation.mutex.RLock()

	argCopy := make([]*AuthUserServiceClientMockRemoveAssociationParams, len(mmRemoveAssociation.callArgs))
	copy(argCopy, mmRemoveAssociation.callArgs)

	mmRemoveAssociation.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAssociationDone returns true if the count of the RemoveAssociation invocations corresponds
// the number of defined expectations
func (m *AuthUserServiceClientMock) MinimockRemoveAssociationDone() bool {
	for _, e := range m.RemoveAssociationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAssociationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAssociation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveAssociationInspect logs each unmet expectation
func (m *AuthUserServiceClientMock) MinimockRemoveAssociationInspect() {
	for _, e := range m.RemoveAssociationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUserServiceClientMock.RemoveAssociation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAssociationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		if m.RemoveAssociationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthUserServiceClientMock.RemoveAssociation")
		} else {
			m.t.Errorf("Expected call to AuthUserServiceClientMock.RemoveAssociation with params: %#v", *m.RemoveAssociationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAssociation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		m.t.Error("Expected call to AuthUserServiceClientMock.RemoveAssociation")
	}
}

type mAuthUserServiceClientMockUpsertUser struct {
	mock               *AuthUserServiceClientMock
	defaultExpectation *AuthUserServiceClientMockUpsertUserExpectation
	expectations       []*AuthUserServiceClientMockUpsertUserExpectation

	callArgs []*AuthUserServiceClientMockUpsertUserParams
	mutex    sync.RWMutex
}

// AuthUserServiceClientMockUpsertUserExpectation specifies expectation struct of the AuthUserServiceClient.UpsertUser
type AuthUserServiceClientMockUpsertUserExpectation struct {
	mock    *AuthUserServiceClientMock
	params  *AuthUserServiceClientMockUpsertUserParams
	results *AuthUserServiceClientMockUpsertUserResults
	Counter uint64
}

// AuthUserServiceClientMockUpsertUserParams contains parameters of the AuthUserServiceClient.UpsertUser
type AuthUserServiceClientMockUpsertUserParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]
}

// AuthUserServiceClientMockUpsertUserResults contains results of the AuthUserServiceClient.UpsertUser
type AuthUserServiceClientMockUpsertUserResults struct {
	pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse]
	err error
}

// Expect sets up expected params for AuthUserServiceClient.UpsertUser
func (mmUpsertUser *mAuthUserServiceClientMockUpsertUser) Expect(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]) *mAuthUserServiceClientMockUpsertUser {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("AuthUserServiceClientMock.UpsertUser mock is already set by Set")
	}

	if mmUpsertUser.defaultExpectation == nil {
		mmUpsertUser.defaultExpectation = &AuthUserServiceClientMockUpsertUserExpectation{}
	}

	mmUpsertUser.defaultExpectation.params = &AuthUserServiceClientMockUpsertUserParams{ctx, pp1}
	for _, e := range mmUpsertUser.expectations {
		if minimock.Equal(e.params, mmUpsertUser.defaultExpectation.params) {
			mmUpsertUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertUser.defaultExpectation.params)
		}
	}

	return mmUpsertUser
}

// Inspect accepts an inspector function that has same arguments as the AuthUserServiceClient.UpsertUser
func (mmUpsertUser *mAuthUserServiceClientMockUpsertUser) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest])) *mAuthUserServiceClientMockUpsertUser {
	if mmUpsertUser.mock.inspectFuncUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("Inspect function is already set for AuthUserServiceClientMock.UpsertUser")
	}

	mmUpsertUser.mock.inspectFuncUpsertUser = f

	return mmUpsertUser
}

// Return sets up results that will be returned by AuthUserServiceClient.UpsertUser
func (mmUpsertUser *mAuthUserServiceClientMockUpsertUser) Return(pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse], err error) *AuthUserServiceClientMock {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("AuthUserServiceClientMock.UpsertUser mock is already set by Set")
	}

	if mmUpsertUser.defaultExpectation == nil {
		mmUpsertUser.defaultExpectation = &AuthUserServiceClientMockUpsertUserExpectation{mock: mmUpsertUser.mock}
	}
	mmUpsertUser.defaultExpectation.results = &AuthUserServiceClientMockUpsertUserResults{pp2, err}
	return mmUpsertUser.mock
}

// Set uses given function f to mock the AuthUserServiceClient.UpsertUser method
func (mmUpsertUser *mAuthUserServiceClientMockUpsertUser) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse], err error)) *AuthUserServiceClientMock {
	if mmUpsertUser.defaultExpectation != nil {
		mmUpsertUser.mock.t.Fatalf("Default expectation is already set for the AuthUserServiceClient.UpsertUser method")
	}

	if len(mmUpsertUser.expectations) > 0 {
		mmUpsertUser.mock.t.Fatalf("Some expectations are already set for the AuthUserServiceClient.UpsertUser method")
	}

	mmUpsertUser.mock.funcUpsertUser = f
	return mmUpsertUser.mock
}

// When sets expectation for the AuthUserServiceClient.UpsertUser which will trigger the result defined by the following
// Then helper
func (mmUpsertUser *mAuthUserServiceClientMockUpsertUser) When(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]) *AuthUserServiceClientMockUpsertUserExpectation {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("AuthUserServiceClientMock.UpsertUser mock is already set by Set")
	}

	expectation := &AuthUserServiceClientMockUpsertUserExpectation{
		mock:   mmUpsertUser.mock,
		params: &AuthUserServiceClientMockUpsertUserParams{ctx, pp1},
	}
	mmUpsertUser.expectations = append(mmUpsertUser.expectations, expectation)
	return expectation
}

// Then sets up AuthUserServiceClient.UpsertUser return parameters for the expectation previously defined by the When method
func (e *AuthUserServiceClientMockUpsertUserExpectation) Then(pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse], err error) *AuthUserServiceClientMock {
	e.results = &AuthUserServiceClientMockUpsertUserResults{pp2, err}
	return e.mock
}

// UpsertUser implements AuthUserServiceClient
func (mmUpsertUser *AuthUserServiceClientMock) UpsertUser(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse], err error) {
	mm_atomic.AddUint64(&mmUpsertUser.beforeUpsertUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertUser.afterUpsertUserCounter, 1)

	if mmUpsertUser.inspectFuncUpsertUser != nil {
		mmUpsertUser.inspectFuncUpsertUser(ctx, pp1)
	}

	mm_params := &AuthUserServiceClientMockUpsertUserParams{ctx, pp1}

	// Record call args
	mmUpsertUser.UpsertUserMock.mutex.Lock()
	mmUpsertUser.UpsertUserMock.callArgs = append(mmUpsertUser.UpsertUserMock.callArgs, mm_params)
	mmUpsertUser.UpsertUserMock.mutex.Unlock()

	for _, e := range mmUpsertUser.UpsertUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpsertUser.UpsertUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertUser.UpsertUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertUser.UpsertUserMock.defaultExpectation.params
		mm_got := AuthUserServiceClientMockUpsertUserParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertUser.t.Errorf("AuthUserServiceClientMock.UpsertUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertUser.UpsertUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertUser.t.Fatal("No results are set for the AuthUserServiceClientMock.UpsertUser")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpsertUser.funcUpsertUser != nil {
		return mmUpsertUser.funcUpsertUser(ctx, pp1)
	}
	mmUpsertUser.t.Fatalf("Unexpected call to AuthUserServiceClientMock.UpsertUser. %v %v", ctx, pp1)
	return
}

// UpsertUserAfterCounter returns a count of finished AuthUserServiceClientMock.UpsertUser invocations
func (mmUpsertUser *AuthUserServiceClientMock) UpsertUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertUser.afterUpsertUserCounter)
}

// UpsertUserBeforeCounter returns a count of AuthUserServiceClientMock.UpsertUser invocations
func (mmUpsertUser *AuthUserServiceClientMock) UpsertUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertUser.beforeUpsertUserCounter)
}

// Calls returns a list of arguments used in each call to AuthUserServiceClientMock.UpsertUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertUser *mAuthUserServiceClientMockUpsertUser) Calls() []*AuthUserServiceClientMockUpsertUserParams {
	mmUpsertUser.mutex.RLock()

	argCopy := make([]*AuthUserServiceClientMockUpsertUserParams, len(mmUpsertUser.callArgs))
	copy(argCopy, mmUpsertUser.callArgs)

	mmUpsertUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertUserDone returns true if the count of the UpsertUser invocations corresponds
// the number of defined expectations
func (m *AuthUserServiceClientMock) MinimockUpsertUserDone() bool {
	for _, e := range m.UpsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertUser != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertUserInspect logs each unmet expectation
func (m *AuthUserServiceClientMock) MinimockUpsertUserInspect() {
	for _, e := range m.UpsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUserServiceClientMock.UpsertUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		if m.UpsertUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthUserServiceClientMock.UpsertUser")
		} else {
			m.t.Errorf("Expected call to AuthUserServiceClientMock.UpsertUser with params: %#v", *m.UpsertUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertUser != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		m.t.Error("Expected call to AuthUserServiceClientMock.UpsertUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthUserServiceClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetAuthUrlInspect()

		m.MinimockListAssociationsInspect()

		m.MinimockRemoveAssociationInspect()

		m.MinimockUpsertUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthUserServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthUserServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAuthUrlDone() &&
		m.MinimockListAssociationsDone() &&
		m.MinimockRemoveAssociationDone() &&
		m.MinimockUpsertUserDone()
}
