package corev1connect

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/koblas/grpc-todo/gen/core/v1/corev1connect.AuthUserServiceHandler -o ./auth_user_service_handler_mock.go -n AuthUserServiceHandlerMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	connect_go "github.com/bufbuild/connect-go"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/koblas/grpc-todo/gen/core/v1"
)

// AuthUserServiceHandlerMock implements AuthUserServiceHandler
type AuthUserServiceHandlerMock struct {
	t minimock.Tester

	funcGetAuthUrl          func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse], err error)
	inspectFuncGetAuthUrl   func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest])
	afterGetAuthUrlCounter  uint64
	beforeGetAuthUrlCounter uint64
	GetAuthUrlMock          mAuthUserServiceHandlerMockGetAuthUrl

	funcListAssociations          func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse], err error)
	inspectFuncListAssociations   func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest])
	afterListAssociationsCounter  uint64
	beforeListAssociationsCounter uint64
	ListAssociationsMock          mAuthUserServiceHandlerMockListAssociations

	funcRemoveAssociation          func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse], err error)
	inspectFuncRemoveAssociation   func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest])
	afterRemoveAssociationCounter  uint64
	beforeRemoveAssociationCounter uint64
	RemoveAssociationMock          mAuthUserServiceHandlerMockRemoveAssociation

	funcUpsertUser          func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse], err error)
	inspectFuncUpsertUser   func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest])
	afterUpsertUserCounter  uint64
	beforeUpsertUserCounter uint64
	UpsertUserMock          mAuthUserServiceHandlerMockUpsertUser
}

// NewAuthUserServiceHandlerMock returns a mock for AuthUserServiceHandler
func NewAuthUserServiceHandlerMock(t minimock.Tester) *AuthUserServiceHandlerMock {
	m := &AuthUserServiceHandlerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAuthUrlMock = mAuthUserServiceHandlerMockGetAuthUrl{mock: m}
	m.GetAuthUrlMock.callArgs = []*AuthUserServiceHandlerMockGetAuthUrlParams{}

	m.ListAssociationsMock = mAuthUserServiceHandlerMockListAssociations{mock: m}
	m.ListAssociationsMock.callArgs = []*AuthUserServiceHandlerMockListAssociationsParams{}

	m.RemoveAssociationMock = mAuthUserServiceHandlerMockRemoveAssociation{mock: m}
	m.RemoveAssociationMock.callArgs = []*AuthUserServiceHandlerMockRemoveAssociationParams{}

	m.UpsertUserMock = mAuthUserServiceHandlerMockUpsertUser{mock: m}
	m.UpsertUserMock.callArgs = []*AuthUserServiceHandlerMockUpsertUserParams{}

	return m
}

type mAuthUserServiceHandlerMockGetAuthUrl struct {
	mock               *AuthUserServiceHandlerMock
	defaultExpectation *AuthUserServiceHandlerMockGetAuthUrlExpectation
	expectations       []*AuthUserServiceHandlerMockGetAuthUrlExpectation

	callArgs []*AuthUserServiceHandlerMockGetAuthUrlParams
	mutex    sync.RWMutex
}

// AuthUserServiceHandlerMockGetAuthUrlExpectation specifies expectation struct of the AuthUserServiceHandler.GetAuthUrl
type AuthUserServiceHandlerMockGetAuthUrlExpectation struct {
	mock    *AuthUserServiceHandlerMock
	params  *AuthUserServiceHandlerMockGetAuthUrlParams
	results *AuthUserServiceHandlerMockGetAuthUrlResults
	Counter uint64
}

// AuthUserServiceHandlerMockGetAuthUrlParams contains parameters of the AuthUserServiceHandler.GetAuthUrl
type AuthUserServiceHandlerMockGetAuthUrlParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]
}

// AuthUserServiceHandlerMockGetAuthUrlResults contains results of the AuthUserServiceHandler.GetAuthUrl
type AuthUserServiceHandlerMockGetAuthUrlResults struct {
	pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse]
	err error
}

// Expect sets up expected params for AuthUserServiceHandler.GetAuthUrl
func (mmGetAuthUrl *mAuthUserServiceHandlerMockGetAuthUrl) Expect(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]) *mAuthUserServiceHandlerMockGetAuthUrl {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("AuthUserServiceHandlerMock.GetAuthUrl mock is already set by Set")
	}

	if mmGetAuthUrl.defaultExpectation == nil {
		mmGetAuthUrl.defaultExpectation = &AuthUserServiceHandlerMockGetAuthUrlExpectation{}
	}

	mmGetAuthUrl.defaultExpectation.params = &AuthUserServiceHandlerMockGetAuthUrlParams{ctx, pp1}
	for _, e := range mmGetAuthUrl.expectations {
		if minimock.Equal(e.params, mmGetAuthUrl.defaultExpectation.params) {
			mmGetAuthUrl.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAuthUrl.defaultExpectation.params)
		}
	}

	return mmGetAuthUrl
}

// Inspect accepts an inspector function that has same arguments as the AuthUserServiceHandler.GetAuthUrl
func (mmGetAuthUrl *mAuthUserServiceHandlerMockGetAuthUrl) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest])) *mAuthUserServiceHandlerMockGetAuthUrl {
	if mmGetAuthUrl.mock.inspectFuncGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("Inspect function is already set for AuthUserServiceHandlerMock.GetAuthUrl")
	}

	mmGetAuthUrl.mock.inspectFuncGetAuthUrl = f

	return mmGetAuthUrl
}

// Return sets up results that will be returned by AuthUserServiceHandler.GetAuthUrl
func (mmGetAuthUrl *mAuthUserServiceHandlerMockGetAuthUrl) Return(pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse], err error) *AuthUserServiceHandlerMock {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("AuthUserServiceHandlerMock.GetAuthUrl mock is already set by Set")
	}

	if mmGetAuthUrl.defaultExpectation == nil {
		mmGetAuthUrl.defaultExpectation = &AuthUserServiceHandlerMockGetAuthUrlExpectation{mock: mmGetAuthUrl.mock}
	}
	mmGetAuthUrl.defaultExpectation.results = &AuthUserServiceHandlerMockGetAuthUrlResults{pp2, err}
	return mmGetAuthUrl.mock
}

// Set uses given function f to mock the AuthUserServiceHandler.GetAuthUrl method
func (mmGetAuthUrl *mAuthUserServiceHandlerMockGetAuthUrl) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse], err error)) *AuthUserServiceHandlerMock {
	if mmGetAuthUrl.defaultExpectation != nil {
		mmGetAuthUrl.mock.t.Fatalf("Default expectation is already set for the AuthUserServiceHandler.GetAuthUrl method")
	}

	if len(mmGetAuthUrl.expectations) > 0 {
		mmGetAuthUrl.mock.t.Fatalf("Some expectations are already set for the AuthUserServiceHandler.GetAuthUrl method")
	}

	mmGetAuthUrl.mock.funcGetAuthUrl = f
	return mmGetAuthUrl.mock
}

// When sets expectation for the AuthUserServiceHandler.GetAuthUrl which will trigger the result defined by the following
// Then helper
func (mmGetAuthUrl *mAuthUserServiceHandlerMockGetAuthUrl) When(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]) *AuthUserServiceHandlerMockGetAuthUrlExpectation {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("AuthUserServiceHandlerMock.GetAuthUrl mock is already set by Set")
	}

	expectation := &AuthUserServiceHandlerMockGetAuthUrlExpectation{
		mock:   mmGetAuthUrl.mock,
		params: &AuthUserServiceHandlerMockGetAuthUrlParams{ctx, pp1},
	}
	mmGetAuthUrl.expectations = append(mmGetAuthUrl.expectations, expectation)
	return expectation
}

// Then sets up AuthUserServiceHandler.GetAuthUrl return parameters for the expectation previously defined by the When method
func (e *AuthUserServiceHandlerMockGetAuthUrlExpectation) Then(pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse], err error) *AuthUserServiceHandlerMock {
	e.results = &AuthUserServiceHandlerMockGetAuthUrlResults{pp2, err}
	return e.mock
}

// GetAuthUrl implements AuthUserServiceHandler
func (mmGetAuthUrl *AuthUserServiceHandlerMock) GetAuthUrl(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceGetAuthUrlResponse], err error) {
	mm_atomic.AddUint64(&mmGetAuthUrl.beforeGetAuthUrlCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAuthUrl.afterGetAuthUrlCounter, 1)

	if mmGetAuthUrl.inspectFuncGetAuthUrl != nil {
		mmGetAuthUrl.inspectFuncGetAuthUrl(ctx, pp1)
	}

	mm_params := &AuthUserServiceHandlerMockGetAuthUrlParams{ctx, pp1}

	// Record call args
	mmGetAuthUrl.GetAuthUrlMock.mutex.Lock()
	mmGetAuthUrl.GetAuthUrlMock.callArgs = append(mmGetAuthUrl.GetAuthUrlMock.callArgs, mm_params)
	mmGetAuthUrl.GetAuthUrlMock.mutex.Unlock()

	for _, e := range mmGetAuthUrl.GetAuthUrlMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetAuthUrl.GetAuthUrlMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.params
		mm_got := AuthUserServiceHandlerMockGetAuthUrlParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAuthUrl.t.Errorf("AuthUserServiceHandlerMock.GetAuthUrl got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAuthUrl.t.Fatal("No results are set for the AuthUserServiceHandlerMock.GetAuthUrl")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetAuthUrl.funcGetAuthUrl != nil {
		return mmGetAuthUrl.funcGetAuthUrl(ctx, pp1)
	}
	mmGetAuthUrl.t.Fatalf("Unexpected call to AuthUserServiceHandlerMock.GetAuthUrl. %v %v", ctx, pp1)
	return
}

// GetAuthUrlAfterCounter returns a count of finished AuthUserServiceHandlerMock.GetAuthUrl invocations
func (mmGetAuthUrl *AuthUserServiceHandlerMock) GetAuthUrlAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthUrl.afterGetAuthUrlCounter)
}

// GetAuthUrlBeforeCounter returns a count of AuthUserServiceHandlerMock.GetAuthUrl invocations
func (mmGetAuthUrl *AuthUserServiceHandlerMock) GetAuthUrlBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthUrl.beforeGetAuthUrlCounter)
}

// Calls returns a list of arguments used in each call to AuthUserServiceHandlerMock.GetAuthUrl.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAuthUrl *mAuthUserServiceHandlerMockGetAuthUrl) Calls() []*AuthUserServiceHandlerMockGetAuthUrlParams {
	mmGetAuthUrl.mutex.RLock()

	argCopy := make([]*AuthUserServiceHandlerMockGetAuthUrlParams, len(mmGetAuthUrl.callArgs))
	copy(argCopy, mmGetAuthUrl.callArgs)

	mmGetAuthUrl.mutex.RUnlock()

	return argCopy
}

// MinimockGetAuthUrlDone returns true if the count of the GetAuthUrl invocations corresponds
// the number of defined expectations
func (m *AuthUserServiceHandlerMock) MinimockGetAuthUrlDone() bool {
	for _, e := range m.GetAuthUrlMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthUrlMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthUrl != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAuthUrlInspect logs each unmet expectation
func (m *AuthUserServiceHandlerMock) MinimockGetAuthUrlInspect() {
	for _, e := range m.GetAuthUrlMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUserServiceHandlerMock.GetAuthUrl with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthUrlMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		if m.GetAuthUrlMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthUserServiceHandlerMock.GetAuthUrl")
		} else {
			m.t.Errorf("Expected call to AuthUserServiceHandlerMock.GetAuthUrl with params: %#v", *m.GetAuthUrlMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthUrl != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		m.t.Error("Expected call to AuthUserServiceHandlerMock.GetAuthUrl")
	}
}

type mAuthUserServiceHandlerMockListAssociations struct {
	mock               *AuthUserServiceHandlerMock
	defaultExpectation *AuthUserServiceHandlerMockListAssociationsExpectation
	expectations       []*AuthUserServiceHandlerMockListAssociationsExpectation

	callArgs []*AuthUserServiceHandlerMockListAssociationsParams
	mutex    sync.RWMutex
}

// AuthUserServiceHandlerMockListAssociationsExpectation specifies expectation struct of the AuthUserServiceHandler.ListAssociations
type AuthUserServiceHandlerMockListAssociationsExpectation struct {
	mock    *AuthUserServiceHandlerMock
	params  *AuthUserServiceHandlerMockListAssociationsParams
	results *AuthUserServiceHandlerMockListAssociationsResults
	Counter uint64
}

// AuthUserServiceHandlerMockListAssociationsParams contains parameters of the AuthUserServiceHandler.ListAssociations
type AuthUserServiceHandlerMockListAssociationsParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]
}

// AuthUserServiceHandlerMockListAssociationsResults contains results of the AuthUserServiceHandler.ListAssociations
type AuthUserServiceHandlerMockListAssociationsResults struct {
	pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse]
	err error
}

// Expect sets up expected params for AuthUserServiceHandler.ListAssociations
func (mmListAssociations *mAuthUserServiceHandlerMockListAssociations) Expect(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]) *mAuthUserServiceHandlerMockListAssociations {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("AuthUserServiceHandlerMock.ListAssociations mock is already set by Set")
	}

	if mmListAssociations.defaultExpectation == nil {
		mmListAssociations.defaultExpectation = &AuthUserServiceHandlerMockListAssociationsExpectation{}
	}

	mmListAssociations.defaultExpectation.params = &AuthUserServiceHandlerMockListAssociationsParams{ctx, pp1}
	for _, e := range mmListAssociations.expectations {
		if minimock.Equal(e.params, mmListAssociations.defaultExpectation.params) {
			mmListAssociations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAssociations.defaultExpectation.params)
		}
	}

	return mmListAssociations
}

// Inspect accepts an inspector function that has same arguments as the AuthUserServiceHandler.ListAssociations
func (mmListAssociations *mAuthUserServiceHandlerMockListAssociations) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest])) *mAuthUserServiceHandlerMockListAssociations {
	if mmListAssociations.mock.inspectFuncListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("Inspect function is already set for AuthUserServiceHandlerMock.ListAssociations")
	}

	mmListAssociations.mock.inspectFuncListAssociations = f

	return mmListAssociations
}

// Return sets up results that will be returned by AuthUserServiceHandler.ListAssociations
func (mmListAssociations *mAuthUserServiceHandlerMockListAssociations) Return(pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse], err error) *AuthUserServiceHandlerMock {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("AuthUserServiceHandlerMock.ListAssociations mock is already set by Set")
	}

	if mmListAssociations.defaultExpectation == nil {
		mmListAssociations.defaultExpectation = &AuthUserServiceHandlerMockListAssociationsExpectation{mock: mmListAssociations.mock}
	}
	mmListAssociations.defaultExpectation.results = &AuthUserServiceHandlerMockListAssociationsResults{pp2, err}
	return mmListAssociations.mock
}

// Set uses given function f to mock the AuthUserServiceHandler.ListAssociations method
func (mmListAssociations *mAuthUserServiceHandlerMockListAssociations) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse], err error)) *AuthUserServiceHandlerMock {
	if mmListAssociations.defaultExpectation != nil {
		mmListAssociations.mock.t.Fatalf("Default expectation is already set for the AuthUserServiceHandler.ListAssociations method")
	}

	if len(mmListAssociations.expectations) > 0 {
		mmListAssociations.mock.t.Fatalf("Some expectations are already set for the AuthUserServiceHandler.ListAssociations method")
	}

	mmListAssociations.mock.funcListAssociations = f
	return mmListAssociations.mock
}

// When sets expectation for the AuthUserServiceHandler.ListAssociations which will trigger the result defined by the following
// Then helper
func (mmListAssociations *mAuthUserServiceHandlerMockListAssociations) When(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]) *AuthUserServiceHandlerMockListAssociationsExpectation {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("AuthUserServiceHandlerMock.ListAssociations mock is already set by Set")
	}

	expectation := &AuthUserServiceHandlerMockListAssociationsExpectation{
		mock:   mmListAssociations.mock,
		params: &AuthUserServiceHandlerMockListAssociationsParams{ctx, pp1},
	}
	mmListAssociations.expectations = append(mmListAssociations.expectations, expectation)
	return expectation
}

// Then sets up AuthUserServiceHandler.ListAssociations return parameters for the expectation previously defined by the When method
func (e *AuthUserServiceHandlerMockListAssociationsExpectation) Then(pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse], err error) *AuthUserServiceHandlerMock {
	e.results = &AuthUserServiceHandlerMockListAssociationsResults{pp2, err}
	return e.mock
}

// ListAssociations implements AuthUserServiceHandler
func (mmListAssociations *AuthUserServiceHandlerMock) ListAssociations(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceListAssociationsResponse], err error) {
	mm_atomic.AddUint64(&mmListAssociations.beforeListAssociationsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAssociations.afterListAssociationsCounter, 1)

	if mmListAssociations.inspectFuncListAssociations != nil {
		mmListAssociations.inspectFuncListAssociations(ctx, pp1)
	}

	mm_params := &AuthUserServiceHandlerMockListAssociationsParams{ctx, pp1}

	// Record call args
	mmListAssociations.ListAssociationsMock.mutex.Lock()
	mmListAssociations.ListAssociationsMock.callArgs = append(mmListAssociations.ListAssociationsMock.callArgs, mm_params)
	mmListAssociations.ListAssociationsMock.mutex.Unlock()

	for _, e := range mmListAssociations.ListAssociationsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListAssociations.ListAssociationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAssociations.ListAssociationsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAssociations.ListAssociationsMock.defaultExpectation.params
		mm_got := AuthUserServiceHandlerMockListAssociationsParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAssociations.t.Errorf("AuthUserServiceHandlerMock.ListAssociations got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAssociations.ListAssociationsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAssociations.t.Fatal("No results are set for the AuthUserServiceHandlerMock.ListAssociations")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListAssociations.funcListAssociations != nil {
		return mmListAssociations.funcListAssociations(ctx, pp1)
	}
	mmListAssociations.t.Fatalf("Unexpected call to AuthUserServiceHandlerMock.ListAssociations. %v %v", ctx, pp1)
	return
}

// ListAssociationsAfterCounter returns a count of finished AuthUserServiceHandlerMock.ListAssociations invocations
func (mmListAssociations *AuthUserServiceHandlerMock) ListAssociationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAssociations.afterListAssociationsCounter)
}

// ListAssociationsBeforeCounter returns a count of AuthUserServiceHandlerMock.ListAssociations invocations
func (mmListAssociations *AuthUserServiceHandlerMock) ListAssociationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAssociations.beforeListAssociationsCounter)
}

// Calls returns a list of arguments used in each call to AuthUserServiceHandlerMock.ListAssociations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAssociations *mAuthUserServiceHandlerMockListAssociations) Calls() []*AuthUserServiceHandlerMockListAssociationsParams {
	mmListAssociations.mutex.RLock()

	argCopy := make([]*AuthUserServiceHandlerMockListAssociationsParams, len(mmListAssociations.callArgs))
	copy(argCopy, mmListAssociations.callArgs)

	mmListAssociations.mutex.RUnlock()

	return argCopy
}

// MinimockListAssociationsDone returns true if the count of the ListAssociations invocations corresponds
// the number of defined expectations
func (m *AuthUserServiceHandlerMock) MinimockListAssociationsDone() bool {
	for _, e := range m.ListAssociationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListAssociationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAssociations != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListAssociationsInspect logs each unmet expectation
func (m *AuthUserServiceHandlerMock) MinimockListAssociationsInspect() {
	for _, e := range m.ListAssociationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUserServiceHandlerMock.ListAssociations with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListAssociationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		if m.ListAssociationsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthUserServiceHandlerMock.ListAssociations")
		} else {
			m.t.Errorf("Expected call to AuthUserServiceHandlerMock.ListAssociations with params: %#v", *m.ListAssociationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAssociations != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		m.t.Error("Expected call to AuthUserServiceHandlerMock.ListAssociations")
	}
}

type mAuthUserServiceHandlerMockRemoveAssociation struct {
	mock               *AuthUserServiceHandlerMock
	defaultExpectation *AuthUserServiceHandlerMockRemoveAssociationExpectation
	expectations       []*AuthUserServiceHandlerMockRemoveAssociationExpectation

	callArgs []*AuthUserServiceHandlerMockRemoveAssociationParams
	mutex    sync.RWMutex
}

// AuthUserServiceHandlerMockRemoveAssociationExpectation specifies expectation struct of the AuthUserServiceHandler.RemoveAssociation
type AuthUserServiceHandlerMockRemoveAssociationExpectation struct {
	mock    *AuthUserServiceHandlerMock
	params  *AuthUserServiceHandlerMockRemoveAssociationParams
	results *AuthUserServiceHandlerMockRemoveAssociationResults
	Counter uint64
}

// AuthUserServiceHandlerMockRemoveAssociationParams contains parameters of the AuthUserServiceHandler.RemoveAssociation
type AuthUserServiceHandlerMockRemoveAssociationParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]
}

// AuthUserServiceHandlerMockRemoveAssociationResults contains results of the AuthUserServiceHandler.RemoveAssociation
type AuthUserServiceHandlerMockRemoveAssociationResults struct {
	pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse]
	err error
}

// Expect sets up expected params for AuthUserServiceHandler.RemoveAssociation
func (mmRemoveAssociation *mAuthUserServiceHandlerMockRemoveAssociation) Expect(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]) *mAuthUserServiceHandlerMockRemoveAssociation {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("AuthUserServiceHandlerMock.RemoveAssociation mock is already set by Set")
	}

	if mmRemoveAssociation.defaultExpectation == nil {
		mmRemoveAssociation.defaultExpectation = &AuthUserServiceHandlerMockRemoveAssociationExpectation{}
	}

	mmRemoveAssociation.defaultExpectation.params = &AuthUserServiceHandlerMockRemoveAssociationParams{ctx, pp1}
	for _, e := range mmRemoveAssociation.expectations {
		if minimock.Equal(e.params, mmRemoveAssociation.defaultExpectation.params) {
			mmRemoveAssociation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAssociation.defaultExpectation.params)
		}
	}

	return mmRemoveAssociation
}

// Inspect accepts an inspector function that has same arguments as the AuthUserServiceHandler.RemoveAssociation
func (mmRemoveAssociation *mAuthUserServiceHandlerMockRemoveAssociation) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest])) *mAuthUserServiceHandlerMockRemoveAssociation {
	if mmRemoveAssociation.mock.inspectFuncRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("Inspect function is already set for AuthUserServiceHandlerMock.RemoveAssociation")
	}

	mmRemoveAssociation.mock.inspectFuncRemoveAssociation = f

	return mmRemoveAssociation
}

// Return sets up results that will be returned by AuthUserServiceHandler.RemoveAssociation
func (mmRemoveAssociation *mAuthUserServiceHandlerMockRemoveAssociation) Return(pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse], err error) *AuthUserServiceHandlerMock {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("AuthUserServiceHandlerMock.RemoveAssociation mock is already set by Set")
	}

	if mmRemoveAssociation.defaultExpectation == nil {
		mmRemoveAssociation.defaultExpectation = &AuthUserServiceHandlerMockRemoveAssociationExpectation{mock: mmRemoveAssociation.mock}
	}
	mmRemoveAssociation.defaultExpectation.results = &AuthUserServiceHandlerMockRemoveAssociationResults{pp2, err}
	return mmRemoveAssociation.mock
}

// Set uses given function f to mock the AuthUserServiceHandler.RemoveAssociation method
func (mmRemoveAssociation *mAuthUserServiceHandlerMockRemoveAssociation) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse], err error)) *AuthUserServiceHandlerMock {
	if mmRemoveAssociation.defaultExpectation != nil {
		mmRemoveAssociation.mock.t.Fatalf("Default expectation is already set for the AuthUserServiceHandler.RemoveAssociation method")
	}

	if len(mmRemoveAssociation.expectations) > 0 {
		mmRemoveAssociation.mock.t.Fatalf("Some expectations are already set for the AuthUserServiceHandler.RemoveAssociation method")
	}

	mmRemoveAssociation.mock.funcRemoveAssociation = f
	return mmRemoveAssociation.mock
}

// When sets expectation for the AuthUserServiceHandler.RemoveAssociation which will trigger the result defined by the following
// Then helper
func (mmRemoveAssociation *mAuthUserServiceHandlerMockRemoveAssociation) When(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]) *AuthUserServiceHandlerMockRemoveAssociationExpectation {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("AuthUserServiceHandlerMock.RemoveAssociation mock is already set by Set")
	}

	expectation := &AuthUserServiceHandlerMockRemoveAssociationExpectation{
		mock:   mmRemoveAssociation.mock,
		params: &AuthUserServiceHandlerMockRemoveAssociationParams{ctx, pp1},
	}
	mmRemoveAssociation.expectations = append(mmRemoveAssociation.expectations, expectation)
	return expectation
}

// Then sets up AuthUserServiceHandler.RemoveAssociation return parameters for the expectation previously defined by the When method
func (e *AuthUserServiceHandlerMockRemoveAssociationExpectation) Then(pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse], err error) *AuthUserServiceHandlerMock {
	e.results = &AuthUserServiceHandlerMockRemoveAssociationResults{pp2, err}
	return e.mock
}

// RemoveAssociation implements AuthUserServiceHandler
func (mmRemoveAssociation *AuthUserServiceHandlerMock) RemoveAssociation(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceRemoveAssociationResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveAssociation.beforeRemoveAssociationCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAssociation.afterRemoveAssociationCounter, 1)

	if mmRemoveAssociation.inspectFuncRemoveAssociation != nil {
		mmRemoveAssociation.inspectFuncRemoveAssociation(ctx, pp1)
	}

	mm_params := &AuthUserServiceHandlerMockRemoveAssociationParams{ctx, pp1}

	// Record call args
	mmRemoveAssociation.RemoveAssociationMock.mutex.Lock()
	mmRemoveAssociation.RemoveAssociationMock.callArgs = append(mmRemoveAssociation.RemoveAssociationMock.callArgs, mm_params)
	mmRemoveAssociation.RemoveAssociationMock.mutex.Unlock()

	for _, e := range mmRemoveAssociation.RemoveAssociationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveAssociation.RemoveAssociationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.params
		mm_got := AuthUserServiceHandlerMockRemoveAssociationParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveAssociation.t.Errorf("AuthUserServiceHandlerMock.RemoveAssociation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAssociation.t.Fatal("No results are set for the AuthUserServiceHandlerMock.RemoveAssociation")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveAssociation.funcRemoveAssociation != nil {
		return mmRemoveAssociation.funcRemoveAssociation(ctx, pp1)
	}
	mmRemoveAssociation.t.Fatalf("Unexpected call to AuthUserServiceHandlerMock.RemoveAssociation. %v %v", ctx, pp1)
	return
}

// RemoveAssociationAfterCounter returns a count of finished AuthUserServiceHandlerMock.RemoveAssociation invocations
func (mmRemoveAssociation *AuthUserServiceHandlerMock) RemoveAssociationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAssociation.afterRemoveAssociationCounter)
}

// RemoveAssociationBeforeCounter returns a count of AuthUserServiceHandlerMock.RemoveAssociation invocations
func (mmRemoveAssociation *AuthUserServiceHandlerMock) RemoveAssociationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAssociation.beforeRemoveAssociationCounter)
}

// Calls returns a list of arguments used in each call to AuthUserServiceHandlerMock.RemoveAssociation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAssociation *mAuthUserServiceHandlerMockRemoveAssociation) Calls() []*AuthUserServiceHandlerMockRemoveAssociationParams {
	mmRemoveAssociation.mutex.RLock()

	argCopy := make([]*AuthUserServiceHandlerMockRemoveAssociationParams, len(mmRemoveAssociation.callArgs))
	copy(argCopy, mmRemoveAssociation.callArgs)

	mmRemoveAssociation.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAssociationDone returns true if the count of the RemoveAssociation invocations corresponds
// the number of defined expectations
func (m *AuthUserServiceHandlerMock) MinimockRemoveAssociationDone() bool {
	for _, e := range m.RemoveAssociationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAssociationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAssociation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveAssociationInspect logs each unmet expectation
func (m *AuthUserServiceHandlerMock) MinimockRemoveAssociationInspect() {
	for _, e := range m.RemoveAssociationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUserServiceHandlerMock.RemoveAssociation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAssociationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		if m.RemoveAssociationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthUserServiceHandlerMock.RemoveAssociation")
		} else {
			m.t.Errorf("Expected call to AuthUserServiceHandlerMock.RemoveAssociation with params: %#v", *m.RemoveAssociationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAssociation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		m.t.Error("Expected call to AuthUserServiceHandlerMock.RemoveAssociation")
	}
}

type mAuthUserServiceHandlerMockUpsertUser struct {
	mock               *AuthUserServiceHandlerMock
	defaultExpectation *AuthUserServiceHandlerMockUpsertUserExpectation
	expectations       []*AuthUserServiceHandlerMockUpsertUserExpectation

	callArgs []*AuthUserServiceHandlerMockUpsertUserParams
	mutex    sync.RWMutex
}

// AuthUserServiceHandlerMockUpsertUserExpectation specifies expectation struct of the AuthUserServiceHandler.UpsertUser
type AuthUserServiceHandlerMockUpsertUserExpectation struct {
	mock    *AuthUserServiceHandlerMock
	params  *AuthUserServiceHandlerMockUpsertUserParams
	results *AuthUserServiceHandlerMockUpsertUserResults
	Counter uint64
}

// AuthUserServiceHandlerMockUpsertUserParams contains parameters of the AuthUserServiceHandler.UpsertUser
type AuthUserServiceHandlerMockUpsertUserParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]
}

// AuthUserServiceHandlerMockUpsertUserResults contains results of the AuthUserServiceHandler.UpsertUser
type AuthUserServiceHandlerMockUpsertUserResults struct {
	pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse]
	err error
}

// Expect sets up expected params for AuthUserServiceHandler.UpsertUser
func (mmUpsertUser *mAuthUserServiceHandlerMockUpsertUser) Expect(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]) *mAuthUserServiceHandlerMockUpsertUser {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("AuthUserServiceHandlerMock.UpsertUser mock is already set by Set")
	}

	if mmUpsertUser.defaultExpectation == nil {
		mmUpsertUser.defaultExpectation = &AuthUserServiceHandlerMockUpsertUserExpectation{}
	}

	mmUpsertUser.defaultExpectation.params = &AuthUserServiceHandlerMockUpsertUserParams{ctx, pp1}
	for _, e := range mmUpsertUser.expectations {
		if minimock.Equal(e.params, mmUpsertUser.defaultExpectation.params) {
			mmUpsertUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertUser.defaultExpectation.params)
		}
	}

	return mmUpsertUser
}

// Inspect accepts an inspector function that has same arguments as the AuthUserServiceHandler.UpsertUser
func (mmUpsertUser *mAuthUserServiceHandlerMockUpsertUser) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest])) *mAuthUserServiceHandlerMockUpsertUser {
	if mmUpsertUser.mock.inspectFuncUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("Inspect function is already set for AuthUserServiceHandlerMock.UpsertUser")
	}

	mmUpsertUser.mock.inspectFuncUpsertUser = f

	return mmUpsertUser
}

// Return sets up results that will be returned by AuthUserServiceHandler.UpsertUser
func (mmUpsertUser *mAuthUserServiceHandlerMockUpsertUser) Return(pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse], err error) *AuthUserServiceHandlerMock {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("AuthUserServiceHandlerMock.UpsertUser mock is already set by Set")
	}

	if mmUpsertUser.defaultExpectation == nil {
		mmUpsertUser.defaultExpectation = &AuthUserServiceHandlerMockUpsertUserExpectation{mock: mmUpsertUser.mock}
	}
	mmUpsertUser.defaultExpectation.results = &AuthUserServiceHandlerMockUpsertUserResults{pp2, err}
	return mmUpsertUser.mock
}

// Set uses given function f to mock the AuthUserServiceHandler.UpsertUser method
func (mmUpsertUser *mAuthUserServiceHandlerMockUpsertUser) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse], err error)) *AuthUserServiceHandlerMock {
	if mmUpsertUser.defaultExpectation != nil {
		mmUpsertUser.mock.t.Fatalf("Default expectation is already set for the AuthUserServiceHandler.UpsertUser method")
	}

	if len(mmUpsertUser.expectations) > 0 {
		mmUpsertUser.mock.t.Fatalf("Some expectations are already set for the AuthUserServiceHandler.UpsertUser method")
	}

	mmUpsertUser.mock.funcUpsertUser = f
	return mmUpsertUser.mock
}

// When sets expectation for the AuthUserServiceHandler.UpsertUser which will trigger the result defined by the following
// Then helper
func (mmUpsertUser *mAuthUserServiceHandlerMockUpsertUser) When(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]) *AuthUserServiceHandlerMockUpsertUserExpectation {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("AuthUserServiceHandlerMock.UpsertUser mock is already set by Set")
	}

	expectation := &AuthUserServiceHandlerMockUpsertUserExpectation{
		mock:   mmUpsertUser.mock,
		params: &AuthUserServiceHandlerMockUpsertUserParams{ctx, pp1},
	}
	mmUpsertUser.expectations = append(mmUpsertUser.expectations, expectation)
	return expectation
}

// Then sets up AuthUserServiceHandler.UpsertUser return parameters for the expectation previously defined by the When method
func (e *AuthUserServiceHandlerMockUpsertUserExpectation) Then(pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse], err error) *AuthUserServiceHandlerMock {
	e.results = &AuthUserServiceHandlerMockUpsertUserResults{pp2, err}
	return e.mock
}

// UpsertUser implements AuthUserServiceHandler
func (mmUpsertUser *AuthUserServiceHandlerMock) UpsertUser(ctx context.Context, pp1 *connect_go.Request[v1.AuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.AuthUserServiceUpsertUserResponse], err error) {
	mm_atomic.AddUint64(&mmUpsertUser.beforeUpsertUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertUser.afterUpsertUserCounter, 1)

	if mmUpsertUser.inspectFuncUpsertUser != nil {
		mmUpsertUser.inspectFuncUpsertUser(ctx, pp1)
	}

	mm_params := &AuthUserServiceHandlerMockUpsertUserParams{ctx, pp1}

	// Record call args
	mmUpsertUser.UpsertUserMock.mutex.Lock()
	mmUpsertUser.UpsertUserMock.callArgs = append(mmUpsertUser.UpsertUserMock.callArgs, mm_params)
	mmUpsertUser.UpsertUserMock.mutex.Unlock()

	for _, e := range mmUpsertUser.UpsertUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpsertUser.UpsertUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertUser.UpsertUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertUser.UpsertUserMock.defaultExpectation.params
		mm_got := AuthUserServiceHandlerMockUpsertUserParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertUser.t.Errorf("AuthUserServiceHandlerMock.UpsertUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertUser.UpsertUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertUser.t.Fatal("No results are set for the AuthUserServiceHandlerMock.UpsertUser")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpsertUser.funcUpsertUser != nil {
		return mmUpsertUser.funcUpsertUser(ctx, pp1)
	}
	mmUpsertUser.t.Fatalf("Unexpected call to AuthUserServiceHandlerMock.UpsertUser. %v %v", ctx, pp1)
	return
}

// UpsertUserAfterCounter returns a count of finished AuthUserServiceHandlerMock.UpsertUser invocations
func (mmUpsertUser *AuthUserServiceHandlerMock) UpsertUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertUser.afterUpsertUserCounter)
}

// UpsertUserBeforeCounter returns a count of AuthUserServiceHandlerMock.UpsertUser invocations
func (mmUpsertUser *AuthUserServiceHandlerMock) UpsertUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertUser.beforeUpsertUserCounter)
}

// Calls returns a list of arguments used in each call to AuthUserServiceHandlerMock.UpsertUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertUser *mAuthUserServiceHandlerMockUpsertUser) Calls() []*AuthUserServiceHandlerMockUpsertUserParams {
	mmUpsertUser.mutex.RLock()

	argCopy := make([]*AuthUserServiceHandlerMockUpsertUserParams, len(mmUpsertUser.callArgs))
	copy(argCopy, mmUpsertUser.callArgs)

	mmUpsertUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertUserDone returns true if the count of the UpsertUser invocations corresponds
// the number of defined expectations
func (m *AuthUserServiceHandlerMock) MinimockUpsertUserDone() bool {
	for _, e := range m.UpsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertUser != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertUserInspect logs each unmet expectation
func (m *AuthUserServiceHandlerMock) MinimockUpsertUserInspect() {
	for _, e := range m.UpsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthUserServiceHandlerMock.UpsertUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		if m.UpsertUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthUserServiceHandlerMock.UpsertUser")
		} else {
			m.t.Errorf("Expected call to AuthUserServiceHandlerMock.UpsertUser with params: %#v", *m.UpsertUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertUser != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		m.t.Error("Expected call to AuthUserServiceHandlerMock.UpsertUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthUserServiceHandlerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetAuthUrlInspect()

		m.MinimockListAssociationsInspect()

		m.MinimockRemoveAssociationInspect()

		m.MinimockUpsertUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthUserServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthUserServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAuthUrlDone() &&
		m.MinimockListAssociationsDone() &&
		m.MinimockRemoveAssociationDone() &&
		m.MinimockUpsertUserDone()
}
