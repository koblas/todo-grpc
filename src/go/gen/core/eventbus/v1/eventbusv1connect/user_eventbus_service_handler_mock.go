package eventbusv1connect

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/koblas/grpc-todo/gen/core/eventbus/v1/eventbusv1connect.UserEventbusServiceHandler -o ./user_eventbus_service_handler_mock.go -n UserEventbusServiceHandlerMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	connect_go "github.com/bufbuild/connect-go"
	"github.com/gojuno/minimock/v3"
	v11 "github.com/koblas/grpc-todo/gen/core/eventbus/v1"
	v1 "github.com/koblas/grpc-todo/gen/core/v1"
)

// UserEventbusServiceHandlerMock implements UserEventbusServiceHandler
type UserEventbusServiceHandlerMock struct {
	t minimock.Tester

	funcSecurityForgotRequest          func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse], err error)
	inspectFuncSecurityForgotRequest   func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])
	afterSecurityForgotRequestCounter  uint64
	beforeSecurityForgotRequestCounter uint64
	SecurityForgotRequestMock          mUserEventbusServiceHandlerMockSecurityForgotRequest

	funcSecurityInviteToken          func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse], err error)
	inspectFuncSecurityInviteToken   func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])
	afterSecurityInviteTokenCounter  uint64
	beforeSecurityInviteTokenCounter uint64
	SecurityInviteTokenMock          mUserEventbusServiceHandlerMockSecurityInviteToken

	funcSecurityPasswordChange          func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse], err error)
	inspectFuncSecurityPasswordChange   func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])
	afterSecurityPasswordChangeCounter  uint64
	beforeSecurityPasswordChangeCounter uint64
	SecurityPasswordChangeMock          mUserEventbusServiceHandlerMockSecurityPasswordChange

	funcSecurityRegisterToken          func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse], err error)
	inspectFuncSecurityRegisterToken   func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])
	afterSecurityRegisterTokenCounter  uint64
	beforeSecurityRegisterTokenCounter uint64
	SecurityRegisterTokenMock          mUserEventbusServiceHandlerMockSecurityRegisterToken

	funcUserChange          func(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent]) (pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse], err error)
	inspectFuncUserChange   func(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent])
	afterUserChangeCounter  uint64
	beforeUserChangeCounter uint64
	UserChangeMock          mUserEventbusServiceHandlerMockUserChange
}

// NewUserEventbusServiceHandlerMock returns a mock for UserEventbusServiceHandler
func NewUserEventbusServiceHandlerMock(t minimock.Tester) *UserEventbusServiceHandlerMock {
	m := &UserEventbusServiceHandlerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SecurityForgotRequestMock = mUserEventbusServiceHandlerMockSecurityForgotRequest{mock: m}
	m.SecurityForgotRequestMock.callArgs = []*UserEventbusServiceHandlerMockSecurityForgotRequestParams{}

	m.SecurityInviteTokenMock = mUserEventbusServiceHandlerMockSecurityInviteToken{mock: m}
	m.SecurityInviteTokenMock.callArgs = []*UserEventbusServiceHandlerMockSecurityInviteTokenParams{}

	m.SecurityPasswordChangeMock = mUserEventbusServiceHandlerMockSecurityPasswordChange{mock: m}
	m.SecurityPasswordChangeMock.callArgs = []*UserEventbusServiceHandlerMockSecurityPasswordChangeParams{}

	m.SecurityRegisterTokenMock = mUserEventbusServiceHandlerMockSecurityRegisterToken{mock: m}
	m.SecurityRegisterTokenMock.callArgs = []*UserEventbusServiceHandlerMockSecurityRegisterTokenParams{}

	m.UserChangeMock = mUserEventbusServiceHandlerMockUserChange{mock: m}
	m.UserChangeMock.callArgs = []*UserEventbusServiceHandlerMockUserChangeParams{}

	return m
}

type mUserEventbusServiceHandlerMockSecurityForgotRequest struct {
	mock               *UserEventbusServiceHandlerMock
	defaultExpectation *UserEventbusServiceHandlerMockSecurityForgotRequestExpectation
	expectations       []*UserEventbusServiceHandlerMockSecurityForgotRequestExpectation

	callArgs []*UserEventbusServiceHandlerMockSecurityForgotRequestParams
	mutex    sync.RWMutex
}

// UserEventbusServiceHandlerMockSecurityForgotRequestExpectation specifies expectation struct of the UserEventbusServiceHandler.SecurityForgotRequest
type UserEventbusServiceHandlerMockSecurityForgotRequestExpectation struct {
	mock    *UserEventbusServiceHandlerMock
	params  *UserEventbusServiceHandlerMockSecurityForgotRequestParams
	results *UserEventbusServiceHandlerMockSecurityForgotRequestResults
	Counter uint64
}

// UserEventbusServiceHandlerMockSecurityForgotRequestParams contains parameters of the UserEventbusServiceHandler.SecurityForgotRequest
type UserEventbusServiceHandlerMockSecurityForgotRequestParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.UserSecurityEvent]
}

// UserEventbusServiceHandlerMockSecurityForgotRequestResults contains results of the UserEventbusServiceHandler.SecurityForgotRequest
type UserEventbusServiceHandlerMockSecurityForgotRequestResults struct {
	pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse]
	err error
}

// Expect sets up expected params for UserEventbusServiceHandler.SecurityForgotRequest
func (mmSecurityForgotRequest *mUserEventbusServiceHandlerMockSecurityForgotRequest) Expect(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *mUserEventbusServiceHandlerMockSecurityForgotRequest {
	if mmSecurityForgotRequest.mock.funcSecurityForgotRequest != nil {
		mmSecurityForgotRequest.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityForgotRequest mock is already set by Set")
	}

	if mmSecurityForgotRequest.defaultExpectation == nil {
		mmSecurityForgotRequest.defaultExpectation = &UserEventbusServiceHandlerMockSecurityForgotRequestExpectation{}
	}

	mmSecurityForgotRequest.defaultExpectation.params = &UserEventbusServiceHandlerMockSecurityForgotRequestParams{ctx, pp1}
	for _, e := range mmSecurityForgotRequest.expectations {
		if minimock.Equal(e.params, mmSecurityForgotRequest.defaultExpectation.params) {
			mmSecurityForgotRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSecurityForgotRequest.defaultExpectation.params)
		}
	}

	return mmSecurityForgotRequest
}

// Inspect accepts an inspector function that has same arguments as the UserEventbusServiceHandler.SecurityForgotRequest
func (mmSecurityForgotRequest *mUserEventbusServiceHandlerMockSecurityForgotRequest) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])) *mUserEventbusServiceHandlerMockSecurityForgotRequest {
	if mmSecurityForgotRequest.mock.inspectFuncSecurityForgotRequest != nil {
		mmSecurityForgotRequest.mock.t.Fatalf("Inspect function is already set for UserEventbusServiceHandlerMock.SecurityForgotRequest")
	}

	mmSecurityForgotRequest.mock.inspectFuncSecurityForgotRequest = f

	return mmSecurityForgotRequest
}

// Return sets up results that will be returned by UserEventbusServiceHandler.SecurityForgotRequest
func (mmSecurityForgotRequest *mUserEventbusServiceHandlerMockSecurityForgotRequest) Return(pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse], err error) *UserEventbusServiceHandlerMock {
	if mmSecurityForgotRequest.mock.funcSecurityForgotRequest != nil {
		mmSecurityForgotRequest.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityForgotRequest mock is already set by Set")
	}

	if mmSecurityForgotRequest.defaultExpectation == nil {
		mmSecurityForgotRequest.defaultExpectation = &UserEventbusServiceHandlerMockSecurityForgotRequestExpectation{mock: mmSecurityForgotRequest.mock}
	}
	mmSecurityForgotRequest.defaultExpectation.results = &UserEventbusServiceHandlerMockSecurityForgotRequestResults{pp2, err}
	return mmSecurityForgotRequest.mock
}

// Set uses given function f to mock the UserEventbusServiceHandler.SecurityForgotRequest method
func (mmSecurityForgotRequest *mUserEventbusServiceHandlerMockSecurityForgotRequest) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse], err error)) *UserEventbusServiceHandlerMock {
	if mmSecurityForgotRequest.defaultExpectation != nil {
		mmSecurityForgotRequest.mock.t.Fatalf("Default expectation is already set for the UserEventbusServiceHandler.SecurityForgotRequest method")
	}

	if len(mmSecurityForgotRequest.expectations) > 0 {
		mmSecurityForgotRequest.mock.t.Fatalf("Some expectations are already set for the UserEventbusServiceHandler.SecurityForgotRequest method")
	}

	mmSecurityForgotRequest.mock.funcSecurityForgotRequest = f
	return mmSecurityForgotRequest.mock
}

// When sets expectation for the UserEventbusServiceHandler.SecurityForgotRequest which will trigger the result defined by the following
// Then helper
func (mmSecurityForgotRequest *mUserEventbusServiceHandlerMockSecurityForgotRequest) When(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *UserEventbusServiceHandlerMockSecurityForgotRequestExpectation {
	if mmSecurityForgotRequest.mock.funcSecurityForgotRequest != nil {
		mmSecurityForgotRequest.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityForgotRequest mock is already set by Set")
	}

	expectation := &UserEventbusServiceHandlerMockSecurityForgotRequestExpectation{
		mock:   mmSecurityForgotRequest.mock,
		params: &UserEventbusServiceHandlerMockSecurityForgotRequestParams{ctx, pp1},
	}
	mmSecurityForgotRequest.expectations = append(mmSecurityForgotRequest.expectations, expectation)
	return expectation
}

// Then sets up UserEventbusServiceHandler.SecurityForgotRequest return parameters for the expectation previously defined by the When method
func (e *UserEventbusServiceHandlerMockSecurityForgotRequestExpectation) Then(pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse], err error) *UserEventbusServiceHandlerMock {
	e.results = &UserEventbusServiceHandlerMockSecurityForgotRequestResults{pp2, err}
	return e.mock
}

// SecurityForgotRequest implements UserEventbusServiceHandler
func (mmSecurityForgotRequest *UserEventbusServiceHandlerMock) SecurityForgotRequest(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse], err error) {
	mm_atomic.AddUint64(&mmSecurityForgotRequest.beforeSecurityForgotRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmSecurityForgotRequest.afterSecurityForgotRequestCounter, 1)

	if mmSecurityForgotRequest.inspectFuncSecurityForgotRequest != nil {
		mmSecurityForgotRequest.inspectFuncSecurityForgotRequest(ctx, pp1)
	}

	mm_params := &UserEventbusServiceHandlerMockSecurityForgotRequestParams{ctx, pp1}

	// Record call args
	mmSecurityForgotRequest.SecurityForgotRequestMock.mutex.Lock()
	mmSecurityForgotRequest.SecurityForgotRequestMock.callArgs = append(mmSecurityForgotRequest.SecurityForgotRequestMock.callArgs, mm_params)
	mmSecurityForgotRequest.SecurityForgotRequestMock.mutex.Unlock()

	for _, e := range mmSecurityForgotRequest.SecurityForgotRequestMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSecurityForgotRequest.SecurityForgotRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSecurityForgotRequest.SecurityForgotRequestMock.defaultExpectation.Counter, 1)
		mm_want := mmSecurityForgotRequest.SecurityForgotRequestMock.defaultExpectation.params
		mm_got := UserEventbusServiceHandlerMockSecurityForgotRequestParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSecurityForgotRequest.t.Errorf("UserEventbusServiceHandlerMock.SecurityForgotRequest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSecurityForgotRequest.SecurityForgotRequestMock.defaultExpectation.results
		if mm_results == nil {
			mmSecurityForgotRequest.t.Fatal("No results are set for the UserEventbusServiceHandlerMock.SecurityForgotRequest")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSecurityForgotRequest.funcSecurityForgotRequest != nil {
		return mmSecurityForgotRequest.funcSecurityForgotRequest(ctx, pp1)
	}
	mmSecurityForgotRequest.t.Fatalf("Unexpected call to UserEventbusServiceHandlerMock.SecurityForgotRequest. %v %v", ctx, pp1)
	return
}

// SecurityForgotRequestAfterCounter returns a count of finished UserEventbusServiceHandlerMock.SecurityForgotRequest invocations
func (mmSecurityForgotRequest *UserEventbusServiceHandlerMock) SecurityForgotRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityForgotRequest.afterSecurityForgotRequestCounter)
}

// SecurityForgotRequestBeforeCounter returns a count of UserEventbusServiceHandlerMock.SecurityForgotRequest invocations
func (mmSecurityForgotRequest *UserEventbusServiceHandlerMock) SecurityForgotRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityForgotRequest.beforeSecurityForgotRequestCounter)
}

// Calls returns a list of arguments used in each call to UserEventbusServiceHandlerMock.SecurityForgotRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSecurityForgotRequest *mUserEventbusServiceHandlerMockSecurityForgotRequest) Calls() []*UserEventbusServiceHandlerMockSecurityForgotRequestParams {
	mmSecurityForgotRequest.mutex.RLock()

	argCopy := make([]*UserEventbusServiceHandlerMockSecurityForgotRequestParams, len(mmSecurityForgotRequest.callArgs))
	copy(argCopy, mmSecurityForgotRequest.callArgs)

	mmSecurityForgotRequest.mutex.RUnlock()

	return argCopy
}

// MinimockSecurityForgotRequestDone returns true if the count of the SecurityForgotRequest invocations corresponds
// the number of defined expectations
func (m *UserEventbusServiceHandlerMock) MinimockSecurityForgotRequestDone() bool {
	for _, e := range m.SecurityForgotRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityForgotRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityForgotRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityForgotRequest != nil && mm_atomic.LoadUint64(&m.afterSecurityForgotRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockSecurityForgotRequestInspect logs each unmet expectation
func (m *UserEventbusServiceHandlerMock) MinimockSecurityForgotRequestInspect() {
	for _, e := range m.SecurityForgotRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserEventbusServiceHandlerMock.SecurityForgotRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityForgotRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityForgotRequestCounter) < 1 {
		if m.SecurityForgotRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserEventbusServiceHandlerMock.SecurityForgotRequest")
		} else {
			m.t.Errorf("Expected call to UserEventbusServiceHandlerMock.SecurityForgotRequest with params: %#v", *m.SecurityForgotRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityForgotRequest != nil && mm_atomic.LoadUint64(&m.afterSecurityForgotRequestCounter) < 1 {
		m.t.Error("Expected call to UserEventbusServiceHandlerMock.SecurityForgotRequest")
	}
}

type mUserEventbusServiceHandlerMockSecurityInviteToken struct {
	mock               *UserEventbusServiceHandlerMock
	defaultExpectation *UserEventbusServiceHandlerMockSecurityInviteTokenExpectation
	expectations       []*UserEventbusServiceHandlerMockSecurityInviteTokenExpectation

	callArgs []*UserEventbusServiceHandlerMockSecurityInviteTokenParams
	mutex    sync.RWMutex
}

// UserEventbusServiceHandlerMockSecurityInviteTokenExpectation specifies expectation struct of the UserEventbusServiceHandler.SecurityInviteToken
type UserEventbusServiceHandlerMockSecurityInviteTokenExpectation struct {
	mock    *UserEventbusServiceHandlerMock
	params  *UserEventbusServiceHandlerMockSecurityInviteTokenParams
	results *UserEventbusServiceHandlerMockSecurityInviteTokenResults
	Counter uint64
}

// UserEventbusServiceHandlerMockSecurityInviteTokenParams contains parameters of the UserEventbusServiceHandler.SecurityInviteToken
type UserEventbusServiceHandlerMockSecurityInviteTokenParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.UserSecurityEvent]
}

// UserEventbusServiceHandlerMockSecurityInviteTokenResults contains results of the UserEventbusServiceHandler.SecurityInviteToken
type UserEventbusServiceHandlerMockSecurityInviteTokenResults struct {
	pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse]
	err error
}

// Expect sets up expected params for UserEventbusServiceHandler.SecurityInviteToken
func (mmSecurityInviteToken *mUserEventbusServiceHandlerMockSecurityInviteToken) Expect(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *mUserEventbusServiceHandlerMockSecurityInviteToken {
	if mmSecurityInviteToken.mock.funcSecurityInviteToken != nil {
		mmSecurityInviteToken.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityInviteToken mock is already set by Set")
	}

	if mmSecurityInviteToken.defaultExpectation == nil {
		mmSecurityInviteToken.defaultExpectation = &UserEventbusServiceHandlerMockSecurityInviteTokenExpectation{}
	}

	mmSecurityInviteToken.defaultExpectation.params = &UserEventbusServiceHandlerMockSecurityInviteTokenParams{ctx, pp1}
	for _, e := range mmSecurityInviteToken.expectations {
		if minimock.Equal(e.params, mmSecurityInviteToken.defaultExpectation.params) {
			mmSecurityInviteToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSecurityInviteToken.defaultExpectation.params)
		}
	}

	return mmSecurityInviteToken
}

// Inspect accepts an inspector function that has same arguments as the UserEventbusServiceHandler.SecurityInviteToken
func (mmSecurityInviteToken *mUserEventbusServiceHandlerMockSecurityInviteToken) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])) *mUserEventbusServiceHandlerMockSecurityInviteToken {
	if mmSecurityInviteToken.mock.inspectFuncSecurityInviteToken != nil {
		mmSecurityInviteToken.mock.t.Fatalf("Inspect function is already set for UserEventbusServiceHandlerMock.SecurityInviteToken")
	}

	mmSecurityInviteToken.mock.inspectFuncSecurityInviteToken = f

	return mmSecurityInviteToken
}

// Return sets up results that will be returned by UserEventbusServiceHandler.SecurityInviteToken
func (mmSecurityInviteToken *mUserEventbusServiceHandlerMockSecurityInviteToken) Return(pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse], err error) *UserEventbusServiceHandlerMock {
	if mmSecurityInviteToken.mock.funcSecurityInviteToken != nil {
		mmSecurityInviteToken.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityInviteToken mock is already set by Set")
	}

	if mmSecurityInviteToken.defaultExpectation == nil {
		mmSecurityInviteToken.defaultExpectation = &UserEventbusServiceHandlerMockSecurityInviteTokenExpectation{mock: mmSecurityInviteToken.mock}
	}
	mmSecurityInviteToken.defaultExpectation.results = &UserEventbusServiceHandlerMockSecurityInviteTokenResults{pp2, err}
	return mmSecurityInviteToken.mock
}

// Set uses given function f to mock the UserEventbusServiceHandler.SecurityInviteToken method
func (mmSecurityInviteToken *mUserEventbusServiceHandlerMockSecurityInviteToken) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse], err error)) *UserEventbusServiceHandlerMock {
	if mmSecurityInviteToken.defaultExpectation != nil {
		mmSecurityInviteToken.mock.t.Fatalf("Default expectation is already set for the UserEventbusServiceHandler.SecurityInviteToken method")
	}

	if len(mmSecurityInviteToken.expectations) > 0 {
		mmSecurityInviteToken.mock.t.Fatalf("Some expectations are already set for the UserEventbusServiceHandler.SecurityInviteToken method")
	}

	mmSecurityInviteToken.mock.funcSecurityInviteToken = f
	return mmSecurityInviteToken.mock
}

// When sets expectation for the UserEventbusServiceHandler.SecurityInviteToken which will trigger the result defined by the following
// Then helper
func (mmSecurityInviteToken *mUserEventbusServiceHandlerMockSecurityInviteToken) When(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *UserEventbusServiceHandlerMockSecurityInviteTokenExpectation {
	if mmSecurityInviteToken.mock.funcSecurityInviteToken != nil {
		mmSecurityInviteToken.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityInviteToken mock is already set by Set")
	}

	expectation := &UserEventbusServiceHandlerMockSecurityInviteTokenExpectation{
		mock:   mmSecurityInviteToken.mock,
		params: &UserEventbusServiceHandlerMockSecurityInviteTokenParams{ctx, pp1},
	}
	mmSecurityInviteToken.expectations = append(mmSecurityInviteToken.expectations, expectation)
	return expectation
}

// Then sets up UserEventbusServiceHandler.SecurityInviteToken return parameters for the expectation previously defined by the When method
func (e *UserEventbusServiceHandlerMockSecurityInviteTokenExpectation) Then(pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse], err error) *UserEventbusServiceHandlerMock {
	e.results = &UserEventbusServiceHandlerMockSecurityInviteTokenResults{pp2, err}
	return e.mock
}

// SecurityInviteToken implements UserEventbusServiceHandler
func (mmSecurityInviteToken *UserEventbusServiceHandlerMock) SecurityInviteToken(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse], err error) {
	mm_atomic.AddUint64(&mmSecurityInviteToken.beforeSecurityInviteTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmSecurityInviteToken.afterSecurityInviteTokenCounter, 1)

	if mmSecurityInviteToken.inspectFuncSecurityInviteToken != nil {
		mmSecurityInviteToken.inspectFuncSecurityInviteToken(ctx, pp1)
	}

	mm_params := &UserEventbusServiceHandlerMockSecurityInviteTokenParams{ctx, pp1}

	// Record call args
	mmSecurityInviteToken.SecurityInviteTokenMock.mutex.Lock()
	mmSecurityInviteToken.SecurityInviteTokenMock.callArgs = append(mmSecurityInviteToken.SecurityInviteTokenMock.callArgs, mm_params)
	mmSecurityInviteToken.SecurityInviteTokenMock.mutex.Unlock()

	for _, e := range mmSecurityInviteToken.SecurityInviteTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSecurityInviteToken.SecurityInviteTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSecurityInviteToken.SecurityInviteTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmSecurityInviteToken.SecurityInviteTokenMock.defaultExpectation.params
		mm_got := UserEventbusServiceHandlerMockSecurityInviteTokenParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSecurityInviteToken.t.Errorf("UserEventbusServiceHandlerMock.SecurityInviteToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSecurityInviteToken.SecurityInviteTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmSecurityInviteToken.t.Fatal("No results are set for the UserEventbusServiceHandlerMock.SecurityInviteToken")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSecurityInviteToken.funcSecurityInviteToken != nil {
		return mmSecurityInviteToken.funcSecurityInviteToken(ctx, pp1)
	}
	mmSecurityInviteToken.t.Fatalf("Unexpected call to UserEventbusServiceHandlerMock.SecurityInviteToken. %v %v", ctx, pp1)
	return
}

// SecurityInviteTokenAfterCounter returns a count of finished UserEventbusServiceHandlerMock.SecurityInviteToken invocations
func (mmSecurityInviteToken *UserEventbusServiceHandlerMock) SecurityInviteTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityInviteToken.afterSecurityInviteTokenCounter)
}

// SecurityInviteTokenBeforeCounter returns a count of UserEventbusServiceHandlerMock.SecurityInviteToken invocations
func (mmSecurityInviteToken *UserEventbusServiceHandlerMock) SecurityInviteTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityInviteToken.beforeSecurityInviteTokenCounter)
}

// Calls returns a list of arguments used in each call to UserEventbusServiceHandlerMock.SecurityInviteToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSecurityInviteToken *mUserEventbusServiceHandlerMockSecurityInviteToken) Calls() []*UserEventbusServiceHandlerMockSecurityInviteTokenParams {
	mmSecurityInviteToken.mutex.RLock()

	argCopy := make([]*UserEventbusServiceHandlerMockSecurityInviteTokenParams, len(mmSecurityInviteToken.callArgs))
	copy(argCopy, mmSecurityInviteToken.callArgs)

	mmSecurityInviteToken.mutex.RUnlock()

	return argCopy
}

// MinimockSecurityInviteTokenDone returns true if the count of the SecurityInviteToken invocations corresponds
// the number of defined expectations
func (m *UserEventbusServiceHandlerMock) MinimockSecurityInviteTokenDone() bool {
	for _, e := range m.SecurityInviteTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityInviteTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityInviteTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityInviteToken != nil && mm_atomic.LoadUint64(&m.afterSecurityInviteTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockSecurityInviteTokenInspect logs each unmet expectation
func (m *UserEventbusServiceHandlerMock) MinimockSecurityInviteTokenInspect() {
	for _, e := range m.SecurityInviteTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserEventbusServiceHandlerMock.SecurityInviteToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityInviteTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityInviteTokenCounter) < 1 {
		if m.SecurityInviteTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserEventbusServiceHandlerMock.SecurityInviteToken")
		} else {
			m.t.Errorf("Expected call to UserEventbusServiceHandlerMock.SecurityInviteToken with params: %#v", *m.SecurityInviteTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityInviteToken != nil && mm_atomic.LoadUint64(&m.afterSecurityInviteTokenCounter) < 1 {
		m.t.Error("Expected call to UserEventbusServiceHandlerMock.SecurityInviteToken")
	}
}

type mUserEventbusServiceHandlerMockSecurityPasswordChange struct {
	mock               *UserEventbusServiceHandlerMock
	defaultExpectation *UserEventbusServiceHandlerMockSecurityPasswordChangeExpectation
	expectations       []*UserEventbusServiceHandlerMockSecurityPasswordChangeExpectation

	callArgs []*UserEventbusServiceHandlerMockSecurityPasswordChangeParams
	mutex    sync.RWMutex
}

// UserEventbusServiceHandlerMockSecurityPasswordChangeExpectation specifies expectation struct of the UserEventbusServiceHandler.SecurityPasswordChange
type UserEventbusServiceHandlerMockSecurityPasswordChangeExpectation struct {
	mock    *UserEventbusServiceHandlerMock
	params  *UserEventbusServiceHandlerMockSecurityPasswordChangeParams
	results *UserEventbusServiceHandlerMockSecurityPasswordChangeResults
	Counter uint64
}

// UserEventbusServiceHandlerMockSecurityPasswordChangeParams contains parameters of the UserEventbusServiceHandler.SecurityPasswordChange
type UserEventbusServiceHandlerMockSecurityPasswordChangeParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.UserSecurityEvent]
}

// UserEventbusServiceHandlerMockSecurityPasswordChangeResults contains results of the UserEventbusServiceHandler.SecurityPasswordChange
type UserEventbusServiceHandlerMockSecurityPasswordChangeResults struct {
	pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse]
	err error
}

// Expect sets up expected params for UserEventbusServiceHandler.SecurityPasswordChange
func (mmSecurityPasswordChange *mUserEventbusServiceHandlerMockSecurityPasswordChange) Expect(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *mUserEventbusServiceHandlerMockSecurityPasswordChange {
	if mmSecurityPasswordChange.mock.funcSecurityPasswordChange != nil {
		mmSecurityPasswordChange.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityPasswordChange mock is already set by Set")
	}

	if mmSecurityPasswordChange.defaultExpectation == nil {
		mmSecurityPasswordChange.defaultExpectation = &UserEventbusServiceHandlerMockSecurityPasswordChangeExpectation{}
	}

	mmSecurityPasswordChange.defaultExpectation.params = &UserEventbusServiceHandlerMockSecurityPasswordChangeParams{ctx, pp1}
	for _, e := range mmSecurityPasswordChange.expectations {
		if minimock.Equal(e.params, mmSecurityPasswordChange.defaultExpectation.params) {
			mmSecurityPasswordChange.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSecurityPasswordChange.defaultExpectation.params)
		}
	}

	return mmSecurityPasswordChange
}

// Inspect accepts an inspector function that has same arguments as the UserEventbusServiceHandler.SecurityPasswordChange
func (mmSecurityPasswordChange *mUserEventbusServiceHandlerMockSecurityPasswordChange) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])) *mUserEventbusServiceHandlerMockSecurityPasswordChange {
	if mmSecurityPasswordChange.mock.inspectFuncSecurityPasswordChange != nil {
		mmSecurityPasswordChange.mock.t.Fatalf("Inspect function is already set for UserEventbusServiceHandlerMock.SecurityPasswordChange")
	}

	mmSecurityPasswordChange.mock.inspectFuncSecurityPasswordChange = f

	return mmSecurityPasswordChange
}

// Return sets up results that will be returned by UserEventbusServiceHandler.SecurityPasswordChange
func (mmSecurityPasswordChange *mUserEventbusServiceHandlerMockSecurityPasswordChange) Return(pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse], err error) *UserEventbusServiceHandlerMock {
	if mmSecurityPasswordChange.mock.funcSecurityPasswordChange != nil {
		mmSecurityPasswordChange.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityPasswordChange mock is already set by Set")
	}

	if mmSecurityPasswordChange.defaultExpectation == nil {
		mmSecurityPasswordChange.defaultExpectation = &UserEventbusServiceHandlerMockSecurityPasswordChangeExpectation{mock: mmSecurityPasswordChange.mock}
	}
	mmSecurityPasswordChange.defaultExpectation.results = &UserEventbusServiceHandlerMockSecurityPasswordChangeResults{pp2, err}
	return mmSecurityPasswordChange.mock
}

// Set uses given function f to mock the UserEventbusServiceHandler.SecurityPasswordChange method
func (mmSecurityPasswordChange *mUserEventbusServiceHandlerMockSecurityPasswordChange) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse], err error)) *UserEventbusServiceHandlerMock {
	if mmSecurityPasswordChange.defaultExpectation != nil {
		mmSecurityPasswordChange.mock.t.Fatalf("Default expectation is already set for the UserEventbusServiceHandler.SecurityPasswordChange method")
	}

	if len(mmSecurityPasswordChange.expectations) > 0 {
		mmSecurityPasswordChange.mock.t.Fatalf("Some expectations are already set for the UserEventbusServiceHandler.SecurityPasswordChange method")
	}

	mmSecurityPasswordChange.mock.funcSecurityPasswordChange = f
	return mmSecurityPasswordChange.mock
}

// When sets expectation for the UserEventbusServiceHandler.SecurityPasswordChange which will trigger the result defined by the following
// Then helper
func (mmSecurityPasswordChange *mUserEventbusServiceHandlerMockSecurityPasswordChange) When(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *UserEventbusServiceHandlerMockSecurityPasswordChangeExpectation {
	if mmSecurityPasswordChange.mock.funcSecurityPasswordChange != nil {
		mmSecurityPasswordChange.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityPasswordChange mock is already set by Set")
	}

	expectation := &UserEventbusServiceHandlerMockSecurityPasswordChangeExpectation{
		mock:   mmSecurityPasswordChange.mock,
		params: &UserEventbusServiceHandlerMockSecurityPasswordChangeParams{ctx, pp1},
	}
	mmSecurityPasswordChange.expectations = append(mmSecurityPasswordChange.expectations, expectation)
	return expectation
}

// Then sets up UserEventbusServiceHandler.SecurityPasswordChange return parameters for the expectation previously defined by the When method
func (e *UserEventbusServiceHandlerMockSecurityPasswordChangeExpectation) Then(pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse], err error) *UserEventbusServiceHandlerMock {
	e.results = &UserEventbusServiceHandlerMockSecurityPasswordChangeResults{pp2, err}
	return e.mock
}

// SecurityPasswordChange implements UserEventbusServiceHandler
func (mmSecurityPasswordChange *UserEventbusServiceHandlerMock) SecurityPasswordChange(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse], err error) {
	mm_atomic.AddUint64(&mmSecurityPasswordChange.beforeSecurityPasswordChangeCounter, 1)
	defer mm_atomic.AddUint64(&mmSecurityPasswordChange.afterSecurityPasswordChangeCounter, 1)

	if mmSecurityPasswordChange.inspectFuncSecurityPasswordChange != nil {
		mmSecurityPasswordChange.inspectFuncSecurityPasswordChange(ctx, pp1)
	}

	mm_params := &UserEventbusServiceHandlerMockSecurityPasswordChangeParams{ctx, pp1}

	// Record call args
	mmSecurityPasswordChange.SecurityPasswordChangeMock.mutex.Lock()
	mmSecurityPasswordChange.SecurityPasswordChangeMock.callArgs = append(mmSecurityPasswordChange.SecurityPasswordChangeMock.callArgs, mm_params)
	mmSecurityPasswordChange.SecurityPasswordChangeMock.mutex.Unlock()

	for _, e := range mmSecurityPasswordChange.SecurityPasswordChangeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSecurityPasswordChange.SecurityPasswordChangeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSecurityPasswordChange.SecurityPasswordChangeMock.defaultExpectation.Counter, 1)
		mm_want := mmSecurityPasswordChange.SecurityPasswordChangeMock.defaultExpectation.params
		mm_got := UserEventbusServiceHandlerMockSecurityPasswordChangeParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSecurityPasswordChange.t.Errorf("UserEventbusServiceHandlerMock.SecurityPasswordChange got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSecurityPasswordChange.SecurityPasswordChangeMock.defaultExpectation.results
		if mm_results == nil {
			mmSecurityPasswordChange.t.Fatal("No results are set for the UserEventbusServiceHandlerMock.SecurityPasswordChange")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSecurityPasswordChange.funcSecurityPasswordChange != nil {
		return mmSecurityPasswordChange.funcSecurityPasswordChange(ctx, pp1)
	}
	mmSecurityPasswordChange.t.Fatalf("Unexpected call to UserEventbusServiceHandlerMock.SecurityPasswordChange. %v %v", ctx, pp1)
	return
}

// SecurityPasswordChangeAfterCounter returns a count of finished UserEventbusServiceHandlerMock.SecurityPasswordChange invocations
func (mmSecurityPasswordChange *UserEventbusServiceHandlerMock) SecurityPasswordChangeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityPasswordChange.afterSecurityPasswordChangeCounter)
}

// SecurityPasswordChangeBeforeCounter returns a count of UserEventbusServiceHandlerMock.SecurityPasswordChange invocations
func (mmSecurityPasswordChange *UserEventbusServiceHandlerMock) SecurityPasswordChangeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityPasswordChange.beforeSecurityPasswordChangeCounter)
}

// Calls returns a list of arguments used in each call to UserEventbusServiceHandlerMock.SecurityPasswordChange.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSecurityPasswordChange *mUserEventbusServiceHandlerMockSecurityPasswordChange) Calls() []*UserEventbusServiceHandlerMockSecurityPasswordChangeParams {
	mmSecurityPasswordChange.mutex.RLock()

	argCopy := make([]*UserEventbusServiceHandlerMockSecurityPasswordChangeParams, len(mmSecurityPasswordChange.callArgs))
	copy(argCopy, mmSecurityPasswordChange.callArgs)

	mmSecurityPasswordChange.mutex.RUnlock()

	return argCopy
}

// MinimockSecurityPasswordChangeDone returns true if the count of the SecurityPasswordChange invocations corresponds
// the number of defined expectations
func (m *UserEventbusServiceHandlerMock) MinimockSecurityPasswordChangeDone() bool {
	for _, e := range m.SecurityPasswordChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityPasswordChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityPasswordChangeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityPasswordChange != nil && mm_atomic.LoadUint64(&m.afterSecurityPasswordChangeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSecurityPasswordChangeInspect logs each unmet expectation
func (m *UserEventbusServiceHandlerMock) MinimockSecurityPasswordChangeInspect() {
	for _, e := range m.SecurityPasswordChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserEventbusServiceHandlerMock.SecurityPasswordChange with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityPasswordChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityPasswordChangeCounter) < 1 {
		if m.SecurityPasswordChangeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserEventbusServiceHandlerMock.SecurityPasswordChange")
		} else {
			m.t.Errorf("Expected call to UserEventbusServiceHandlerMock.SecurityPasswordChange with params: %#v", *m.SecurityPasswordChangeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityPasswordChange != nil && mm_atomic.LoadUint64(&m.afterSecurityPasswordChangeCounter) < 1 {
		m.t.Error("Expected call to UserEventbusServiceHandlerMock.SecurityPasswordChange")
	}
}

type mUserEventbusServiceHandlerMockSecurityRegisterToken struct {
	mock               *UserEventbusServiceHandlerMock
	defaultExpectation *UserEventbusServiceHandlerMockSecurityRegisterTokenExpectation
	expectations       []*UserEventbusServiceHandlerMockSecurityRegisterTokenExpectation

	callArgs []*UserEventbusServiceHandlerMockSecurityRegisterTokenParams
	mutex    sync.RWMutex
}

// UserEventbusServiceHandlerMockSecurityRegisterTokenExpectation specifies expectation struct of the UserEventbusServiceHandler.SecurityRegisterToken
type UserEventbusServiceHandlerMockSecurityRegisterTokenExpectation struct {
	mock    *UserEventbusServiceHandlerMock
	params  *UserEventbusServiceHandlerMockSecurityRegisterTokenParams
	results *UserEventbusServiceHandlerMockSecurityRegisterTokenResults
	Counter uint64
}

// UserEventbusServiceHandlerMockSecurityRegisterTokenParams contains parameters of the UserEventbusServiceHandler.SecurityRegisterToken
type UserEventbusServiceHandlerMockSecurityRegisterTokenParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.UserSecurityEvent]
}

// UserEventbusServiceHandlerMockSecurityRegisterTokenResults contains results of the UserEventbusServiceHandler.SecurityRegisterToken
type UserEventbusServiceHandlerMockSecurityRegisterTokenResults struct {
	pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse]
	err error
}

// Expect sets up expected params for UserEventbusServiceHandler.SecurityRegisterToken
func (mmSecurityRegisterToken *mUserEventbusServiceHandlerMockSecurityRegisterToken) Expect(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *mUserEventbusServiceHandlerMockSecurityRegisterToken {
	if mmSecurityRegisterToken.mock.funcSecurityRegisterToken != nil {
		mmSecurityRegisterToken.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityRegisterToken mock is already set by Set")
	}

	if mmSecurityRegisterToken.defaultExpectation == nil {
		mmSecurityRegisterToken.defaultExpectation = &UserEventbusServiceHandlerMockSecurityRegisterTokenExpectation{}
	}

	mmSecurityRegisterToken.defaultExpectation.params = &UserEventbusServiceHandlerMockSecurityRegisterTokenParams{ctx, pp1}
	for _, e := range mmSecurityRegisterToken.expectations {
		if minimock.Equal(e.params, mmSecurityRegisterToken.defaultExpectation.params) {
			mmSecurityRegisterToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSecurityRegisterToken.defaultExpectation.params)
		}
	}

	return mmSecurityRegisterToken
}

// Inspect accepts an inspector function that has same arguments as the UserEventbusServiceHandler.SecurityRegisterToken
func (mmSecurityRegisterToken *mUserEventbusServiceHandlerMockSecurityRegisterToken) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])) *mUserEventbusServiceHandlerMockSecurityRegisterToken {
	if mmSecurityRegisterToken.mock.inspectFuncSecurityRegisterToken != nil {
		mmSecurityRegisterToken.mock.t.Fatalf("Inspect function is already set for UserEventbusServiceHandlerMock.SecurityRegisterToken")
	}

	mmSecurityRegisterToken.mock.inspectFuncSecurityRegisterToken = f

	return mmSecurityRegisterToken
}

// Return sets up results that will be returned by UserEventbusServiceHandler.SecurityRegisterToken
func (mmSecurityRegisterToken *mUserEventbusServiceHandlerMockSecurityRegisterToken) Return(pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse], err error) *UserEventbusServiceHandlerMock {
	if mmSecurityRegisterToken.mock.funcSecurityRegisterToken != nil {
		mmSecurityRegisterToken.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityRegisterToken mock is already set by Set")
	}

	if mmSecurityRegisterToken.defaultExpectation == nil {
		mmSecurityRegisterToken.defaultExpectation = &UserEventbusServiceHandlerMockSecurityRegisterTokenExpectation{mock: mmSecurityRegisterToken.mock}
	}
	mmSecurityRegisterToken.defaultExpectation.results = &UserEventbusServiceHandlerMockSecurityRegisterTokenResults{pp2, err}
	return mmSecurityRegisterToken.mock
}

// Set uses given function f to mock the UserEventbusServiceHandler.SecurityRegisterToken method
func (mmSecurityRegisterToken *mUserEventbusServiceHandlerMockSecurityRegisterToken) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse], err error)) *UserEventbusServiceHandlerMock {
	if mmSecurityRegisterToken.defaultExpectation != nil {
		mmSecurityRegisterToken.mock.t.Fatalf("Default expectation is already set for the UserEventbusServiceHandler.SecurityRegisterToken method")
	}

	if len(mmSecurityRegisterToken.expectations) > 0 {
		mmSecurityRegisterToken.mock.t.Fatalf("Some expectations are already set for the UserEventbusServiceHandler.SecurityRegisterToken method")
	}

	mmSecurityRegisterToken.mock.funcSecurityRegisterToken = f
	return mmSecurityRegisterToken.mock
}

// When sets expectation for the UserEventbusServiceHandler.SecurityRegisterToken which will trigger the result defined by the following
// Then helper
func (mmSecurityRegisterToken *mUserEventbusServiceHandlerMockSecurityRegisterToken) When(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *UserEventbusServiceHandlerMockSecurityRegisterTokenExpectation {
	if mmSecurityRegisterToken.mock.funcSecurityRegisterToken != nil {
		mmSecurityRegisterToken.mock.t.Fatalf("UserEventbusServiceHandlerMock.SecurityRegisterToken mock is already set by Set")
	}

	expectation := &UserEventbusServiceHandlerMockSecurityRegisterTokenExpectation{
		mock:   mmSecurityRegisterToken.mock,
		params: &UserEventbusServiceHandlerMockSecurityRegisterTokenParams{ctx, pp1},
	}
	mmSecurityRegisterToken.expectations = append(mmSecurityRegisterToken.expectations, expectation)
	return expectation
}

// Then sets up UserEventbusServiceHandler.SecurityRegisterToken return parameters for the expectation previously defined by the When method
func (e *UserEventbusServiceHandlerMockSecurityRegisterTokenExpectation) Then(pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse], err error) *UserEventbusServiceHandlerMock {
	e.results = &UserEventbusServiceHandlerMockSecurityRegisterTokenResults{pp2, err}
	return e.mock
}

// SecurityRegisterToken implements UserEventbusServiceHandler
func (mmSecurityRegisterToken *UserEventbusServiceHandlerMock) SecurityRegisterToken(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse], err error) {
	mm_atomic.AddUint64(&mmSecurityRegisterToken.beforeSecurityRegisterTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmSecurityRegisterToken.afterSecurityRegisterTokenCounter, 1)

	if mmSecurityRegisterToken.inspectFuncSecurityRegisterToken != nil {
		mmSecurityRegisterToken.inspectFuncSecurityRegisterToken(ctx, pp1)
	}

	mm_params := &UserEventbusServiceHandlerMockSecurityRegisterTokenParams{ctx, pp1}

	// Record call args
	mmSecurityRegisterToken.SecurityRegisterTokenMock.mutex.Lock()
	mmSecurityRegisterToken.SecurityRegisterTokenMock.callArgs = append(mmSecurityRegisterToken.SecurityRegisterTokenMock.callArgs, mm_params)
	mmSecurityRegisterToken.SecurityRegisterTokenMock.mutex.Unlock()

	for _, e := range mmSecurityRegisterToken.SecurityRegisterTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSecurityRegisterToken.SecurityRegisterTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSecurityRegisterToken.SecurityRegisterTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmSecurityRegisterToken.SecurityRegisterTokenMock.defaultExpectation.params
		mm_got := UserEventbusServiceHandlerMockSecurityRegisterTokenParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSecurityRegisterToken.t.Errorf("UserEventbusServiceHandlerMock.SecurityRegisterToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSecurityRegisterToken.SecurityRegisterTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmSecurityRegisterToken.t.Fatal("No results are set for the UserEventbusServiceHandlerMock.SecurityRegisterToken")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSecurityRegisterToken.funcSecurityRegisterToken != nil {
		return mmSecurityRegisterToken.funcSecurityRegisterToken(ctx, pp1)
	}
	mmSecurityRegisterToken.t.Fatalf("Unexpected call to UserEventbusServiceHandlerMock.SecurityRegisterToken. %v %v", ctx, pp1)
	return
}

// SecurityRegisterTokenAfterCounter returns a count of finished UserEventbusServiceHandlerMock.SecurityRegisterToken invocations
func (mmSecurityRegisterToken *UserEventbusServiceHandlerMock) SecurityRegisterTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityRegisterToken.afterSecurityRegisterTokenCounter)
}

// SecurityRegisterTokenBeforeCounter returns a count of UserEventbusServiceHandlerMock.SecurityRegisterToken invocations
func (mmSecurityRegisterToken *UserEventbusServiceHandlerMock) SecurityRegisterTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityRegisterToken.beforeSecurityRegisterTokenCounter)
}

// Calls returns a list of arguments used in each call to UserEventbusServiceHandlerMock.SecurityRegisterToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSecurityRegisterToken *mUserEventbusServiceHandlerMockSecurityRegisterToken) Calls() []*UserEventbusServiceHandlerMockSecurityRegisterTokenParams {
	mmSecurityRegisterToken.mutex.RLock()

	argCopy := make([]*UserEventbusServiceHandlerMockSecurityRegisterTokenParams, len(mmSecurityRegisterToken.callArgs))
	copy(argCopy, mmSecurityRegisterToken.callArgs)

	mmSecurityRegisterToken.mutex.RUnlock()

	return argCopy
}

// MinimockSecurityRegisterTokenDone returns true if the count of the SecurityRegisterToken invocations corresponds
// the number of defined expectations
func (m *UserEventbusServiceHandlerMock) MinimockSecurityRegisterTokenDone() bool {
	for _, e := range m.SecurityRegisterTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityRegisterTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityRegisterTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityRegisterToken != nil && mm_atomic.LoadUint64(&m.afterSecurityRegisterTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockSecurityRegisterTokenInspect logs each unmet expectation
func (m *UserEventbusServiceHandlerMock) MinimockSecurityRegisterTokenInspect() {
	for _, e := range m.SecurityRegisterTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserEventbusServiceHandlerMock.SecurityRegisterToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityRegisterTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityRegisterTokenCounter) < 1 {
		if m.SecurityRegisterTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserEventbusServiceHandlerMock.SecurityRegisterToken")
		} else {
			m.t.Errorf("Expected call to UserEventbusServiceHandlerMock.SecurityRegisterToken with params: %#v", *m.SecurityRegisterTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityRegisterToken != nil && mm_atomic.LoadUint64(&m.afterSecurityRegisterTokenCounter) < 1 {
		m.t.Error("Expected call to UserEventbusServiceHandlerMock.SecurityRegisterToken")
	}
}

type mUserEventbusServiceHandlerMockUserChange struct {
	mock               *UserEventbusServiceHandlerMock
	defaultExpectation *UserEventbusServiceHandlerMockUserChangeExpectation
	expectations       []*UserEventbusServiceHandlerMockUserChangeExpectation

	callArgs []*UserEventbusServiceHandlerMockUserChangeParams
	mutex    sync.RWMutex
}

// UserEventbusServiceHandlerMockUserChangeExpectation specifies expectation struct of the UserEventbusServiceHandler.UserChange
type UserEventbusServiceHandlerMockUserChangeExpectation struct {
	mock    *UserEventbusServiceHandlerMock
	params  *UserEventbusServiceHandlerMockUserChangeParams
	results *UserEventbusServiceHandlerMockUserChangeResults
	Counter uint64
}

// UserEventbusServiceHandlerMockUserChangeParams contains parameters of the UserEventbusServiceHandler.UserChange
type UserEventbusServiceHandlerMockUserChangeParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.UserChangeEvent]
}

// UserEventbusServiceHandlerMockUserChangeResults contains results of the UserEventbusServiceHandler.UserChange
type UserEventbusServiceHandlerMockUserChangeResults struct {
	pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse]
	err error
}

// Expect sets up expected params for UserEventbusServiceHandler.UserChange
func (mmUserChange *mUserEventbusServiceHandlerMockUserChange) Expect(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent]) *mUserEventbusServiceHandlerMockUserChange {
	if mmUserChange.mock.funcUserChange != nil {
		mmUserChange.mock.t.Fatalf("UserEventbusServiceHandlerMock.UserChange mock is already set by Set")
	}

	if mmUserChange.defaultExpectation == nil {
		mmUserChange.defaultExpectation = &UserEventbusServiceHandlerMockUserChangeExpectation{}
	}

	mmUserChange.defaultExpectation.params = &UserEventbusServiceHandlerMockUserChangeParams{ctx, pp1}
	for _, e := range mmUserChange.expectations {
		if minimock.Equal(e.params, mmUserChange.defaultExpectation.params) {
			mmUserChange.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserChange.defaultExpectation.params)
		}
	}

	return mmUserChange
}

// Inspect accepts an inspector function that has same arguments as the UserEventbusServiceHandler.UserChange
func (mmUserChange *mUserEventbusServiceHandlerMockUserChange) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent])) *mUserEventbusServiceHandlerMockUserChange {
	if mmUserChange.mock.inspectFuncUserChange != nil {
		mmUserChange.mock.t.Fatalf("Inspect function is already set for UserEventbusServiceHandlerMock.UserChange")
	}

	mmUserChange.mock.inspectFuncUserChange = f

	return mmUserChange
}

// Return sets up results that will be returned by UserEventbusServiceHandler.UserChange
func (mmUserChange *mUserEventbusServiceHandlerMockUserChange) Return(pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse], err error) *UserEventbusServiceHandlerMock {
	if mmUserChange.mock.funcUserChange != nil {
		mmUserChange.mock.t.Fatalf("UserEventbusServiceHandlerMock.UserChange mock is already set by Set")
	}

	if mmUserChange.defaultExpectation == nil {
		mmUserChange.defaultExpectation = &UserEventbusServiceHandlerMockUserChangeExpectation{mock: mmUserChange.mock}
	}
	mmUserChange.defaultExpectation.results = &UserEventbusServiceHandlerMockUserChangeResults{pp2, err}
	return mmUserChange.mock
}

// Set uses given function f to mock the UserEventbusServiceHandler.UserChange method
func (mmUserChange *mUserEventbusServiceHandlerMockUserChange) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent]) (pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse], err error)) *UserEventbusServiceHandlerMock {
	if mmUserChange.defaultExpectation != nil {
		mmUserChange.mock.t.Fatalf("Default expectation is already set for the UserEventbusServiceHandler.UserChange method")
	}

	if len(mmUserChange.expectations) > 0 {
		mmUserChange.mock.t.Fatalf("Some expectations are already set for the UserEventbusServiceHandler.UserChange method")
	}

	mmUserChange.mock.funcUserChange = f
	return mmUserChange.mock
}

// When sets expectation for the UserEventbusServiceHandler.UserChange which will trigger the result defined by the following
// Then helper
func (mmUserChange *mUserEventbusServiceHandlerMockUserChange) When(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent]) *UserEventbusServiceHandlerMockUserChangeExpectation {
	if mmUserChange.mock.funcUserChange != nil {
		mmUserChange.mock.t.Fatalf("UserEventbusServiceHandlerMock.UserChange mock is already set by Set")
	}

	expectation := &UserEventbusServiceHandlerMockUserChangeExpectation{
		mock:   mmUserChange.mock,
		params: &UserEventbusServiceHandlerMockUserChangeParams{ctx, pp1},
	}
	mmUserChange.expectations = append(mmUserChange.expectations, expectation)
	return expectation
}

// Then sets up UserEventbusServiceHandler.UserChange return parameters for the expectation previously defined by the When method
func (e *UserEventbusServiceHandlerMockUserChangeExpectation) Then(pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse], err error) *UserEventbusServiceHandlerMock {
	e.results = &UserEventbusServiceHandlerMockUserChangeResults{pp2, err}
	return e.mock
}

// UserChange implements UserEventbusServiceHandler
func (mmUserChange *UserEventbusServiceHandlerMock) UserChange(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent]) (pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse], err error) {
	mm_atomic.AddUint64(&mmUserChange.beforeUserChangeCounter, 1)
	defer mm_atomic.AddUint64(&mmUserChange.afterUserChangeCounter, 1)

	if mmUserChange.inspectFuncUserChange != nil {
		mmUserChange.inspectFuncUserChange(ctx, pp1)
	}

	mm_params := &UserEventbusServiceHandlerMockUserChangeParams{ctx, pp1}

	// Record call args
	mmUserChange.UserChangeMock.mutex.Lock()
	mmUserChange.UserChangeMock.callArgs = append(mmUserChange.UserChangeMock.callArgs, mm_params)
	mmUserChange.UserChangeMock.mutex.Unlock()

	for _, e := range mmUserChange.UserChangeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUserChange.UserChangeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserChange.UserChangeMock.defaultExpectation.Counter, 1)
		mm_want := mmUserChange.UserChangeMock.defaultExpectation.params
		mm_got := UserEventbusServiceHandlerMockUserChangeParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserChange.t.Errorf("UserEventbusServiceHandlerMock.UserChange got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserChange.UserChangeMock.defaultExpectation.results
		if mm_results == nil {
			mmUserChange.t.Fatal("No results are set for the UserEventbusServiceHandlerMock.UserChange")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUserChange.funcUserChange != nil {
		return mmUserChange.funcUserChange(ctx, pp1)
	}
	mmUserChange.t.Fatalf("Unexpected call to UserEventbusServiceHandlerMock.UserChange. %v %v", ctx, pp1)
	return
}

// UserChangeAfterCounter returns a count of finished UserEventbusServiceHandlerMock.UserChange invocations
func (mmUserChange *UserEventbusServiceHandlerMock) UserChangeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserChange.afterUserChangeCounter)
}

// UserChangeBeforeCounter returns a count of UserEventbusServiceHandlerMock.UserChange invocations
func (mmUserChange *UserEventbusServiceHandlerMock) UserChangeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserChange.beforeUserChangeCounter)
}

// Calls returns a list of arguments used in each call to UserEventbusServiceHandlerMock.UserChange.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserChange *mUserEventbusServiceHandlerMockUserChange) Calls() []*UserEventbusServiceHandlerMockUserChangeParams {
	mmUserChange.mutex.RLock()

	argCopy := make([]*UserEventbusServiceHandlerMockUserChangeParams, len(mmUserChange.callArgs))
	copy(argCopy, mmUserChange.callArgs)

	mmUserChange.mutex.RUnlock()

	return argCopy
}

// MinimockUserChangeDone returns true if the count of the UserChange invocations corresponds
// the number of defined expectations
func (m *UserEventbusServiceHandlerMock) MinimockUserChangeDone() bool {
	for _, e := range m.UserChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserChangeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserChange != nil && mm_atomic.LoadUint64(&m.afterUserChangeCounter) < 1 {
		return false
	}
	return true
}

// MinimockUserChangeInspect logs each unmet expectation
func (m *UserEventbusServiceHandlerMock) MinimockUserChangeInspect() {
	for _, e := range m.UserChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserEventbusServiceHandlerMock.UserChange with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserChangeCounter) < 1 {
		if m.UserChangeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserEventbusServiceHandlerMock.UserChange")
		} else {
			m.t.Errorf("Expected call to UserEventbusServiceHandlerMock.UserChange with params: %#v", *m.UserChangeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserChange != nil && mm_atomic.LoadUint64(&m.afterUserChangeCounter) < 1 {
		m.t.Error("Expected call to UserEventbusServiceHandlerMock.UserChange")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserEventbusServiceHandlerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockSecurityForgotRequestInspect()

		m.MinimockSecurityInviteTokenInspect()

		m.MinimockSecurityPasswordChangeInspect()

		m.MinimockSecurityRegisterTokenInspect()

		m.MinimockUserChangeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserEventbusServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserEventbusServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSecurityForgotRequestDone() &&
		m.MinimockSecurityInviteTokenDone() &&
		m.MinimockSecurityPasswordChangeDone() &&
		m.MinimockSecurityRegisterTokenDone() &&
		m.MinimockUserChangeDone()
}
