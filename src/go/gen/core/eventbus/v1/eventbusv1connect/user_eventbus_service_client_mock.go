package eventbusv1connect

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/koblas/grpc-todo/gen/core/eventbus/v1/eventbusv1connect.UserEventbusServiceClient -o ./user_eventbus_service_client_mock.go -n UserEventbusServiceClientMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	connect_go "github.com/bufbuild/connect-go"
	"github.com/gojuno/minimock/v3"
	v11 "github.com/koblas/grpc-todo/gen/core/eventbus/v1"
	v1 "github.com/koblas/grpc-todo/gen/core/v1"
)

// UserEventbusServiceClientMock implements UserEventbusServiceClient
type UserEventbusServiceClientMock struct {
	t minimock.Tester

	funcSecurityForgotRequest          func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse], err error)
	inspectFuncSecurityForgotRequest   func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])
	afterSecurityForgotRequestCounter  uint64
	beforeSecurityForgotRequestCounter uint64
	SecurityForgotRequestMock          mUserEventbusServiceClientMockSecurityForgotRequest

	funcSecurityInviteToken          func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse], err error)
	inspectFuncSecurityInviteToken   func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])
	afterSecurityInviteTokenCounter  uint64
	beforeSecurityInviteTokenCounter uint64
	SecurityInviteTokenMock          mUserEventbusServiceClientMockSecurityInviteToken

	funcSecurityPasswordChange          func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse], err error)
	inspectFuncSecurityPasswordChange   func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])
	afterSecurityPasswordChangeCounter  uint64
	beforeSecurityPasswordChangeCounter uint64
	SecurityPasswordChangeMock          mUserEventbusServiceClientMockSecurityPasswordChange

	funcSecurityRegisterToken          func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse], err error)
	inspectFuncSecurityRegisterToken   func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])
	afterSecurityRegisterTokenCounter  uint64
	beforeSecurityRegisterTokenCounter uint64
	SecurityRegisterTokenMock          mUserEventbusServiceClientMockSecurityRegisterToken

	funcUserChange          func(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent]) (pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse], err error)
	inspectFuncUserChange   func(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent])
	afterUserChangeCounter  uint64
	beforeUserChangeCounter uint64
	UserChangeMock          mUserEventbusServiceClientMockUserChange
}

// NewUserEventbusServiceClientMock returns a mock for UserEventbusServiceClient
func NewUserEventbusServiceClientMock(t minimock.Tester) *UserEventbusServiceClientMock {
	m := &UserEventbusServiceClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SecurityForgotRequestMock = mUserEventbusServiceClientMockSecurityForgotRequest{mock: m}
	m.SecurityForgotRequestMock.callArgs = []*UserEventbusServiceClientMockSecurityForgotRequestParams{}

	m.SecurityInviteTokenMock = mUserEventbusServiceClientMockSecurityInviteToken{mock: m}
	m.SecurityInviteTokenMock.callArgs = []*UserEventbusServiceClientMockSecurityInviteTokenParams{}

	m.SecurityPasswordChangeMock = mUserEventbusServiceClientMockSecurityPasswordChange{mock: m}
	m.SecurityPasswordChangeMock.callArgs = []*UserEventbusServiceClientMockSecurityPasswordChangeParams{}

	m.SecurityRegisterTokenMock = mUserEventbusServiceClientMockSecurityRegisterToken{mock: m}
	m.SecurityRegisterTokenMock.callArgs = []*UserEventbusServiceClientMockSecurityRegisterTokenParams{}

	m.UserChangeMock = mUserEventbusServiceClientMockUserChange{mock: m}
	m.UserChangeMock.callArgs = []*UserEventbusServiceClientMockUserChangeParams{}

	return m
}

type mUserEventbusServiceClientMockSecurityForgotRequest struct {
	mock               *UserEventbusServiceClientMock
	defaultExpectation *UserEventbusServiceClientMockSecurityForgotRequestExpectation
	expectations       []*UserEventbusServiceClientMockSecurityForgotRequestExpectation

	callArgs []*UserEventbusServiceClientMockSecurityForgotRequestParams
	mutex    sync.RWMutex
}

// UserEventbusServiceClientMockSecurityForgotRequestExpectation specifies expectation struct of the UserEventbusServiceClient.SecurityForgotRequest
type UserEventbusServiceClientMockSecurityForgotRequestExpectation struct {
	mock    *UserEventbusServiceClientMock
	params  *UserEventbusServiceClientMockSecurityForgotRequestParams
	results *UserEventbusServiceClientMockSecurityForgotRequestResults
	Counter uint64
}

// UserEventbusServiceClientMockSecurityForgotRequestParams contains parameters of the UserEventbusServiceClient.SecurityForgotRequest
type UserEventbusServiceClientMockSecurityForgotRequestParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.UserSecurityEvent]
}

// UserEventbusServiceClientMockSecurityForgotRequestResults contains results of the UserEventbusServiceClient.SecurityForgotRequest
type UserEventbusServiceClientMockSecurityForgotRequestResults struct {
	pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse]
	err error
}

// Expect sets up expected params for UserEventbusServiceClient.SecurityForgotRequest
func (mmSecurityForgotRequest *mUserEventbusServiceClientMockSecurityForgotRequest) Expect(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *mUserEventbusServiceClientMockSecurityForgotRequest {
	if mmSecurityForgotRequest.mock.funcSecurityForgotRequest != nil {
		mmSecurityForgotRequest.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityForgotRequest mock is already set by Set")
	}

	if mmSecurityForgotRequest.defaultExpectation == nil {
		mmSecurityForgotRequest.defaultExpectation = &UserEventbusServiceClientMockSecurityForgotRequestExpectation{}
	}

	mmSecurityForgotRequest.defaultExpectation.params = &UserEventbusServiceClientMockSecurityForgotRequestParams{ctx, pp1}
	for _, e := range mmSecurityForgotRequest.expectations {
		if minimock.Equal(e.params, mmSecurityForgotRequest.defaultExpectation.params) {
			mmSecurityForgotRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSecurityForgotRequest.defaultExpectation.params)
		}
	}

	return mmSecurityForgotRequest
}

// Inspect accepts an inspector function that has same arguments as the UserEventbusServiceClient.SecurityForgotRequest
func (mmSecurityForgotRequest *mUserEventbusServiceClientMockSecurityForgotRequest) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])) *mUserEventbusServiceClientMockSecurityForgotRequest {
	if mmSecurityForgotRequest.mock.inspectFuncSecurityForgotRequest != nil {
		mmSecurityForgotRequest.mock.t.Fatalf("Inspect function is already set for UserEventbusServiceClientMock.SecurityForgotRequest")
	}

	mmSecurityForgotRequest.mock.inspectFuncSecurityForgotRequest = f

	return mmSecurityForgotRequest
}

// Return sets up results that will be returned by UserEventbusServiceClient.SecurityForgotRequest
func (mmSecurityForgotRequest *mUserEventbusServiceClientMockSecurityForgotRequest) Return(pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse], err error) *UserEventbusServiceClientMock {
	if mmSecurityForgotRequest.mock.funcSecurityForgotRequest != nil {
		mmSecurityForgotRequest.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityForgotRequest mock is already set by Set")
	}

	if mmSecurityForgotRequest.defaultExpectation == nil {
		mmSecurityForgotRequest.defaultExpectation = &UserEventbusServiceClientMockSecurityForgotRequestExpectation{mock: mmSecurityForgotRequest.mock}
	}
	mmSecurityForgotRequest.defaultExpectation.results = &UserEventbusServiceClientMockSecurityForgotRequestResults{pp2, err}
	return mmSecurityForgotRequest.mock
}

// Set uses given function f to mock the UserEventbusServiceClient.SecurityForgotRequest method
func (mmSecurityForgotRequest *mUserEventbusServiceClientMockSecurityForgotRequest) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse], err error)) *UserEventbusServiceClientMock {
	if mmSecurityForgotRequest.defaultExpectation != nil {
		mmSecurityForgotRequest.mock.t.Fatalf("Default expectation is already set for the UserEventbusServiceClient.SecurityForgotRequest method")
	}

	if len(mmSecurityForgotRequest.expectations) > 0 {
		mmSecurityForgotRequest.mock.t.Fatalf("Some expectations are already set for the UserEventbusServiceClient.SecurityForgotRequest method")
	}

	mmSecurityForgotRequest.mock.funcSecurityForgotRequest = f
	return mmSecurityForgotRequest.mock
}

// When sets expectation for the UserEventbusServiceClient.SecurityForgotRequest which will trigger the result defined by the following
// Then helper
func (mmSecurityForgotRequest *mUserEventbusServiceClientMockSecurityForgotRequest) When(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *UserEventbusServiceClientMockSecurityForgotRequestExpectation {
	if mmSecurityForgotRequest.mock.funcSecurityForgotRequest != nil {
		mmSecurityForgotRequest.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityForgotRequest mock is already set by Set")
	}

	expectation := &UserEventbusServiceClientMockSecurityForgotRequestExpectation{
		mock:   mmSecurityForgotRequest.mock,
		params: &UserEventbusServiceClientMockSecurityForgotRequestParams{ctx, pp1},
	}
	mmSecurityForgotRequest.expectations = append(mmSecurityForgotRequest.expectations, expectation)
	return expectation
}

// Then sets up UserEventbusServiceClient.SecurityForgotRequest return parameters for the expectation previously defined by the When method
func (e *UserEventbusServiceClientMockSecurityForgotRequestExpectation) Then(pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse], err error) *UserEventbusServiceClientMock {
	e.results = &UserEventbusServiceClientMockSecurityForgotRequestResults{pp2, err}
	return e.mock
}

// SecurityForgotRequest implements UserEventbusServiceClient
func (mmSecurityForgotRequest *UserEventbusServiceClientMock) SecurityForgotRequest(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityForgotRequestResponse], err error) {
	mm_atomic.AddUint64(&mmSecurityForgotRequest.beforeSecurityForgotRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmSecurityForgotRequest.afterSecurityForgotRequestCounter, 1)

	if mmSecurityForgotRequest.inspectFuncSecurityForgotRequest != nil {
		mmSecurityForgotRequest.inspectFuncSecurityForgotRequest(ctx, pp1)
	}

	mm_params := &UserEventbusServiceClientMockSecurityForgotRequestParams{ctx, pp1}

	// Record call args
	mmSecurityForgotRequest.SecurityForgotRequestMock.mutex.Lock()
	mmSecurityForgotRequest.SecurityForgotRequestMock.callArgs = append(mmSecurityForgotRequest.SecurityForgotRequestMock.callArgs, mm_params)
	mmSecurityForgotRequest.SecurityForgotRequestMock.mutex.Unlock()

	for _, e := range mmSecurityForgotRequest.SecurityForgotRequestMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSecurityForgotRequest.SecurityForgotRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSecurityForgotRequest.SecurityForgotRequestMock.defaultExpectation.Counter, 1)
		mm_want := mmSecurityForgotRequest.SecurityForgotRequestMock.defaultExpectation.params
		mm_got := UserEventbusServiceClientMockSecurityForgotRequestParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSecurityForgotRequest.t.Errorf("UserEventbusServiceClientMock.SecurityForgotRequest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSecurityForgotRequest.SecurityForgotRequestMock.defaultExpectation.results
		if mm_results == nil {
			mmSecurityForgotRequest.t.Fatal("No results are set for the UserEventbusServiceClientMock.SecurityForgotRequest")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSecurityForgotRequest.funcSecurityForgotRequest != nil {
		return mmSecurityForgotRequest.funcSecurityForgotRequest(ctx, pp1)
	}
	mmSecurityForgotRequest.t.Fatalf("Unexpected call to UserEventbusServiceClientMock.SecurityForgotRequest. %v %v", ctx, pp1)
	return
}

// SecurityForgotRequestAfterCounter returns a count of finished UserEventbusServiceClientMock.SecurityForgotRequest invocations
func (mmSecurityForgotRequest *UserEventbusServiceClientMock) SecurityForgotRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityForgotRequest.afterSecurityForgotRequestCounter)
}

// SecurityForgotRequestBeforeCounter returns a count of UserEventbusServiceClientMock.SecurityForgotRequest invocations
func (mmSecurityForgotRequest *UserEventbusServiceClientMock) SecurityForgotRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityForgotRequest.beforeSecurityForgotRequestCounter)
}

// Calls returns a list of arguments used in each call to UserEventbusServiceClientMock.SecurityForgotRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSecurityForgotRequest *mUserEventbusServiceClientMockSecurityForgotRequest) Calls() []*UserEventbusServiceClientMockSecurityForgotRequestParams {
	mmSecurityForgotRequest.mutex.RLock()

	argCopy := make([]*UserEventbusServiceClientMockSecurityForgotRequestParams, len(mmSecurityForgotRequest.callArgs))
	copy(argCopy, mmSecurityForgotRequest.callArgs)

	mmSecurityForgotRequest.mutex.RUnlock()

	return argCopy
}

// MinimockSecurityForgotRequestDone returns true if the count of the SecurityForgotRequest invocations corresponds
// the number of defined expectations
func (m *UserEventbusServiceClientMock) MinimockSecurityForgotRequestDone() bool {
	for _, e := range m.SecurityForgotRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityForgotRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityForgotRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityForgotRequest != nil && mm_atomic.LoadUint64(&m.afterSecurityForgotRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockSecurityForgotRequestInspect logs each unmet expectation
func (m *UserEventbusServiceClientMock) MinimockSecurityForgotRequestInspect() {
	for _, e := range m.SecurityForgotRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserEventbusServiceClientMock.SecurityForgotRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityForgotRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityForgotRequestCounter) < 1 {
		if m.SecurityForgotRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserEventbusServiceClientMock.SecurityForgotRequest")
		} else {
			m.t.Errorf("Expected call to UserEventbusServiceClientMock.SecurityForgotRequest with params: %#v", *m.SecurityForgotRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityForgotRequest != nil && mm_atomic.LoadUint64(&m.afterSecurityForgotRequestCounter) < 1 {
		m.t.Error("Expected call to UserEventbusServiceClientMock.SecurityForgotRequest")
	}
}

type mUserEventbusServiceClientMockSecurityInviteToken struct {
	mock               *UserEventbusServiceClientMock
	defaultExpectation *UserEventbusServiceClientMockSecurityInviteTokenExpectation
	expectations       []*UserEventbusServiceClientMockSecurityInviteTokenExpectation

	callArgs []*UserEventbusServiceClientMockSecurityInviteTokenParams
	mutex    sync.RWMutex
}

// UserEventbusServiceClientMockSecurityInviteTokenExpectation specifies expectation struct of the UserEventbusServiceClient.SecurityInviteToken
type UserEventbusServiceClientMockSecurityInviteTokenExpectation struct {
	mock    *UserEventbusServiceClientMock
	params  *UserEventbusServiceClientMockSecurityInviteTokenParams
	results *UserEventbusServiceClientMockSecurityInviteTokenResults
	Counter uint64
}

// UserEventbusServiceClientMockSecurityInviteTokenParams contains parameters of the UserEventbusServiceClient.SecurityInviteToken
type UserEventbusServiceClientMockSecurityInviteTokenParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.UserSecurityEvent]
}

// UserEventbusServiceClientMockSecurityInviteTokenResults contains results of the UserEventbusServiceClient.SecurityInviteToken
type UserEventbusServiceClientMockSecurityInviteTokenResults struct {
	pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse]
	err error
}

// Expect sets up expected params for UserEventbusServiceClient.SecurityInviteToken
func (mmSecurityInviteToken *mUserEventbusServiceClientMockSecurityInviteToken) Expect(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *mUserEventbusServiceClientMockSecurityInviteToken {
	if mmSecurityInviteToken.mock.funcSecurityInviteToken != nil {
		mmSecurityInviteToken.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityInviteToken mock is already set by Set")
	}

	if mmSecurityInviteToken.defaultExpectation == nil {
		mmSecurityInviteToken.defaultExpectation = &UserEventbusServiceClientMockSecurityInviteTokenExpectation{}
	}

	mmSecurityInviteToken.defaultExpectation.params = &UserEventbusServiceClientMockSecurityInviteTokenParams{ctx, pp1}
	for _, e := range mmSecurityInviteToken.expectations {
		if minimock.Equal(e.params, mmSecurityInviteToken.defaultExpectation.params) {
			mmSecurityInviteToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSecurityInviteToken.defaultExpectation.params)
		}
	}

	return mmSecurityInviteToken
}

// Inspect accepts an inspector function that has same arguments as the UserEventbusServiceClient.SecurityInviteToken
func (mmSecurityInviteToken *mUserEventbusServiceClientMockSecurityInviteToken) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])) *mUserEventbusServiceClientMockSecurityInviteToken {
	if mmSecurityInviteToken.mock.inspectFuncSecurityInviteToken != nil {
		mmSecurityInviteToken.mock.t.Fatalf("Inspect function is already set for UserEventbusServiceClientMock.SecurityInviteToken")
	}

	mmSecurityInviteToken.mock.inspectFuncSecurityInviteToken = f

	return mmSecurityInviteToken
}

// Return sets up results that will be returned by UserEventbusServiceClient.SecurityInviteToken
func (mmSecurityInviteToken *mUserEventbusServiceClientMockSecurityInviteToken) Return(pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse], err error) *UserEventbusServiceClientMock {
	if mmSecurityInviteToken.mock.funcSecurityInviteToken != nil {
		mmSecurityInviteToken.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityInviteToken mock is already set by Set")
	}

	if mmSecurityInviteToken.defaultExpectation == nil {
		mmSecurityInviteToken.defaultExpectation = &UserEventbusServiceClientMockSecurityInviteTokenExpectation{mock: mmSecurityInviteToken.mock}
	}
	mmSecurityInviteToken.defaultExpectation.results = &UserEventbusServiceClientMockSecurityInviteTokenResults{pp2, err}
	return mmSecurityInviteToken.mock
}

// Set uses given function f to mock the UserEventbusServiceClient.SecurityInviteToken method
func (mmSecurityInviteToken *mUserEventbusServiceClientMockSecurityInviteToken) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse], err error)) *UserEventbusServiceClientMock {
	if mmSecurityInviteToken.defaultExpectation != nil {
		mmSecurityInviteToken.mock.t.Fatalf("Default expectation is already set for the UserEventbusServiceClient.SecurityInviteToken method")
	}

	if len(mmSecurityInviteToken.expectations) > 0 {
		mmSecurityInviteToken.mock.t.Fatalf("Some expectations are already set for the UserEventbusServiceClient.SecurityInviteToken method")
	}

	mmSecurityInviteToken.mock.funcSecurityInviteToken = f
	return mmSecurityInviteToken.mock
}

// When sets expectation for the UserEventbusServiceClient.SecurityInviteToken which will trigger the result defined by the following
// Then helper
func (mmSecurityInviteToken *mUserEventbusServiceClientMockSecurityInviteToken) When(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *UserEventbusServiceClientMockSecurityInviteTokenExpectation {
	if mmSecurityInviteToken.mock.funcSecurityInviteToken != nil {
		mmSecurityInviteToken.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityInviteToken mock is already set by Set")
	}

	expectation := &UserEventbusServiceClientMockSecurityInviteTokenExpectation{
		mock:   mmSecurityInviteToken.mock,
		params: &UserEventbusServiceClientMockSecurityInviteTokenParams{ctx, pp1},
	}
	mmSecurityInviteToken.expectations = append(mmSecurityInviteToken.expectations, expectation)
	return expectation
}

// Then sets up UserEventbusServiceClient.SecurityInviteToken return parameters for the expectation previously defined by the When method
func (e *UserEventbusServiceClientMockSecurityInviteTokenExpectation) Then(pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse], err error) *UserEventbusServiceClientMock {
	e.results = &UserEventbusServiceClientMockSecurityInviteTokenResults{pp2, err}
	return e.mock
}

// SecurityInviteToken implements UserEventbusServiceClient
func (mmSecurityInviteToken *UserEventbusServiceClientMock) SecurityInviteToken(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityInviteTokenResponse], err error) {
	mm_atomic.AddUint64(&mmSecurityInviteToken.beforeSecurityInviteTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmSecurityInviteToken.afterSecurityInviteTokenCounter, 1)

	if mmSecurityInviteToken.inspectFuncSecurityInviteToken != nil {
		mmSecurityInviteToken.inspectFuncSecurityInviteToken(ctx, pp1)
	}

	mm_params := &UserEventbusServiceClientMockSecurityInviteTokenParams{ctx, pp1}

	// Record call args
	mmSecurityInviteToken.SecurityInviteTokenMock.mutex.Lock()
	mmSecurityInviteToken.SecurityInviteTokenMock.callArgs = append(mmSecurityInviteToken.SecurityInviteTokenMock.callArgs, mm_params)
	mmSecurityInviteToken.SecurityInviteTokenMock.mutex.Unlock()

	for _, e := range mmSecurityInviteToken.SecurityInviteTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSecurityInviteToken.SecurityInviteTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSecurityInviteToken.SecurityInviteTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmSecurityInviteToken.SecurityInviteTokenMock.defaultExpectation.params
		mm_got := UserEventbusServiceClientMockSecurityInviteTokenParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSecurityInviteToken.t.Errorf("UserEventbusServiceClientMock.SecurityInviteToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSecurityInviteToken.SecurityInviteTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmSecurityInviteToken.t.Fatal("No results are set for the UserEventbusServiceClientMock.SecurityInviteToken")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSecurityInviteToken.funcSecurityInviteToken != nil {
		return mmSecurityInviteToken.funcSecurityInviteToken(ctx, pp1)
	}
	mmSecurityInviteToken.t.Fatalf("Unexpected call to UserEventbusServiceClientMock.SecurityInviteToken. %v %v", ctx, pp1)
	return
}

// SecurityInviteTokenAfterCounter returns a count of finished UserEventbusServiceClientMock.SecurityInviteToken invocations
func (mmSecurityInviteToken *UserEventbusServiceClientMock) SecurityInviteTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityInviteToken.afterSecurityInviteTokenCounter)
}

// SecurityInviteTokenBeforeCounter returns a count of UserEventbusServiceClientMock.SecurityInviteToken invocations
func (mmSecurityInviteToken *UserEventbusServiceClientMock) SecurityInviteTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityInviteToken.beforeSecurityInviteTokenCounter)
}

// Calls returns a list of arguments used in each call to UserEventbusServiceClientMock.SecurityInviteToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSecurityInviteToken *mUserEventbusServiceClientMockSecurityInviteToken) Calls() []*UserEventbusServiceClientMockSecurityInviteTokenParams {
	mmSecurityInviteToken.mutex.RLock()

	argCopy := make([]*UserEventbusServiceClientMockSecurityInviteTokenParams, len(mmSecurityInviteToken.callArgs))
	copy(argCopy, mmSecurityInviteToken.callArgs)

	mmSecurityInviteToken.mutex.RUnlock()

	return argCopy
}

// MinimockSecurityInviteTokenDone returns true if the count of the SecurityInviteToken invocations corresponds
// the number of defined expectations
func (m *UserEventbusServiceClientMock) MinimockSecurityInviteTokenDone() bool {
	for _, e := range m.SecurityInviteTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityInviteTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityInviteTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityInviteToken != nil && mm_atomic.LoadUint64(&m.afterSecurityInviteTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockSecurityInviteTokenInspect logs each unmet expectation
func (m *UserEventbusServiceClientMock) MinimockSecurityInviteTokenInspect() {
	for _, e := range m.SecurityInviteTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserEventbusServiceClientMock.SecurityInviteToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityInviteTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityInviteTokenCounter) < 1 {
		if m.SecurityInviteTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserEventbusServiceClientMock.SecurityInviteToken")
		} else {
			m.t.Errorf("Expected call to UserEventbusServiceClientMock.SecurityInviteToken with params: %#v", *m.SecurityInviteTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityInviteToken != nil && mm_atomic.LoadUint64(&m.afterSecurityInviteTokenCounter) < 1 {
		m.t.Error("Expected call to UserEventbusServiceClientMock.SecurityInviteToken")
	}
}

type mUserEventbusServiceClientMockSecurityPasswordChange struct {
	mock               *UserEventbusServiceClientMock
	defaultExpectation *UserEventbusServiceClientMockSecurityPasswordChangeExpectation
	expectations       []*UserEventbusServiceClientMockSecurityPasswordChangeExpectation

	callArgs []*UserEventbusServiceClientMockSecurityPasswordChangeParams
	mutex    sync.RWMutex
}

// UserEventbusServiceClientMockSecurityPasswordChangeExpectation specifies expectation struct of the UserEventbusServiceClient.SecurityPasswordChange
type UserEventbusServiceClientMockSecurityPasswordChangeExpectation struct {
	mock    *UserEventbusServiceClientMock
	params  *UserEventbusServiceClientMockSecurityPasswordChangeParams
	results *UserEventbusServiceClientMockSecurityPasswordChangeResults
	Counter uint64
}

// UserEventbusServiceClientMockSecurityPasswordChangeParams contains parameters of the UserEventbusServiceClient.SecurityPasswordChange
type UserEventbusServiceClientMockSecurityPasswordChangeParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.UserSecurityEvent]
}

// UserEventbusServiceClientMockSecurityPasswordChangeResults contains results of the UserEventbusServiceClient.SecurityPasswordChange
type UserEventbusServiceClientMockSecurityPasswordChangeResults struct {
	pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse]
	err error
}

// Expect sets up expected params for UserEventbusServiceClient.SecurityPasswordChange
func (mmSecurityPasswordChange *mUserEventbusServiceClientMockSecurityPasswordChange) Expect(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *mUserEventbusServiceClientMockSecurityPasswordChange {
	if mmSecurityPasswordChange.mock.funcSecurityPasswordChange != nil {
		mmSecurityPasswordChange.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityPasswordChange mock is already set by Set")
	}

	if mmSecurityPasswordChange.defaultExpectation == nil {
		mmSecurityPasswordChange.defaultExpectation = &UserEventbusServiceClientMockSecurityPasswordChangeExpectation{}
	}

	mmSecurityPasswordChange.defaultExpectation.params = &UserEventbusServiceClientMockSecurityPasswordChangeParams{ctx, pp1}
	for _, e := range mmSecurityPasswordChange.expectations {
		if minimock.Equal(e.params, mmSecurityPasswordChange.defaultExpectation.params) {
			mmSecurityPasswordChange.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSecurityPasswordChange.defaultExpectation.params)
		}
	}

	return mmSecurityPasswordChange
}

// Inspect accepts an inspector function that has same arguments as the UserEventbusServiceClient.SecurityPasswordChange
func (mmSecurityPasswordChange *mUserEventbusServiceClientMockSecurityPasswordChange) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])) *mUserEventbusServiceClientMockSecurityPasswordChange {
	if mmSecurityPasswordChange.mock.inspectFuncSecurityPasswordChange != nil {
		mmSecurityPasswordChange.mock.t.Fatalf("Inspect function is already set for UserEventbusServiceClientMock.SecurityPasswordChange")
	}

	mmSecurityPasswordChange.mock.inspectFuncSecurityPasswordChange = f

	return mmSecurityPasswordChange
}

// Return sets up results that will be returned by UserEventbusServiceClient.SecurityPasswordChange
func (mmSecurityPasswordChange *mUserEventbusServiceClientMockSecurityPasswordChange) Return(pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse], err error) *UserEventbusServiceClientMock {
	if mmSecurityPasswordChange.mock.funcSecurityPasswordChange != nil {
		mmSecurityPasswordChange.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityPasswordChange mock is already set by Set")
	}

	if mmSecurityPasswordChange.defaultExpectation == nil {
		mmSecurityPasswordChange.defaultExpectation = &UserEventbusServiceClientMockSecurityPasswordChangeExpectation{mock: mmSecurityPasswordChange.mock}
	}
	mmSecurityPasswordChange.defaultExpectation.results = &UserEventbusServiceClientMockSecurityPasswordChangeResults{pp2, err}
	return mmSecurityPasswordChange.mock
}

// Set uses given function f to mock the UserEventbusServiceClient.SecurityPasswordChange method
func (mmSecurityPasswordChange *mUserEventbusServiceClientMockSecurityPasswordChange) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse], err error)) *UserEventbusServiceClientMock {
	if mmSecurityPasswordChange.defaultExpectation != nil {
		mmSecurityPasswordChange.mock.t.Fatalf("Default expectation is already set for the UserEventbusServiceClient.SecurityPasswordChange method")
	}

	if len(mmSecurityPasswordChange.expectations) > 0 {
		mmSecurityPasswordChange.mock.t.Fatalf("Some expectations are already set for the UserEventbusServiceClient.SecurityPasswordChange method")
	}

	mmSecurityPasswordChange.mock.funcSecurityPasswordChange = f
	return mmSecurityPasswordChange.mock
}

// When sets expectation for the UserEventbusServiceClient.SecurityPasswordChange which will trigger the result defined by the following
// Then helper
func (mmSecurityPasswordChange *mUserEventbusServiceClientMockSecurityPasswordChange) When(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *UserEventbusServiceClientMockSecurityPasswordChangeExpectation {
	if mmSecurityPasswordChange.mock.funcSecurityPasswordChange != nil {
		mmSecurityPasswordChange.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityPasswordChange mock is already set by Set")
	}

	expectation := &UserEventbusServiceClientMockSecurityPasswordChangeExpectation{
		mock:   mmSecurityPasswordChange.mock,
		params: &UserEventbusServiceClientMockSecurityPasswordChangeParams{ctx, pp1},
	}
	mmSecurityPasswordChange.expectations = append(mmSecurityPasswordChange.expectations, expectation)
	return expectation
}

// Then sets up UserEventbusServiceClient.SecurityPasswordChange return parameters for the expectation previously defined by the When method
func (e *UserEventbusServiceClientMockSecurityPasswordChangeExpectation) Then(pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse], err error) *UserEventbusServiceClientMock {
	e.results = &UserEventbusServiceClientMockSecurityPasswordChangeResults{pp2, err}
	return e.mock
}

// SecurityPasswordChange implements UserEventbusServiceClient
func (mmSecurityPasswordChange *UserEventbusServiceClientMock) SecurityPasswordChange(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityPasswordChangeResponse], err error) {
	mm_atomic.AddUint64(&mmSecurityPasswordChange.beforeSecurityPasswordChangeCounter, 1)
	defer mm_atomic.AddUint64(&mmSecurityPasswordChange.afterSecurityPasswordChangeCounter, 1)

	if mmSecurityPasswordChange.inspectFuncSecurityPasswordChange != nil {
		mmSecurityPasswordChange.inspectFuncSecurityPasswordChange(ctx, pp1)
	}

	mm_params := &UserEventbusServiceClientMockSecurityPasswordChangeParams{ctx, pp1}

	// Record call args
	mmSecurityPasswordChange.SecurityPasswordChangeMock.mutex.Lock()
	mmSecurityPasswordChange.SecurityPasswordChangeMock.callArgs = append(mmSecurityPasswordChange.SecurityPasswordChangeMock.callArgs, mm_params)
	mmSecurityPasswordChange.SecurityPasswordChangeMock.mutex.Unlock()

	for _, e := range mmSecurityPasswordChange.SecurityPasswordChangeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSecurityPasswordChange.SecurityPasswordChangeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSecurityPasswordChange.SecurityPasswordChangeMock.defaultExpectation.Counter, 1)
		mm_want := mmSecurityPasswordChange.SecurityPasswordChangeMock.defaultExpectation.params
		mm_got := UserEventbusServiceClientMockSecurityPasswordChangeParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSecurityPasswordChange.t.Errorf("UserEventbusServiceClientMock.SecurityPasswordChange got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSecurityPasswordChange.SecurityPasswordChangeMock.defaultExpectation.results
		if mm_results == nil {
			mmSecurityPasswordChange.t.Fatal("No results are set for the UserEventbusServiceClientMock.SecurityPasswordChange")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSecurityPasswordChange.funcSecurityPasswordChange != nil {
		return mmSecurityPasswordChange.funcSecurityPasswordChange(ctx, pp1)
	}
	mmSecurityPasswordChange.t.Fatalf("Unexpected call to UserEventbusServiceClientMock.SecurityPasswordChange. %v %v", ctx, pp1)
	return
}

// SecurityPasswordChangeAfterCounter returns a count of finished UserEventbusServiceClientMock.SecurityPasswordChange invocations
func (mmSecurityPasswordChange *UserEventbusServiceClientMock) SecurityPasswordChangeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityPasswordChange.afterSecurityPasswordChangeCounter)
}

// SecurityPasswordChangeBeforeCounter returns a count of UserEventbusServiceClientMock.SecurityPasswordChange invocations
func (mmSecurityPasswordChange *UserEventbusServiceClientMock) SecurityPasswordChangeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityPasswordChange.beforeSecurityPasswordChangeCounter)
}

// Calls returns a list of arguments used in each call to UserEventbusServiceClientMock.SecurityPasswordChange.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSecurityPasswordChange *mUserEventbusServiceClientMockSecurityPasswordChange) Calls() []*UserEventbusServiceClientMockSecurityPasswordChangeParams {
	mmSecurityPasswordChange.mutex.RLock()

	argCopy := make([]*UserEventbusServiceClientMockSecurityPasswordChangeParams, len(mmSecurityPasswordChange.callArgs))
	copy(argCopy, mmSecurityPasswordChange.callArgs)

	mmSecurityPasswordChange.mutex.RUnlock()

	return argCopy
}

// MinimockSecurityPasswordChangeDone returns true if the count of the SecurityPasswordChange invocations corresponds
// the number of defined expectations
func (m *UserEventbusServiceClientMock) MinimockSecurityPasswordChangeDone() bool {
	for _, e := range m.SecurityPasswordChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityPasswordChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityPasswordChangeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityPasswordChange != nil && mm_atomic.LoadUint64(&m.afterSecurityPasswordChangeCounter) < 1 {
		return false
	}
	return true
}

// MinimockSecurityPasswordChangeInspect logs each unmet expectation
func (m *UserEventbusServiceClientMock) MinimockSecurityPasswordChangeInspect() {
	for _, e := range m.SecurityPasswordChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserEventbusServiceClientMock.SecurityPasswordChange with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityPasswordChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityPasswordChangeCounter) < 1 {
		if m.SecurityPasswordChangeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserEventbusServiceClientMock.SecurityPasswordChange")
		} else {
			m.t.Errorf("Expected call to UserEventbusServiceClientMock.SecurityPasswordChange with params: %#v", *m.SecurityPasswordChangeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityPasswordChange != nil && mm_atomic.LoadUint64(&m.afterSecurityPasswordChangeCounter) < 1 {
		m.t.Error("Expected call to UserEventbusServiceClientMock.SecurityPasswordChange")
	}
}

type mUserEventbusServiceClientMockSecurityRegisterToken struct {
	mock               *UserEventbusServiceClientMock
	defaultExpectation *UserEventbusServiceClientMockSecurityRegisterTokenExpectation
	expectations       []*UserEventbusServiceClientMockSecurityRegisterTokenExpectation

	callArgs []*UserEventbusServiceClientMockSecurityRegisterTokenParams
	mutex    sync.RWMutex
}

// UserEventbusServiceClientMockSecurityRegisterTokenExpectation specifies expectation struct of the UserEventbusServiceClient.SecurityRegisterToken
type UserEventbusServiceClientMockSecurityRegisterTokenExpectation struct {
	mock    *UserEventbusServiceClientMock
	params  *UserEventbusServiceClientMockSecurityRegisterTokenParams
	results *UserEventbusServiceClientMockSecurityRegisterTokenResults
	Counter uint64
}

// UserEventbusServiceClientMockSecurityRegisterTokenParams contains parameters of the UserEventbusServiceClient.SecurityRegisterToken
type UserEventbusServiceClientMockSecurityRegisterTokenParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.UserSecurityEvent]
}

// UserEventbusServiceClientMockSecurityRegisterTokenResults contains results of the UserEventbusServiceClient.SecurityRegisterToken
type UserEventbusServiceClientMockSecurityRegisterTokenResults struct {
	pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse]
	err error
}

// Expect sets up expected params for UserEventbusServiceClient.SecurityRegisterToken
func (mmSecurityRegisterToken *mUserEventbusServiceClientMockSecurityRegisterToken) Expect(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *mUserEventbusServiceClientMockSecurityRegisterToken {
	if mmSecurityRegisterToken.mock.funcSecurityRegisterToken != nil {
		mmSecurityRegisterToken.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityRegisterToken mock is already set by Set")
	}

	if mmSecurityRegisterToken.defaultExpectation == nil {
		mmSecurityRegisterToken.defaultExpectation = &UserEventbusServiceClientMockSecurityRegisterTokenExpectation{}
	}

	mmSecurityRegisterToken.defaultExpectation.params = &UserEventbusServiceClientMockSecurityRegisterTokenParams{ctx, pp1}
	for _, e := range mmSecurityRegisterToken.expectations {
		if minimock.Equal(e.params, mmSecurityRegisterToken.defaultExpectation.params) {
			mmSecurityRegisterToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSecurityRegisterToken.defaultExpectation.params)
		}
	}

	return mmSecurityRegisterToken
}

// Inspect accepts an inspector function that has same arguments as the UserEventbusServiceClient.SecurityRegisterToken
func (mmSecurityRegisterToken *mUserEventbusServiceClientMockSecurityRegisterToken) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent])) *mUserEventbusServiceClientMockSecurityRegisterToken {
	if mmSecurityRegisterToken.mock.inspectFuncSecurityRegisterToken != nil {
		mmSecurityRegisterToken.mock.t.Fatalf("Inspect function is already set for UserEventbusServiceClientMock.SecurityRegisterToken")
	}

	mmSecurityRegisterToken.mock.inspectFuncSecurityRegisterToken = f

	return mmSecurityRegisterToken
}

// Return sets up results that will be returned by UserEventbusServiceClient.SecurityRegisterToken
func (mmSecurityRegisterToken *mUserEventbusServiceClientMockSecurityRegisterToken) Return(pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse], err error) *UserEventbusServiceClientMock {
	if mmSecurityRegisterToken.mock.funcSecurityRegisterToken != nil {
		mmSecurityRegisterToken.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityRegisterToken mock is already set by Set")
	}

	if mmSecurityRegisterToken.defaultExpectation == nil {
		mmSecurityRegisterToken.defaultExpectation = &UserEventbusServiceClientMockSecurityRegisterTokenExpectation{mock: mmSecurityRegisterToken.mock}
	}
	mmSecurityRegisterToken.defaultExpectation.results = &UserEventbusServiceClientMockSecurityRegisterTokenResults{pp2, err}
	return mmSecurityRegisterToken.mock
}

// Set uses given function f to mock the UserEventbusServiceClient.SecurityRegisterToken method
func (mmSecurityRegisterToken *mUserEventbusServiceClientMockSecurityRegisterToken) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse], err error)) *UserEventbusServiceClientMock {
	if mmSecurityRegisterToken.defaultExpectation != nil {
		mmSecurityRegisterToken.mock.t.Fatalf("Default expectation is already set for the UserEventbusServiceClient.SecurityRegisterToken method")
	}

	if len(mmSecurityRegisterToken.expectations) > 0 {
		mmSecurityRegisterToken.mock.t.Fatalf("Some expectations are already set for the UserEventbusServiceClient.SecurityRegisterToken method")
	}

	mmSecurityRegisterToken.mock.funcSecurityRegisterToken = f
	return mmSecurityRegisterToken.mock
}

// When sets expectation for the UserEventbusServiceClient.SecurityRegisterToken which will trigger the result defined by the following
// Then helper
func (mmSecurityRegisterToken *mUserEventbusServiceClientMockSecurityRegisterToken) When(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) *UserEventbusServiceClientMockSecurityRegisterTokenExpectation {
	if mmSecurityRegisterToken.mock.funcSecurityRegisterToken != nil {
		mmSecurityRegisterToken.mock.t.Fatalf("UserEventbusServiceClientMock.SecurityRegisterToken mock is already set by Set")
	}

	expectation := &UserEventbusServiceClientMockSecurityRegisterTokenExpectation{
		mock:   mmSecurityRegisterToken.mock,
		params: &UserEventbusServiceClientMockSecurityRegisterTokenParams{ctx, pp1},
	}
	mmSecurityRegisterToken.expectations = append(mmSecurityRegisterToken.expectations, expectation)
	return expectation
}

// Then sets up UserEventbusServiceClient.SecurityRegisterToken return parameters for the expectation previously defined by the When method
func (e *UserEventbusServiceClientMockSecurityRegisterTokenExpectation) Then(pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse], err error) *UserEventbusServiceClientMock {
	e.results = &UserEventbusServiceClientMockSecurityRegisterTokenResults{pp2, err}
	return e.mock
}

// SecurityRegisterToken implements UserEventbusServiceClient
func (mmSecurityRegisterToken *UserEventbusServiceClientMock) SecurityRegisterToken(ctx context.Context, pp1 *connect_go.Request[v1.UserSecurityEvent]) (pp2 *connect_go.Response[v11.UserEventbusSecurityRegisterTokenResponse], err error) {
	mm_atomic.AddUint64(&mmSecurityRegisterToken.beforeSecurityRegisterTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmSecurityRegisterToken.afterSecurityRegisterTokenCounter, 1)

	if mmSecurityRegisterToken.inspectFuncSecurityRegisterToken != nil {
		mmSecurityRegisterToken.inspectFuncSecurityRegisterToken(ctx, pp1)
	}

	mm_params := &UserEventbusServiceClientMockSecurityRegisterTokenParams{ctx, pp1}

	// Record call args
	mmSecurityRegisterToken.SecurityRegisterTokenMock.mutex.Lock()
	mmSecurityRegisterToken.SecurityRegisterTokenMock.callArgs = append(mmSecurityRegisterToken.SecurityRegisterTokenMock.callArgs, mm_params)
	mmSecurityRegisterToken.SecurityRegisterTokenMock.mutex.Unlock()

	for _, e := range mmSecurityRegisterToken.SecurityRegisterTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmSecurityRegisterToken.SecurityRegisterTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSecurityRegisterToken.SecurityRegisterTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmSecurityRegisterToken.SecurityRegisterTokenMock.defaultExpectation.params
		mm_got := UserEventbusServiceClientMockSecurityRegisterTokenParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSecurityRegisterToken.t.Errorf("UserEventbusServiceClientMock.SecurityRegisterToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSecurityRegisterToken.SecurityRegisterTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmSecurityRegisterToken.t.Fatal("No results are set for the UserEventbusServiceClientMock.SecurityRegisterToken")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmSecurityRegisterToken.funcSecurityRegisterToken != nil {
		return mmSecurityRegisterToken.funcSecurityRegisterToken(ctx, pp1)
	}
	mmSecurityRegisterToken.t.Fatalf("Unexpected call to UserEventbusServiceClientMock.SecurityRegisterToken. %v %v", ctx, pp1)
	return
}

// SecurityRegisterTokenAfterCounter returns a count of finished UserEventbusServiceClientMock.SecurityRegisterToken invocations
func (mmSecurityRegisterToken *UserEventbusServiceClientMock) SecurityRegisterTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityRegisterToken.afterSecurityRegisterTokenCounter)
}

// SecurityRegisterTokenBeforeCounter returns a count of UserEventbusServiceClientMock.SecurityRegisterToken invocations
func (mmSecurityRegisterToken *UserEventbusServiceClientMock) SecurityRegisterTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSecurityRegisterToken.beforeSecurityRegisterTokenCounter)
}

// Calls returns a list of arguments used in each call to UserEventbusServiceClientMock.SecurityRegisterToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSecurityRegisterToken *mUserEventbusServiceClientMockSecurityRegisterToken) Calls() []*UserEventbusServiceClientMockSecurityRegisterTokenParams {
	mmSecurityRegisterToken.mutex.RLock()

	argCopy := make([]*UserEventbusServiceClientMockSecurityRegisterTokenParams, len(mmSecurityRegisterToken.callArgs))
	copy(argCopy, mmSecurityRegisterToken.callArgs)

	mmSecurityRegisterToken.mutex.RUnlock()

	return argCopy
}

// MinimockSecurityRegisterTokenDone returns true if the count of the SecurityRegisterToken invocations corresponds
// the number of defined expectations
func (m *UserEventbusServiceClientMock) MinimockSecurityRegisterTokenDone() bool {
	for _, e := range m.SecurityRegisterTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityRegisterTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityRegisterTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityRegisterToken != nil && mm_atomic.LoadUint64(&m.afterSecurityRegisterTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockSecurityRegisterTokenInspect logs each unmet expectation
func (m *UserEventbusServiceClientMock) MinimockSecurityRegisterTokenInspect() {
	for _, e := range m.SecurityRegisterTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserEventbusServiceClientMock.SecurityRegisterToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SecurityRegisterTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSecurityRegisterTokenCounter) < 1 {
		if m.SecurityRegisterTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserEventbusServiceClientMock.SecurityRegisterToken")
		} else {
			m.t.Errorf("Expected call to UserEventbusServiceClientMock.SecurityRegisterToken with params: %#v", *m.SecurityRegisterTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSecurityRegisterToken != nil && mm_atomic.LoadUint64(&m.afterSecurityRegisterTokenCounter) < 1 {
		m.t.Error("Expected call to UserEventbusServiceClientMock.SecurityRegisterToken")
	}
}

type mUserEventbusServiceClientMockUserChange struct {
	mock               *UserEventbusServiceClientMock
	defaultExpectation *UserEventbusServiceClientMockUserChangeExpectation
	expectations       []*UserEventbusServiceClientMockUserChangeExpectation

	callArgs []*UserEventbusServiceClientMockUserChangeParams
	mutex    sync.RWMutex
}

// UserEventbusServiceClientMockUserChangeExpectation specifies expectation struct of the UserEventbusServiceClient.UserChange
type UserEventbusServiceClientMockUserChangeExpectation struct {
	mock    *UserEventbusServiceClientMock
	params  *UserEventbusServiceClientMockUserChangeParams
	results *UserEventbusServiceClientMockUserChangeResults
	Counter uint64
}

// UserEventbusServiceClientMockUserChangeParams contains parameters of the UserEventbusServiceClient.UserChange
type UserEventbusServiceClientMockUserChangeParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.UserChangeEvent]
}

// UserEventbusServiceClientMockUserChangeResults contains results of the UserEventbusServiceClient.UserChange
type UserEventbusServiceClientMockUserChangeResults struct {
	pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse]
	err error
}

// Expect sets up expected params for UserEventbusServiceClient.UserChange
func (mmUserChange *mUserEventbusServiceClientMockUserChange) Expect(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent]) *mUserEventbusServiceClientMockUserChange {
	if mmUserChange.mock.funcUserChange != nil {
		mmUserChange.mock.t.Fatalf("UserEventbusServiceClientMock.UserChange mock is already set by Set")
	}

	if mmUserChange.defaultExpectation == nil {
		mmUserChange.defaultExpectation = &UserEventbusServiceClientMockUserChangeExpectation{}
	}

	mmUserChange.defaultExpectation.params = &UserEventbusServiceClientMockUserChangeParams{ctx, pp1}
	for _, e := range mmUserChange.expectations {
		if minimock.Equal(e.params, mmUserChange.defaultExpectation.params) {
			mmUserChange.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserChange.defaultExpectation.params)
		}
	}

	return mmUserChange
}

// Inspect accepts an inspector function that has same arguments as the UserEventbusServiceClient.UserChange
func (mmUserChange *mUserEventbusServiceClientMockUserChange) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent])) *mUserEventbusServiceClientMockUserChange {
	if mmUserChange.mock.inspectFuncUserChange != nil {
		mmUserChange.mock.t.Fatalf("Inspect function is already set for UserEventbusServiceClientMock.UserChange")
	}

	mmUserChange.mock.inspectFuncUserChange = f

	return mmUserChange
}

// Return sets up results that will be returned by UserEventbusServiceClient.UserChange
func (mmUserChange *mUserEventbusServiceClientMockUserChange) Return(pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse], err error) *UserEventbusServiceClientMock {
	if mmUserChange.mock.funcUserChange != nil {
		mmUserChange.mock.t.Fatalf("UserEventbusServiceClientMock.UserChange mock is already set by Set")
	}

	if mmUserChange.defaultExpectation == nil {
		mmUserChange.defaultExpectation = &UserEventbusServiceClientMockUserChangeExpectation{mock: mmUserChange.mock}
	}
	mmUserChange.defaultExpectation.results = &UserEventbusServiceClientMockUserChangeResults{pp2, err}
	return mmUserChange.mock
}

// Set uses given function f to mock the UserEventbusServiceClient.UserChange method
func (mmUserChange *mUserEventbusServiceClientMockUserChange) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent]) (pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse], err error)) *UserEventbusServiceClientMock {
	if mmUserChange.defaultExpectation != nil {
		mmUserChange.mock.t.Fatalf("Default expectation is already set for the UserEventbusServiceClient.UserChange method")
	}

	if len(mmUserChange.expectations) > 0 {
		mmUserChange.mock.t.Fatalf("Some expectations are already set for the UserEventbusServiceClient.UserChange method")
	}

	mmUserChange.mock.funcUserChange = f
	return mmUserChange.mock
}

// When sets expectation for the UserEventbusServiceClient.UserChange which will trigger the result defined by the following
// Then helper
func (mmUserChange *mUserEventbusServiceClientMockUserChange) When(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent]) *UserEventbusServiceClientMockUserChangeExpectation {
	if mmUserChange.mock.funcUserChange != nil {
		mmUserChange.mock.t.Fatalf("UserEventbusServiceClientMock.UserChange mock is already set by Set")
	}

	expectation := &UserEventbusServiceClientMockUserChangeExpectation{
		mock:   mmUserChange.mock,
		params: &UserEventbusServiceClientMockUserChangeParams{ctx, pp1},
	}
	mmUserChange.expectations = append(mmUserChange.expectations, expectation)
	return expectation
}

// Then sets up UserEventbusServiceClient.UserChange return parameters for the expectation previously defined by the When method
func (e *UserEventbusServiceClientMockUserChangeExpectation) Then(pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse], err error) *UserEventbusServiceClientMock {
	e.results = &UserEventbusServiceClientMockUserChangeResults{pp2, err}
	return e.mock
}

// UserChange implements UserEventbusServiceClient
func (mmUserChange *UserEventbusServiceClientMock) UserChange(ctx context.Context, pp1 *connect_go.Request[v1.UserChangeEvent]) (pp2 *connect_go.Response[v11.UserEventbusUserChangeResponse], err error) {
	mm_atomic.AddUint64(&mmUserChange.beforeUserChangeCounter, 1)
	defer mm_atomic.AddUint64(&mmUserChange.afterUserChangeCounter, 1)

	if mmUserChange.inspectFuncUserChange != nil {
		mmUserChange.inspectFuncUserChange(ctx, pp1)
	}

	mm_params := &UserEventbusServiceClientMockUserChangeParams{ctx, pp1}

	// Record call args
	mmUserChange.UserChangeMock.mutex.Lock()
	mmUserChange.UserChangeMock.callArgs = append(mmUserChange.UserChangeMock.callArgs, mm_params)
	mmUserChange.UserChangeMock.mutex.Unlock()

	for _, e := range mmUserChange.UserChangeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUserChange.UserChangeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserChange.UserChangeMock.defaultExpectation.Counter, 1)
		mm_want := mmUserChange.UserChangeMock.defaultExpectation.params
		mm_got := UserEventbusServiceClientMockUserChangeParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserChange.t.Errorf("UserEventbusServiceClientMock.UserChange got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserChange.UserChangeMock.defaultExpectation.results
		if mm_results == nil {
			mmUserChange.t.Fatal("No results are set for the UserEventbusServiceClientMock.UserChange")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUserChange.funcUserChange != nil {
		return mmUserChange.funcUserChange(ctx, pp1)
	}
	mmUserChange.t.Fatalf("Unexpected call to UserEventbusServiceClientMock.UserChange. %v %v", ctx, pp1)
	return
}

// UserChangeAfterCounter returns a count of finished UserEventbusServiceClientMock.UserChange invocations
func (mmUserChange *UserEventbusServiceClientMock) UserChangeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserChange.afterUserChangeCounter)
}

// UserChangeBeforeCounter returns a count of UserEventbusServiceClientMock.UserChange invocations
func (mmUserChange *UserEventbusServiceClientMock) UserChangeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserChange.beforeUserChangeCounter)
}

// Calls returns a list of arguments used in each call to UserEventbusServiceClientMock.UserChange.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserChange *mUserEventbusServiceClientMockUserChange) Calls() []*UserEventbusServiceClientMockUserChangeParams {
	mmUserChange.mutex.RLock()

	argCopy := make([]*UserEventbusServiceClientMockUserChangeParams, len(mmUserChange.callArgs))
	copy(argCopy, mmUserChange.callArgs)

	mmUserChange.mutex.RUnlock()

	return argCopy
}

// MinimockUserChangeDone returns true if the count of the UserChange invocations corresponds
// the number of defined expectations
func (m *UserEventbusServiceClientMock) MinimockUserChangeDone() bool {
	for _, e := range m.UserChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserChangeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserChange != nil && mm_atomic.LoadUint64(&m.afterUserChangeCounter) < 1 {
		return false
	}
	return true
}

// MinimockUserChangeInspect logs each unmet expectation
func (m *UserEventbusServiceClientMock) MinimockUserChangeInspect() {
	for _, e := range m.UserChangeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserEventbusServiceClientMock.UserChange with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserChangeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserChangeCounter) < 1 {
		if m.UserChangeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserEventbusServiceClientMock.UserChange")
		} else {
			m.t.Errorf("Expected call to UserEventbusServiceClientMock.UserChange with params: %#v", *m.UserChangeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserChange != nil && mm_atomic.LoadUint64(&m.afterUserChangeCounter) < 1 {
		m.t.Error("Expected call to UserEventbusServiceClientMock.UserChange")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserEventbusServiceClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockSecurityForgotRequestInspect()

		m.MinimockSecurityInviteTokenInspect()

		m.MinimockSecurityPasswordChangeInspect()

		m.MinimockSecurityRegisterTokenInspect()

		m.MinimockUserChangeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserEventbusServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserEventbusServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSecurityForgotRequestDone() &&
		m.MinimockSecurityInviteTokenDone() &&
		m.MinimockSecurityPasswordChangeDone() &&
		m.MinimockSecurityRegisterTokenDone() &&
		m.MinimockUserChangeDone()
}
