package messagev1connect

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/koblas/grpc-todo/gen/core/message/v1/messagev1connect.MessageServiceClient -o ./message_service_client_mock.go -n MessageServiceClientMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	connect_go "github.com/bufbuild/connect-go"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/koblas/grpc-todo/gen/core/message/v1"
)

// MessageServiceClientMock implements MessageServiceClient
type MessageServiceClientMock struct {
	t minimock.Tester

	funcAdd          func(ctx context.Context, pp1 *connect_go.Request[v1.AddRequest]) (pp2 *connect_go.Response[v1.AddResponse], err error)
	inspectFuncAdd   func(ctx context.Context, pp1 *connect_go.Request[v1.AddRequest])
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mMessageServiceClientMockAdd

	funcDelete          func(ctx context.Context, pp1 *connect_go.Request[v1.DeleteRequest]) (pp2 *connect_go.Response[v1.DeleteResponse], err error)
	inspectFuncDelete   func(ctx context.Context, pp1 *connect_go.Request[v1.DeleteRequest])
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mMessageServiceClientMockDelete

	funcList          func(ctx context.Context, pp1 *connect_go.Request[v1.ListRequest]) (pp2 *connect_go.Response[v1.ListResponse], err error)
	inspectFuncList   func(ctx context.Context, pp1 *connect_go.Request[v1.ListRequest])
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mMessageServiceClientMockList

	funcRoomJoin          func(ctx context.Context, pp1 *connect_go.Request[v1.RoomJoinRequest]) (pp2 *connect_go.Response[v1.RoomJoinResponse], err error)
	inspectFuncRoomJoin   func(ctx context.Context, pp1 *connect_go.Request[v1.RoomJoinRequest])
	afterRoomJoinCounter  uint64
	beforeRoomJoinCounter uint64
	RoomJoinMock          mMessageServiceClientMockRoomJoin

	funcRoomList          func(ctx context.Context, pp1 *connect_go.Request[v1.RoomListRequest]) (pp2 *connect_go.Response[v1.RoomListResponse], err error)
	inspectFuncRoomList   func(ctx context.Context, pp1 *connect_go.Request[v1.RoomListRequest])
	afterRoomListCounter  uint64
	beforeRoomListCounter uint64
	RoomListMock          mMessageServiceClientMockRoomList
}

// NewMessageServiceClientMock returns a mock for MessageServiceClient
func NewMessageServiceClientMock(t minimock.Tester) *MessageServiceClientMock {
	m := &MessageServiceClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mMessageServiceClientMockAdd{mock: m}
	m.AddMock.callArgs = []*MessageServiceClientMockAddParams{}

	m.DeleteMock = mMessageServiceClientMockDelete{mock: m}
	m.DeleteMock.callArgs = []*MessageServiceClientMockDeleteParams{}

	m.ListMock = mMessageServiceClientMockList{mock: m}
	m.ListMock.callArgs = []*MessageServiceClientMockListParams{}

	m.RoomJoinMock = mMessageServiceClientMockRoomJoin{mock: m}
	m.RoomJoinMock.callArgs = []*MessageServiceClientMockRoomJoinParams{}

	m.RoomListMock = mMessageServiceClientMockRoomList{mock: m}
	m.RoomListMock.callArgs = []*MessageServiceClientMockRoomListParams{}

	return m
}

type mMessageServiceClientMockAdd struct {
	mock               *MessageServiceClientMock
	defaultExpectation *MessageServiceClientMockAddExpectation
	expectations       []*MessageServiceClientMockAddExpectation

	callArgs []*MessageServiceClientMockAddParams
	mutex    sync.RWMutex
}

// MessageServiceClientMockAddExpectation specifies expectation struct of the MessageServiceClient.Add
type MessageServiceClientMockAddExpectation struct {
	mock    *MessageServiceClientMock
	params  *MessageServiceClientMockAddParams
	results *MessageServiceClientMockAddResults
	Counter uint64
}

// MessageServiceClientMockAddParams contains parameters of the MessageServiceClient.Add
type MessageServiceClientMockAddParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.AddRequest]
}

// MessageServiceClientMockAddResults contains results of the MessageServiceClient.Add
type MessageServiceClientMockAddResults struct {
	pp2 *connect_go.Response[v1.AddResponse]
	err error
}

// Expect sets up expected params for MessageServiceClient.Add
func (mmAdd *mMessageServiceClientMockAdd) Expect(ctx context.Context, pp1 *connect_go.Request[v1.AddRequest]) *mMessageServiceClientMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("MessageServiceClientMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &MessageServiceClientMockAddExpectation{}
	}

	mmAdd.defaultExpectation.params = &MessageServiceClientMockAddParams{ctx, pp1}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the MessageServiceClient.Add
func (mmAdd *mMessageServiceClientMockAdd) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.AddRequest])) *mMessageServiceClientMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for MessageServiceClientMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by MessageServiceClient.Add
func (mmAdd *mMessageServiceClientMockAdd) Return(pp2 *connect_go.Response[v1.AddResponse], err error) *MessageServiceClientMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("MessageServiceClientMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &MessageServiceClientMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &MessageServiceClientMockAddResults{pp2, err}
	return mmAdd.mock
}

// Set uses given function f to mock the MessageServiceClient.Add method
func (mmAdd *mMessageServiceClientMockAdd) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.AddRequest]) (pp2 *connect_go.Response[v1.AddResponse], err error)) *MessageServiceClientMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the MessageServiceClient.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the MessageServiceClient.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// When sets expectation for the MessageServiceClient.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mMessageServiceClientMockAdd) When(ctx context.Context, pp1 *connect_go.Request[v1.AddRequest]) *MessageServiceClientMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("MessageServiceClientMock.Add mock is already set by Set")
	}

	expectation := &MessageServiceClientMockAddExpectation{
		mock:   mmAdd.mock,
		params: &MessageServiceClientMockAddParams{ctx, pp1},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up MessageServiceClient.Add return parameters for the expectation previously defined by the When method
func (e *MessageServiceClientMockAddExpectation) Then(pp2 *connect_go.Response[v1.AddResponse], err error) *MessageServiceClientMock {
	e.results = &MessageServiceClientMockAddResults{pp2, err}
	return e.mock
}

// Add implements MessageServiceClient
func (mmAdd *MessageServiceClientMock) Add(ctx context.Context, pp1 *connect_go.Request[v1.AddRequest]) (pp2 *connect_go.Response[v1.AddResponse], err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, pp1)
	}

	mm_params := &MessageServiceClientMockAddParams{ctx, pp1}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_got := MessageServiceClientMockAddParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("MessageServiceClientMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the MessageServiceClientMock.Add")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, pp1)
	}
	mmAdd.t.Fatalf("Unexpected call to MessageServiceClientMock.Add. %v %v", ctx, pp1)
	return
}

// AddAfterCounter returns a count of finished MessageServiceClientMock.Add invocations
func (mmAdd *MessageServiceClientMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of MessageServiceClientMock.Add invocations
func (mmAdd *MessageServiceClientMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to MessageServiceClientMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mMessageServiceClientMockAdd) Calls() []*MessageServiceClientMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*MessageServiceClientMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *MessageServiceClientMock) MinimockAddDone() bool {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddInspect logs each unmet expectation
func (m *MessageServiceClientMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageServiceClientMock.Add with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageServiceClientMock.Add")
		} else {
			m.t.Errorf("Expected call to MessageServiceClientMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		m.t.Error("Expected call to MessageServiceClientMock.Add")
	}
}

type mMessageServiceClientMockDelete struct {
	mock               *MessageServiceClientMock
	defaultExpectation *MessageServiceClientMockDeleteExpectation
	expectations       []*MessageServiceClientMockDeleteExpectation

	callArgs []*MessageServiceClientMockDeleteParams
	mutex    sync.RWMutex
}

// MessageServiceClientMockDeleteExpectation specifies expectation struct of the MessageServiceClient.Delete
type MessageServiceClientMockDeleteExpectation struct {
	mock    *MessageServiceClientMock
	params  *MessageServiceClientMockDeleteParams
	results *MessageServiceClientMockDeleteResults
	Counter uint64
}

// MessageServiceClientMockDeleteParams contains parameters of the MessageServiceClient.Delete
type MessageServiceClientMockDeleteParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.DeleteRequest]
}

// MessageServiceClientMockDeleteResults contains results of the MessageServiceClient.Delete
type MessageServiceClientMockDeleteResults struct {
	pp2 *connect_go.Response[v1.DeleteResponse]
	err error
}

// Expect sets up expected params for MessageServiceClient.Delete
func (mmDelete *mMessageServiceClientMockDelete) Expect(ctx context.Context, pp1 *connect_go.Request[v1.DeleteRequest]) *mMessageServiceClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessageServiceClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MessageServiceClientMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &MessageServiceClientMockDeleteParams{ctx, pp1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the MessageServiceClient.Delete
func (mmDelete *mMessageServiceClientMockDelete) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.DeleteRequest])) *mMessageServiceClientMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for MessageServiceClientMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by MessageServiceClient.Delete
func (mmDelete *mMessageServiceClientMockDelete) Return(pp2 *connect_go.Response[v1.DeleteResponse], err error) *MessageServiceClientMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessageServiceClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MessageServiceClientMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &MessageServiceClientMockDeleteResults{pp2, err}
	return mmDelete.mock
}

// Set uses given function f to mock the MessageServiceClient.Delete method
func (mmDelete *mMessageServiceClientMockDelete) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.DeleteRequest]) (pp2 *connect_go.Response[v1.DeleteResponse], err error)) *MessageServiceClientMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the MessageServiceClient.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the MessageServiceClient.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the MessageServiceClient.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mMessageServiceClientMockDelete) When(ctx context.Context, pp1 *connect_go.Request[v1.DeleteRequest]) *MessageServiceClientMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessageServiceClientMock.Delete mock is already set by Set")
	}

	expectation := &MessageServiceClientMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &MessageServiceClientMockDeleteParams{ctx, pp1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up MessageServiceClient.Delete return parameters for the expectation previously defined by the When method
func (e *MessageServiceClientMockDeleteExpectation) Then(pp2 *connect_go.Response[v1.DeleteResponse], err error) *MessageServiceClientMock {
	e.results = &MessageServiceClientMockDeleteResults{pp2, err}
	return e.mock
}

// Delete implements MessageServiceClient
func (mmDelete *MessageServiceClientMock) Delete(ctx context.Context, pp1 *connect_go.Request[v1.DeleteRequest]) (pp2 *connect_go.Response[v1.DeleteResponse], err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, pp1)
	}

	mm_params := &MessageServiceClientMockDeleteParams{ctx, pp1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := MessageServiceClientMockDeleteParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("MessageServiceClientMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the MessageServiceClientMock.Delete")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, pp1)
	}
	mmDelete.t.Fatalf("Unexpected call to MessageServiceClientMock.Delete. %v %v", ctx, pp1)
	return
}

// DeleteAfterCounter returns a count of finished MessageServiceClientMock.Delete invocations
func (mmDelete *MessageServiceClientMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of MessageServiceClientMock.Delete invocations
func (mmDelete *MessageServiceClientMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to MessageServiceClientMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mMessageServiceClientMockDelete) Calls() []*MessageServiceClientMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*MessageServiceClientMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *MessageServiceClientMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *MessageServiceClientMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageServiceClientMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageServiceClientMock.Delete")
		} else {
			m.t.Errorf("Expected call to MessageServiceClientMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to MessageServiceClientMock.Delete")
	}
}

type mMessageServiceClientMockList struct {
	mock               *MessageServiceClientMock
	defaultExpectation *MessageServiceClientMockListExpectation
	expectations       []*MessageServiceClientMockListExpectation

	callArgs []*MessageServiceClientMockListParams
	mutex    sync.RWMutex
}

// MessageServiceClientMockListExpectation specifies expectation struct of the MessageServiceClient.List
type MessageServiceClientMockListExpectation struct {
	mock    *MessageServiceClientMock
	params  *MessageServiceClientMockListParams
	results *MessageServiceClientMockListResults
	Counter uint64
}

// MessageServiceClientMockListParams contains parameters of the MessageServiceClient.List
type MessageServiceClientMockListParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.ListRequest]
}

// MessageServiceClientMockListResults contains results of the MessageServiceClient.List
type MessageServiceClientMockListResults struct {
	pp2 *connect_go.Response[v1.ListResponse]
	err error
}

// Expect sets up expected params for MessageServiceClient.List
func (mmList *mMessageServiceClientMockList) Expect(ctx context.Context, pp1 *connect_go.Request[v1.ListRequest]) *mMessageServiceClientMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("MessageServiceClientMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &MessageServiceClientMockListExpectation{}
	}

	mmList.defaultExpectation.params = &MessageServiceClientMockListParams{ctx, pp1}
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the MessageServiceClient.List
func (mmList *mMessageServiceClientMockList) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.ListRequest])) *mMessageServiceClientMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for MessageServiceClientMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by MessageServiceClient.List
func (mmList *mMessageServiceClientMockList) Return(pp2 *connect_go.Response[v1.ListResponse], err error) *MessageServiceClientMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("MessageServiceClientMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &MessageServiceClientMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &MessageServiceClientMockListResults{pp2, err}
	return mmList.mock
}

// Set uses given function f to mock the MessageServiceClient.List method
func (mmList *mMessageServiceClientMockList) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.ListRequest]) (pp2 *connect_go.Response[v1.ListResponse], err error)) *MessageServiceClientMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the MessageServiceClient.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the MessageServiceClient.List method")
	}

	mmList.mock.funcList = f
	return mmList.mock
}

// When sets expectation for the MessageServiceClient.List which will trigger the result defined by the following
// Then helper
func (mmList *mMessageServiceClientMockList) When(ctx context.Context, pp1 *connect_go.Request[v1.ListRequest]) *MessageServiceClientMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("MessageServiceClientMock.List mock is already set by Set")
	}

	expectation := &MessageServiceClientMockListExpectation{
		mock:   mmList.mock,
		params: &MessageServiceClientMockListParams{ctx, pp1},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up MessageServiceClient.List return parameters for the expectation previously defined by the When method
func (e *MessageServiceClientMockListExpectation) Then(pp2 *connect_go.Response[v1.ListResponse], err error) *MessageServiceClientMock {
	e.results = &MessageServiceClientMockListResults{pp2, err}
	return e.mock
}

// List implements MessageServiceClient
func (mmList *MessageServiceClientMock) List(ctx context.Context, pp1 *connect_go.Request[v1.ListRequest]) (pp2 *connect_go.Response[v1.ListResponse], err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx, pp1)
	}

	mm_params := &MessageServiceClientMockListParams{ctx, pp1}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_got := MessageServiceClientMockListParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("MessageServiceClientMock.List got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the MessageServiceClientMock.List")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx, pp1)
	}
	mmList.t.Fatalf("Unexpected call to MessageServiceClientMock.List. %v %v", ctx, pp1)
	return
}

// ListAfterCounter returns a count of finished MessageServiceClientMock.List invocations
func (mmList *MessageServiceClientMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of MessageServiceClientMock.List invocations
func (mmList *MessageServiceClientMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to MessageServiceClientMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mMessageServiceClientMockList) Calls() []*MessageServiceClientMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*MessageServiceClientMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *MessageServiceClientMock) MinimockListDone() bool {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		return false
	}
	return true
}

// MinimockListInspect logs each unmet expectation
func (m *MessageServiceClientMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageServiceClientMock.List with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageServiceClientMock.List")
		} else {
			m.t.Errorf("Expected call to MessageServiceClientMock.List with params: %#v", *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && mm_atomic.LoadUint64(&m.afterListCounter) < 1 {
		m.t.Error("Expected call to MessageServiceClientMock.List")
	}
}

type mMessageServiceClientMockRoomJoin struct {
	mock               *MessageServiceClientMock
	defaultExpectation *MessageServiceClientMockRoomJoinExpectation
	expectations       []*MessageServiceClientMockRoomJoinExpectation

	callArgs []*MessageServiceClientMockRoomJoinParams
	mutex    sync.RWMutex
}

// MessageServiceClientMockRoomJoinExpectation specifies expectation struct of the MessageServiceClient.RoomJoin
type MessageServiceClientMockRoomJoinExpectation struct {
	mock    *MessageServiceClientMock
	params  *MessageServiceClientMockRoomJoinParams
	results *MessageServiceClientMockRoomJoinResults
	Counter uint64
}

// MessageServiceClientMockRoomJoinParams contains parameters of the MessageServiceClient.RoomJoin
type MessageServiceClientMockRoomJoinParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.RoomJoinRequest]
}

// MessageServiceClientMockRoomJoinResults contains results of the MessageServiceClient.RoomJoin
type MessageServiceClientMockRoomJoinResults struct {
	pp2 *connect_go.Response[v1.RoomJoinResponse]
	err error
}

// Expect sets up expected params for MessageServiceClient.RoomJoin
func (mmRoomJoin *mMessageServiceClientMockRoomJoin) Expect(ctx context.Context, pp1 *connect_go.Request[v1.RoomJoinRequest]) *mMessageServiceClientMockRoomJoin {
	if mmRoomJoin.mock.funcRoomJoin != nil {
		mmRoomJoin.mock.t.Fatalf("MessageServiceClientMock.RoomJoin mock is already set by Set")
	}

	if mmRoomJoin.defaultExpectation == nil {
		mmRoomJoin.defaultExpectation = &MessageServiceClientMockRoomJoinExpectation{}
	}

	mmRoomJoin.defaultExpectation.params = &MessageServiceClientMockRoomJoinParams{ctx, pp1}
	for _, e := range mmRoomJoin.expectations {
		if minimock.Equal(e.params, mmRoomJoin.defaultExpectation.params) {
			mmRoomJoin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRoomJoin.defaultExpectation.params)
		}
	}

	return mmRoomJoin
}

// Inspect accepts an inspector function that has same arguments as the MessageServiceClient.RoomJoin
func (mmRoomJoin *mMessageServiceClientMockRoomJoin) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.RoomJoinRequest])) *mMessageServiceClientMockRoomJoin {
	if mmRoomJoin.mock.inspectFuncRoomJoin != nil {
		mmRoomJoin.mock.t.Fatalf("Inspect function is already set for MessageServiceClientMock.RoomJoin")
	}

	mmRoomJoin.mock.inspectFuncRoomJoin = f

	return mmRoomJoin
}

// Return sets up results that will be returned by MessageServiceClient.RoomJoin
func (mmRoomJoin *mMessageServiceClientMockRoomJoin) Return(pp2 *connect_go.Response[v1.RoomJoinResponse], err error) *MessageServiceClientMock {
	if mmRoomJoin.mock.funcRoomJoin != nil {
		mmRoomJoin.mock.t.Fatalf("MessageServiceClientMock.RoomJoin mock is already set by Set")
	}

	if mmRoomJoin.defaultExpectation == nil {
		mmRoomJoin.defaultExpectation = &MessageServiceClientMockRoomJoinExpectation{mock: mmRoomJoin.mock}
	}
	mmRoomJoin.defaultExpectation.results = &MessageServiceClientMockRoomJoinResults{pp2, err}
	return mmRoomJoin.mock
}

// Set uses given function f to mock the MessageServiceClient.RoomJoin method
func (mmRoomJoin *mMessageServiceClientMockRoomJoin) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.RoomJoinRequest]) (pp2 *connect_go.Response[v1.RoomJoinResponse], err error)) *MessageServiceClientMock {
	if mmRoomJoin.defaultExpectation != nil {
		mmRoomJoin.mock.t.Fatalf("Default expectation is already set for the MessageServiceClient.RoomJoin method")
	}

	if len(mmRoomJoin.expectations) > 0 {
		mmRoomJoin.mock.t.Fatalf("Some expectations are already set for the MessageServiceClient.RoomJoin method")
	}

	mmRoomJoin.mock.funcRoomJoin = f
	return mmRoomJoin.mock
}

// When sets expectation for the MessageServiceClient.RoomJoin which will trigger the result defined by the following
// Then helper
func (mmRoomJoin *mMessageServiceClientMockRoomJoin) When(ctx context.Context, pp1 *connect_go.Request[v1.RoomJoinRequest]) *MessageServiceClientMockRoomJoinExpectation {
	if mmRoomJoin.mock.funcRoomJoin != nil {
		mmRoomJoin.mock.t.Fatalf("MessageServiceClientMock.RoomJoin mock is already set by Set")
	}

	expectation := &MessageServiceClientMockRoomJoinExpectation{
		mock:   mmRoomJoin.mock,
		params: &MessageServiceClientMockRoomJoinParams{ctx, pp1},
	}
	mmRoomJoin.expectations = append(mmRoomJoin.expectations, expectation)
	return expectation
}

// Then sets up MessageServiceClient.RoomJoin return parameters for the expectation previously defined by the When method
func (e *MessageServiceClientMockRoomJoinExpectation) Then(pp2 *connect_go.Response[v1.RoomJoinResponse], err error) *MessageServiceClientMock {
	e.results = &MessageServiceClientMockRoomJoinResults{pp2, err}
	return e.mock
}

// RoomJoin implements MessageServiceClient
func (mmRoomJoin *MessageServiceClientMock) RoomJoin(ctx context.Context, pp1 *connect_go.Request[v1.RoomJoinRequest]) (pp2 *connect_go.Response[v1.RoomJoinResponse], err error) {
	mm_atomic.AddUint64(&mmRoomJoin.beforeRoomJoinCounter, 1)
	defer mm_atomic.AddUint64(&mmRoomJoin.afterRoomJoinCounter, 1)

	if mmRoomJoin.inspectFuncRoomJoin != nil {
		mmRoomJoin.inspectFuncRoomJoin(ctx, pp1)
	}

	mm_params := &MessageServiceClientMockRoomJoinParams{ctx, pp1}

	// Record call args
	mmRoomJoin.RoomJoinMock.mutex.Lock()
	mmRoomJoin.RoomJoinMock.callArgs = append(mmRoomJoin.RoomJoinMock.callArgs, mm_params)
	mmRoomJoin.RoomJoinMock.mutex.Unlock()

	for _, e := range mmRoomJoin.RoomJoinMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRoomJoin.RoomJoinMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRoomJoin.RoomJoinMock.defaultExpectation.Counter, 1)
		mm_want := mmRoomJoin.RoomJoinMock.defaultExpectation.params
		mm_got := MessageServiceClientMockRoomJoinParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRoomJoin.t.Errorf("MessageServiceClientMock.RoomJoin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRoomJoin.RoomJoinMock.defaultExpectation.results
		if mm_results == nil {
			mmRoomJoin.t.Fatal("No results are set for the MessageServiceClientMock.RoomJoin")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRoomJoin.funcRoomJoin != nil {
		return mmRoomJoin.funcRoomJoin(ctx, pp1)
	}
	mmRoomJoin.t.Fatalf("Unexpected call to MessageServiceClientMock.RoomJoin. %v %v", ctx, pp1)
	return
}

// RoomJoinAfterCounter returns a count of finished MessageServiceClientMock.RoomJoin invocations
func (mmRoomJoin *MessageServiceClientMock) RoomJoinAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRoomJoin.afterRoomJoinCounter)
}

// RoomJoinBeforeCounter returns a count of MessageServiceClientMock.RoomJoin invocations
func (mmRoomJoin *MessageServiceClientMock) RoomJoinBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRoomJoin.beforeRoomJoinCounter)
}

// Calls returns a list of arguments used in each call to MessageServiceClientMock.RoomJoin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRoomJoin *mMessageServiceClientMockRoomJoin) Calls() []*MessageServiceClientMockRoomJoinParams {
	mmRoomJoin.mutex.RLock()

	argCopy := make([]*MessageServiceClientMockRoomJoinParams, len(mmRoomJoin.callArgs))
	copy(argCopy, mmRoomJoin.callArgs)

	mmRoomJoin.mutex.RUnlock()

	return argCopy
}

// MinimockRoomJoinDone returns true if the count of the RoomJoin invocations corresponds
// the number of defined expectations
func (m *MessageServiceClientMock) MinimockRoomJoinDone() bool {
	for _, e := range m.RoomJoinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RoomJoinMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRoomJoinCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRoomJoin != nil && mm_atomic.LoadUint64(&m.afterRoomJoinCounter) < 1 {
		return false
	}
	return true
}

// MinimockRoomJoinInspect logs each unmet expectation
func (m *MessageServiceClientMock) MinimockRoomJoinInspect() {
	for _, e := range m.RoomJoinMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageServiceClientMock.RoomJoin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RoomJoinMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRoomJoinCounter) < 1 {
		if m.RoomJoinMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageServiceClientMock.RoomJoin")
		} else {
			m.t.Errorf("Expected call to MessageServiceClientMock.RoomJoin with params: %#v", *m.RoomJoinMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRoomJoin != nil && mm_atomic.LoadUint64(&m.afterRoomJoinCounter) < 1 {
		m.t.Error("Expected call to MessageServiceClientMock.RoomJoin")
	}
}

type mMessageServiceClientMockRoomList struct {
	mock               *MessageServiceClientMock
	defaultExpectation *MessageServiceClientMockRoomListExpectation
	expectations       []*MessageServiceClientMockRoomListExpectation

	callArgs []*MessageServiceClientMockRoomListParams
	mutex    sync.RWMutex
}

// MessageServiceClientMockRoomListExpectation specifies expectation struct of the MessageServiceClient.RoomList
type MessageServiceClientMockRoomListExpectation struct {
	mock    *MessageServiceClientMock
	params  *MessageServiceClientMockRoomListParams
	results *MessageServiceClientMockRoomListResults
	Counter uint64
}

// MessageServiceClientMockRoomListParams contains parameters of the MessageServiceClient.RoomList
type MessageServiceClientMockRoomListParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.RoomListRequest]
}

// MessageServiceClientMockRoomListResults contains results of the MessageServiceClient.RoomList
type MessageServiceClientMockRoomListResults struct {
	pp2 *connect_go.Response[v1.RoomListResponse]
	err error
}

// Expect sets up expected params for MessageServiceClient.RoomList
func (mmRoomList *mMessageServiceClientMockRoomList) Expect(ctx context.Context, pp1 *connect_go.Request[v1.RoomListRequest]) *mMessageServiceClientMockRoomList {
	if mmRoomList.mock.funcRoomList != nil {
		mmRoomList.mock.t.Fatalf("MessageServiceClientMock.RoomList mock is already set by Set")
	}

	if mmRoomList.defaultExpectation == nil {
		mmRoomList.defaultExpectation = &MessageServiceClientMockRoomListExpectation{}
	}

	mmRoomList.defaultExpectation.params = &MessageServiceClientMockRoomListParams{ctx, pp1}
	for _, e := range mmRoomList.expectations {
		if minimock.Equal(e.params, mmRoomList.defaultExpectation.params) {
			mmRoomList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRoomList.defaultExpectation.params)
		}
	}

	return mmRoomList
}

// Inspect accepts an inspector function that has same arguments as the MessageServiceClient.RoomList
func (mmRoomList *mMessageServiceClientMockRoomList) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.RoomListRequest])) *mMessageServiceClientMockRoomList {
	if mmRoomList.mock.inspectFuncRoomList != nil {
		mmRoomList.mock.t.Fatalf("Inspect function is already set for MessageServiceClientMock.RoomList")
	}

	mmRoomList.mock.inspectFuncRoomList = f

	return mmRoomList
}

// Return sets up results that will be returned by MessageServiceClient.RoomList
func (mmRoomList *mMessageServiceClientMockRoomList) Return(pp2 *connect_go.Response[v1.RoomListResponse], err error) *MessageServiceClientMock {
	if mmRoomList.mock.funcRoomList != nil {
		mmRoomList.mock.t.Fatalf("MessageServiceClientMock.RoomList mock is already set by Set")
	}

	if mmRoomList.defaultExpectation == nil {
		mmRoomList.defaultExpectation = &MessageServiceClientMockRoomListExpectation{mock: mmRoomList.mock}
	}
	mmRoomList.defaultExpectation.results = &MessageServiceClientMockRoomListResults{pp2, err}
	return mmRoomList.mock
}

// Set uses given function f to mock the MessageServiceClient.RoomList method
func (mmRoomList *mMessageServiceClientMockRoomList) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.RoomListRequest]) (pp2 *connect_go.Response[v1.RoomListResponse], err error)) *MessageServiceClientMock {
	if mmRoomList.defaultExpectation != nil {
		mmRoomList.mock.t.Fatalf("Default expectation is already set for the MessageServiceClient.RoomList method")
	}

	if len(mmRoomList.expectations) > 0 {
		mmRoomList.mock.t.Fatalf("Some expectations are already set for the MessageServiceClient.RoomList method")
	}

	mmRoomList.mock.funcRoomList = f
	return mmRoomList.mock
}

// When sets expectation for the MessageServiceClient.RoomList which will trigger the result defined by the following
// Then helper
func (mmRoomList *mMessageServiceClientMockRoomList) When(ctx context.Context, pp1 *connect_go.Request[v1.RoomListRequest]) *MessageServiceClientMockRoomListExpectation {
	if mmRoomList.mock.funcRoomList != nil {
		mmRoomList.mock.t.Fatalf("MessageServiceClientMock.RoomList mock is already set by Set")
	}

	expectation := &MessageServiceClientMockRoomListExpectation{
		mock:   mmRoomList.mock,
		params: &MessageServiceClientMockRoomListParams{ctx, pp1},
	}
	mmRoomList.expectations = append(mmRoomList.expectations, expectation)
	return expectation
}

// Then sets up MessageServiceClient.RoomList return parameters for the expectation previously defined by the When method
func (e *MessageServiceClientMockRoomListExpectation) Then(pp2 *connect_go.Response[v1.RoomListResponse], err error) *MessageServiceClientMock {
	e.results = &MessageServiceClientMockRoomListResults{pp2, err}
	return e.mock
}

// RoomList implements MessageServiceClient
func (mmRoomList *MessageServiceClientMock) RoomList(ctx context.Context, pp1 *connect_go.Request[v1.RoomListRequest]) (pp2 *connect_go.Response[v1.RoomListResponse], err error) {
	mm_atomic.AddUint64(&mmRoomList.beforeRoomListCounter, 1)
	defer mm_atomic.AddUint64(&mmRoomList.afterRoomListCounter, 1)

	if mmRoomList.inspectFuncRoomList != nil {
		mmRoomList.inspectFuncRoomList(ctx, pp1)
	}

	mm_params := &MessageServiceClientMockRoomListParams{ctx, pp1}

	// Record call args
	mmRoomList.RoomListMock.mutex.Lock()
	mmRoomList.RoomListMock.callArgs = append(mmRoomList.RoomListMock.callArgs, mm_params)
	mmRoomList.RoomListMock.mutex.Unlock()

	for _, e := range mmRoomList.RoomListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRoomList.RoomListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRoomList.RoomListMock.defaultExpectation.Counter, 1)
		mm_want := mmRoomList.RoomListMock.defaultExpectation.params
		mm_got := MessageServiceClientMockRoomListParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRoomList.t.Errorf("MessageServiceClientMock.RoomList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRoomList.RoomListMock.defaultExpectation.results
		if mm_results == nil {
			mmRoomList.t.Fatal("No results are set for the MessageServiceClientMock.RoomList")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRoomList.funcRoomList != nil {
		return mmRoomList.funcRoomList(ctx, pp1)
	}
	mmRoomList.t.Fatalf("Unexpected call to MessageServiceClientMock.RoomList. %v %v", ctx, pp1)
	return
}

// RoomListAfterCounter returns a count of finished MessageServiceClientMock.RoomList invocations
func (mmRoomList *MessageServiceClientMock) RoomListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRoomList.afterRoomListCounter)
}

// RoomListBeforeCounter returns a count of MessageServiceClientMock.RoomList invocations
func (mmRoomList *MessageServiceClientMock) RoomListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRoomList.beforeRoomListCounter)
}

// Calls returns a list of arguments used in each call to MessageServiceClientMock.RoomList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRoomList *mMessageServiceClientMockRoomList) Calls() []*MessageServiceClientMockRoomListParams {
	mmRoomList.mutex.RLock()

	argCopy := make([]*MessageServiceClientMockRoomListParams, len(mmRoomList.callArgs))
	copy(argCopy, mmRoomList.callArgs)

	mmRoomList.mutex.RUnlock()

	return argCopy
}

// MinimockRoomListDone returns true if the count of the RoomList invocations corresponds
// the number of defined expectations
func (m *MessageServiceClientMock) MinimockRoomListDone() bool {
	for _, e := range m.RoomListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RoomListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRoomListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRoomList != nil && mm_atomic.LoadUint64(&m.afterRoomListCounter) < 1 {
		return false
	}
	return true
}

// MinimockRoomListInspect logs each unmet expectation
func (m *MessageServiceClientMock) MinimockRoomListInspect() {
	for _, e := range m.RoomListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageServiceClientMock.RoomList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RoomListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRoomListCounter) < 1 {
		if m.RoomListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageServiceClientMock.RoomList")
		} else {
			m.t.Errorf("Expected call to MessageServiceClientMock.RoomList with params: %#v", *m.RoomListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRoomList != nil && mm_atomic.LoadUint64(&m.afterRoomListCounter) < 1 {
		m.t.Error("Expected call to MessageServiceClientMock.RoomList")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessageServiceClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddInspect()

		m.MinimockDeleteInspect()

		m.MinimockListInspect()

		m.MinimockRoomJoinInspect()

		m.MinimockRoomListInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessageServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MessageServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockListDone() &&
		m.MinimockRoomJoinDone() &&
		m.MinimockRoomListDone()
}
