package oauth_userv1connect

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/koblas/grpc-todo/gen/core/oauth_user/v1/oauth_userv1connect.OAuthUserServiceHandler -o ./o_auth_user_service_handler_mock.go -n OAuthUserServiceHandlerMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	connect_go "github.com/bufbuild/connect-go"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/koblas/grpc-todo/gen/core/oauth_user/v1"
)

// OAuthUserServiceHandlerMock implements OAuthUserServiceHandler
type OAuthUserServiceHandlerMock struct {
	t minimock.Tester

	funcGetAuthUrl          func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse], err error)
	inspectFuncGetAuthUrl   func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest])
	afterGetAuthUrlCounter  uint64
	beforeGetAuthUrlCounter uint64
	GetAuthUrlMock          mOAuthUserServiceHandlerMockGetAuthUrl

	funcListAssociations          func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse], err error)
	inspectFuncListAssociations   func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest])
	afterListAssociationsCounter  uint64
	beforeListAssociationsCounter uint64
	ListAssociationsMock          mOAuthUserServiceHandlerMockListAssociations

	funcRemoveAssociation          func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse], err error)
	inspectFuncRemoveAssociation   func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest])
	afterRemoveAssociationCounter  uint64
	beforeRemoveAssociationCounter uint64
	RemoveAssociationMock          mOAuthUserServiceHandlerMockRemoveAssociation

	funcUpsertUser          func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse], err error)
	inspectFuncUpsertUser   func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest])
	afterUpsertUserCounter  uint64
	beforeUpsertUserCounter uint64
	UpsertUserMock          mOAuthUserServiceHandlerMockUpsertUser
}

// NewOAuthUserServiceHandlerMock returns a mock for OAuthUserServiceHandler
func NewOAuthUserServiceHandlerMock(t minimock.Tester) *OAuthUserServiceHandlerMock {
	m := &OAuthUserServiceHandlerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAuthUrlMock = mOAuthUserServiceHandlerMockGetAuthUrl{mock: m}
	m.GetAuthUrlMock.callArgs = []*OAuthUserServiceHandlerMockGetAuthUrlParams{}

	m.ListAssociationsMock = mOAuthUserServiceHandlerMockListAssociations{mock: m}
	m.ListAssociationsMock.callArgs = []*OAuthUserServiceHandlerMockListAssociationsParams{}

	m.RemoveAssociationMock = mOAuthUserServiceHandlerMockRemoveAssociation{mock: m}
	m.RemoveAssociationMock.callArgs = []*OAuthUserServiceHandlerMockRemoveAssociationParams{}

	m.UpsertUserMock = mOAuthUserServiceHandlerMockUpsertUser{mock: m}
	m.UpsertUserMock.callArgs = []*OAuthUserServiceHandlerMockUpsertUserParams{}

	return m
}

type mOAuthUserServiceHandlerMockGetAuthUrl struct {
	mock               *OAuthUserServiceHandlerMock
	defaultExpectation *OAuthUserServiceHandlerMockGetAuthUrlExpectation
	expectations       []*OAuthUserServiceHandlerMockGetAuthUrlExpectation

	callArgs []*OAuthUserServiceHandlerMockGetAuthUrlParams
	mutex    sync.RWMutex
}

// OAuthUserServiceHandlerMockGetAuthUrlExpectation specifies expectation struct of the OAuthUserServiceHandler.GetAuthUrl
type OAuthUserServiceHandlerMockGetAuthUrlExpectation struct {
	mock    *OAuthUserServiceHandlerMock
	params  *OAuthUserServiceHandlerMockGetAuthUrlParams
	results *OAuthUserServiceHandlerMockGetAuthUrlResults
	Counter uint64
}

// OAuthUserServiceHandlerMockGetAuthUrlParams contains parameters of the OAuthUserServiceHandler.GetAuthUrl
type OAuthUserServiceHandlerMockGetAuthUrlParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]
}

// OAuthUserServiceHandlerMockGetAuthUrlResults contains results of the OAuthUserServiceHandler.GetAuthUrl
type OAuthUserServiceHandlerMockGetAuthUrlResults struct {
	pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse]
	err error
}

// Expect sets up expected params for OAuthUserServiceHandler.GetAuthUrl
func (mmGetAuthUrl *mOAuthUserServiceHandlerMockGetAuthUrl) Expect(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]) *mOAuthUserServiceHandlerMockGetAuthUrl {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("OAuthUserServiceHandlerMock.GetAuthUrl mock is already set by Set")
	}

	if mmGetAuthUrl.defaultExpectation == nil {
		mmGetAuthUrl.defaultExpectation = &OAuthUserServiceHandlerMockGetAuthUrlExpectation{}
	}

	mmGetAuthUrl.defaultExpectation.params = &OAuthUserServiceHandlerMockGetAuthUrlParams{ctx, pp1}
	for _, e := range mmGetAuthUrl.expectations {
		if minimock.Equal(e.params, mmGetAuthUrl.defaultExpectation.params) {
			mmGetAuthUrl.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAuthUrl.defaultExpectation.params)
		}
	}

	return mmGetAuthUrl
}

// Inspect accepts an inspector function that has same arguments as the OAuthUserServiceHandler.GetAuthUrl
func (mmGetAuthUrl *mOAuthUserServiceHandlerMockGetAuthUrl) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest])) *mOAuthUserServiceHandlerMockGetAuthUrl {
	if mmGetAuthUrl.mock.inspectFuncGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("Inspect function is already set for OAuthUserServiceHandlerMock.GetAuthUrl")
	}

	mmGetAuthUrl.mock.inspectFuncGetAuthUrl = f

	return mmGetAuthUrl
}

// Return sets up results that will be returned by OAuthUserServiceHandler.GetAuthUrl
func (mmGetAuthUrl *mOAuthUserServiceHandlerMockGetAuthUrl) Return(pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse], err error) *OAuthUserServiceHandlerMock {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("OAuthUserServiceHandlerMock.GetAuthUrl mock is already set by Set")
	}

	if mmGetAuthUrl.defaultExpectation == nil {
		mmGetAuthUrl.defaultExpectation = &OAuthUserServiceHandlerMockGetAuthUrlExpectation{mock: mmGetAuthUrl.mock}
	}
	mmGetAuthUrl.defaultExpectation.results = &OAuthUserServiceHandlerMockGetAuthUrlResults{pp2, err}
	return mmGetAuthUrl.mock
}

// Set uses given function f to mock the OAuthUserServiceHandler.GetAuthUrl method
func (mmGetAuthUrl *mOAuthUserServiceHandlerMockGetAuthUrl) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse], err error)) *OAuthUserServiceHandlerMock {
	if mmGetAuthUrl.defaultExpectation != nil {
		mmGetAuthUrl.mock.t.Fatalf("Default expectation is already set for the OAuthUserServiceHandler.GetAuthUrl method")
	}

	if len(mmGetAuthUrl.expectations) > 0 {
		mmGetAuthUrl.mock.t.Fatalf("Some expectations are already set for the OAuthUserServiceHandler.GetAuthUrl method")
	}

	mmGetAuthUrl.mock.funcGetAuthUrl = f
	return mmGetAuthUrl.mock
}

// When sets expectation for the OAuthUserServiceHandler.GetAuthUrl which will trigger the result defined by the following
// Then helper
func (mmGetAuthUrl *mOAuthUserServiceHandlerMockGetAuthUrl) When(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]) *OAuthUserServiceHandlerMockGetAuthUrlExpectation {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("OAuthUserServiceHandlerMock.GetAuthUrl mock is already set by Set")
	}

	expectation := &OAuthUserServiceHandlerMockGetAuthUrlExpectation{
		mock:   mmGetAuthUrl.mock,
		params: &OAuthUserServiceHandlerMockGetAuthUrlParams{ctx, pp1},
	}
	mmGetAuthUrl.expectations = append(mmGetAuthUrl.expectations, expectation)
	return expectation
}

// Then sets up OAuthUserServiceHandler.GetAuthUrl return parameters for the expectation previously defined by the When method
func (e *OAuthUserServiceHandlerMockGetAuthUrlExpectation) Then(pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse], err error) *OAuthUserServiceHandlerMock {
	e.results = &OAuthUserServiceHandlerMockGetAuthUrlResults{pp2, err}
	return e.mock
}

// GetAuthUrl implements OAuthUserServiceHandler
func (mmGetAuthUrl *OAuthUserServiceHandlerMock) GetAuthUrl(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse], err error) {
	mm_atomic.AddUint64(&mmGetAuthUrl.beforeGetAuthUrlCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAuthUrl.afterGetAuthUrlCounter, 1)

	if mmGetAuthUrl.inspectFuncGetAuthUrl != nil {
		mmGetAuthUrl.inspectFuncGetAuthUrl(ctx, pp1)
	}

	mm_params := &OAuthUserServiceHandlerMockGetAuthUrlParams{ctx, pp1}

	// Record call args
	mmGetAuthUrl.GetAuthUrlMock.mutex.Lock()
	mmGetAuthUrl.GetAuthUrlMock.callArgs = append(mmGetAuthUrl.GetAuthUrlMock.callArgs, mm_params)
	mmGetAuthUrl.GetAuthUrlMock.mutex.Unlock()

	for _, e := range mmGetAuthUrl.GetAuthUrlMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetAuthUrl.GetAuthUrlMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.params
		mm_got := OAuthUserServiceHandlerMockGetAuthUrlParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAuthUrl.t.Errorf("OAuthUserServiceHandlerMock.GetAuthUrl got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAuthUrl.t.Fatal("No results are set for the OAuthUserServiceHandlerMock.GetAuthUrl")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetAuthUrl.funcGetAuthUrl != nil {
		return mmGetAuthUrl.funcGetAuthUrl(ctx, pp1)
	}
	mmGetAuthUrl.t.Fatalf("Unexpected call to OAuthUserServiceHandlerMock.GetAuthUrl. %v %v", ctx, pp1)
	return
}

// GetAuthUrlAfterCounter returns a count of finished OAuthUserServiceHandlerMock.GetAuthUrl invocations
func (mmGetAuthUrl *OAuthUserServiceHandlerMock) GetAuthUrlAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthUrl.afterGetAuthUrlCounter)
}

// GetAuthUrlBeforeCounter returns a count of OAuthUserServiceHandlerMock.GetAuthUrl invocations
func (mmGetAuthUrl *OAuthUserServiceHandlerMock) GetAuthUrlBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthUrl.beforeGetAuthUrlCounter)
}

// Calls returns a list of arguments used in each call to OAuthUserServiceHandlerMock.GetAuthUrl.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAuthUrl *mOAuthUserServiceHandlerMockGetAuthUrl) Calls() []*OAuthUserServiceHandlerMockGetAuthUrlParams {
	mmGetAuthUrl.mutex.RLock()

	argCopy := make([]*OAuthUserServiceHandlerMockGetAuthUrlParams, len(mmGetAuthUrl.callArgs))
	copy(argCopy, mmGetAuthUrl.callArgs)

	mmGetAuthUrl.mutex.RUnlock()

	return argCopy
}

// MinimockGetAuthUrlDone returns true if the count of the GetAuthUrl invocations corresponds
// the number of defined expectations
func (m *OAuthUserServiceHandlerMock) MinimockGetAuthUrlDone() bool {
	for _, e := range m.GetAuthUrlMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthUrlMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthUrl != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAuthUrlInspect logs each unmet expectation
func (m *OAuthUserServiceHandlerMock) MinimockGetAuthUrlInspect() {
	for _, e := range m.GetAuthUrlMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OAuthUserServiceHandlerMock.GetAuthUrl with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthUrlMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		if m.GetAuthUrlMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OAuthUserServiceHandlerMock.GetAuthUrl")
		} else {
			m.t.Errorf("Expected call to OAuthUserServiceHandlerMock.GetAuthUrl with params: %#v", *m.GetAuthUrlMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthUrl != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		m.t.Error("Expected call to OAuthUserServiceHandlerMock.GetAuthUrl")
	}
}

type mOAuthUserServiceHandlerMockListAssociations struct {
	mock               *OAuthUserServiceHandlerMock
	defaultExpectation *OAuthUserServiceHandlerMockListAssociationsExpectation
	expectations       []*OAuthUserServiceHandlerMockListAssociationsExpectation

	callArgs []*OAuthUserServiceHandlerMockListAssociationsParams
	mutex    sync.RWMutex
}

// OAuthUserServiceHandlerMockListAssociationsExpectation specifies expectation struct of the OAuthUserServiceHandler.ListAssociations
type OAuthUserServiceHandlerMockListAssociationsExpectation struct {
	mock    *OAuthUserServiceHandlerMock
	params  *OAuthUserServiceHandlerMockListAssociationsParams
	results *OAuthUserServiceHandlerMockListAssociationsResults
	Counter uint64
}

// OAuthUserServiceHandlerMockListAssociationsParams contains parameters of the OAuthUserServiceHandler.ListAssociations
type OAuthUserServiceHandlerMockListAssociationsParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]
}

// OAuthUserServiceHandlerMockListAssociationsResults contains results of the OAuthUserServiceHandler.ListAssociations
type OAuthUserServiceHandlerMockListAssociationsResults struct {
	pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse]
	err error
}

// Expect sets up expected params for OAuthUserServiceHandler.ListAssociations
func (mmListAssociations *mOAuthUserServiceHandlerMockListAssociations) Expect(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]) *mOAuthUserServiceHandlerMockListAssociations {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("OAuthUserServiceHandlerMock.ListAssociations mock is already set by Set")
	}

	if mmListAssociations.defaultExpectation == nil {
		mmListAssociations.defaultExpectation = &OAuthUserServiceHandlerMockListAssociationsExpectation{}
	}

	mmListAssociations.defaultExpectation.params = &OAuthUserServiceHandlerMockListAssociationsParams{ctx, pp1}
	for _, e := range mmListAssociations.expectations {
		if minimock.Equal(e.params, mmListAssociations.defaultExpectation.params) {
			mmListAssociations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAssociations.defaultExpectation.params)
		}
	}

	return mmListAssociations
}

// Inspect accepts an inspector function that has same arguments as the OAuthUserServiceHandler.ListAssociations
func (mmListAssociations *mOAuthUserServiceHandlerMockListAssociations) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest])) *mOAuthUserServiceHandlerMockListAssociations {
	if mmListAssociations.mock.inspectFuncListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("Inspect function is already set for OAuthUserServiceHandlerMock.ListAssociations")
	}

	mmListAssociations.mock.inspectFuncListAssociations = f

	return mmListAssociations
}

// Return sets up results that will be returned by OAuthUserServiceHandler.ListAssociations
func (mmListAssociations *mOAuthUserServiceHandlerMockListAssociations) Return(pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse], err error) *OAuthUserServiceHandlerMock {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("OAuthUserServiceHandlerMock.ListAssociations mock is already set by Set")
	}

	if mmListAssociations.defaultExpectation == nil {
		mmListAssociations.defaultExpectation = &OAuthUserServiceHandlerMockListAssociationsExpectation{mock: mmListAssociations.mock}
	}
	mmListAssociations.defaultExpectation.results = &OAuthUserServiceHandlerMockListAssociationsResults{pp2, err}
	return mmListAssociations.mock
}

// Set uses given function f to mock the OAuthUserServiceHandler.ListAssociations method
func (mmListAssociations *mOAuthUserServiceHandlerMockListAssociations) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse], err error)) *OAuthUserServiceHandlerMock {
	if mmListAssociations.defaultExpectation != nil {
		mmListAssociations.mock.t.Fatalf("Default expectation is already set for the OAuthUserServiceHandler.ListAssociations method")
	}

	if len(mmListAssociations.expectations) > 0 {
		mmListAssociations.mock.t.Fatalf("Some expectations are already set for the OAuthUserServiceHandler.ListAssociations method")
	}

	mmListAssociations.mock.funcListAssociations = f
	return mmListAssociations.mock
}

// When sets expectation for the OAuthUserServiceHandler.ListAssociations which will trigger the result defined by the following
// Then helper
func (mmListAssociations *mOAuthUserServiceHandlerMockListAssociations) When(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]) *OAuthUserServiceHandlerMockListAssociationsExpectation {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("OAuthUserServiceHandlerMock.ListAssociations mock is already set by Set")
	}

	expectation := &OAuthUserServiceHandlerMockListAssociationsExpectation{
		mock:   mmListAssociations.mock,
		params: &OAuthUserServiceHandlerMockListAssociationsParams{ctx, pp1},
	}
	mmListAssociations.expectations = append(mmListAssociations.expectations, expectation)
	return expectation
}

// Then sets up OAuthUserServiceHandler.ListAssociations return parameters for the expectation previously defined by the When method
func (e *OAuthUserServiceHandlerMockListAssociationsExpectation) Then(pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse], err error) *OAuthUserServiceHandlerMock {
	e.results = &OAuthUserServiceHandlerMockListAssociationsResults{pp2, err}
	return e.mock
}

// ListAssociations implements OAuthUserServiceHandler
func (mmListAssociations *OAuthUserServiceHandlerMock) ListAssociations(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse], err error) {
	mm_atomic.AddUint64(&mmListAssociations.beforeListAssociationsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAssociations.afterListAssociationsCounter, 1)

	if mmListAssociations.inspectFuncListAssociations != nil {
		mmListAssociations.inspectFuncListAssociations(ctx, pp1)
	}

	mm_params := &OAuthUserServiceHandlerMockListAssociationsParams{ctx, pp1}

	// Record call args
	mmListAssociations.ListAssociationsMock.mutex.Lock()
	mmListAssociations.ListAssociationsMock.callArgs = append(mmListAssociations.ListAssociationsMock.callArgs, mm_params)
	mmListAssociations.ListAssociationsMock.mutex.Unlock()

	for _, e := range mmListAssociations.ListAssociationsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListAssociations.ListAssociationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAssociations.ListAssociationsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAssociations.ListAssociationsMock.defaultExpectation.params
		mm_got := OAuthUserServiceHandlerMockListAssociationsParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAssociations.t.Errorf("OAuthUserServiceHandlerMock.ListAssociations got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAssociations.ListAssociationsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAssociations.t.Fatal("No results are set for the OAuthUserServiceHandlerMock.ListAssociations")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListAssociations.funcListAssociations != nil {
		return mmListAssociations.funcListAssociations(ctx, pp1)
	}
	mmListAssociations.t.Fatalf("Unexpected call to OAuthUserServiceHandlerMock.ListAssociations. %v %v", ctx, pp1)
	return
}

// ListAssociationsAfterCounter returns a count of finished OAuthUserServiceHandlerMock.ListAssociations invocations
func (mmListAssociations *OAuthUserServiceHandlerMock) ListAssociationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAssociations.afterListAssociationsCounter)
}

// ListAssociationsBeforeCounter returns a count of OAuthUserServiceHandlerMock.ListAssociations invocations
func (mmListAssociations *OAuthUserServiceHandlerMock) ListAssociationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAssociations.beforeListAssociationsCounter)
}

// Calls returns a list of arguments used in each call to OAuthUserServiceHandlerMock.ListAssociations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAssociations *mOAuthUserServiceHandlerMockListAssociations) Calls() []*OAuthUserServiceHandlerMockListAssociationsParams {
	mmListAssociations.mutex.RLock()

	argCopy := make([]*OAuthUserServiceHandlerMockListAssociationsParams, len(mmListAssociations.callArgs))
	copy(argCopy, mmListAssociations.callArgs)

	mmListAssociations.mutex.RUnlock()

	return argCopy
}

// MinimockListAssociationsDone returns true if the count of the ListAssociations invocations corresponds
// the number of defined expectations
func (m *OAuthUserServiceHandlerMock) MinimockListAssociationsDone() bool {
	for _, e := range m.ListAssociationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListAssociationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAssociations != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListAssociationsInspect logs each unmet expectation
func (m *OAuthUserServiceHandlerMock) MinimockListAssociationsInspect() {
	for _, e := range m.ListAssociationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OAuthUserServiceHandlerMock.ListAssociations with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListAssociationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		if m.ListAssociationsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OAuthUserServiceHandlerMock.ListAssociations")
		} else {
			m.t.Errorf("Expected call to OAuthUserServiceHandlerMock.ListAssociations with params: %#v", *m.ListAssociationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAssociations != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		m.t.Error("Expected call to OAuthUserServiceHandlerMock.ListAssociations")
	}
}

type mOAuthUserServiceHandlerMockRemoveAssociation struct {
	mock               *OAuthUserServiceHandlerMock
	defaultExpectation *OAuthUserServiceHandlerMockRemoveAssociationExpectation
	expectations       []*OAuthUserServiceHandlerMockRemoveAssociationExpectation

	callArgs []*OAuthUserServiceHandlerMockRemoveAssociationParams
	mutex    sync.RWMutex
}

// OAuthUserServiceHandlerMockRemoveAssociationExpectation specifies expectation struct of the OAuthUserServiceHandler.RemoveAssociation
type OAuthUserServiceHandlerMockRemoveAssociationExpectation struct {
	mock    *OAuthUserServiceHandlerMock
	params  *OAuthUserServiceHandlerMockRemoveAssociationParams
	results *OAuthUserServiceHandlerMockRemoveAssociationResults
	Counter uint64
}

// OAuthUserServiceHandlerMockRemoveAssociationParams contains parameters of the OAuthUserServiceHandler.RemoveAssociation
type OAuthUserServiceHandlerMockRemoveAssociationParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]
}

// OAuthUserServiceHandlerMockRemoveAssociationResults contains results of the OAuthUserServiceHandler.RemoveAssociation
type OAuthUserServiceHandlerMockRemoveAssociationResults struct {
	pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse]
	err error
}

// Expect sets up expected params for OAuthUserServiceHandler.RemoveAssociation
func (mmRemoveAssociation *mOAuthUserServiceHandlerMockRemoveAssociation) Expect(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]) *mOAuthUserServiceHandlerMockRemoveAssociation {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("OAuthUserServiceHandlerMock.RemoveAssociation mock is already set by Set")
	}

	if mmRemoveAssociation.defaultExpectation == nil {
		mmRemoveAssociation.defaultExpectation = &OAuthUserServiceHandlerMockRemoveAssociationExpectation{}
	}

	mmRemoveAssociation.defaultExpectation.params = &OAuthUserServiceHandlerMockRemoveAssociationParams{ctx, pp1}
	for _, e := range mmRemoveAssociation.expectations {
		if minimock.Equal(e.params, mmRemoveAssociation.defaultExpectation.params) {
			mmRemoveAssociation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAssociation.defaultExpectation.params)
		}
	}

	return mmRemoveAssociation
}

// Inspect accepts an inspector function that has same arguments as the OAuthUserServiceHandler.RemoveAssociation
func (mmRemoveAssociation *mOAuthUserServiceHandlerMockRemoveAssociation) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest])) *mOAuthUserServiceHandlerMockRemoveAssociation {
	if mmRemoveAssociation.mock.inspectFuncRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("Inspect function is already set for OAuthUserServiceHandlerMock.RemoveAssociation")
	}

	mmRemoveAssociation.mock.inspectFuncRemoveAssociation = f

	return mmRemoveAssociation
}

// Return sets up results that will be returned by OAuthUserServiceHandler.RemoveAssociation
func (mmRemoveAssociation *mOAuthUserServiceHandlerMockRemoveAssociation) Return(pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse], err error) *OAuthUserServiceHandlerMock {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("OAuthUserServiceHandlerMock.RemoveAssociation mock is already set by Set")
	}

	if mmRemoveAssociation.defaultExpectation == nil {
		mmRemoveAssociation.defaultExpectation = &OAuthUserServiceHandlerMockRemoveAssociationExpectation{mock: mmRemoveAssociation.mock}
	}
	mmRemoveAssociation.defaultExpectation.results = &OAuthUserServiceHandlerMockRemoveAssociationResults{pp2, err}
	return mmRemoveAssociation.mock
}

// Set uses given function f to mock the OAuthUserServiceHandler.RemoveAssociation method
func (mmRemoveAssociation *mOAuthUserServiceHandlerMockRemoveAssociation) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse], err error)) *OAuthUserServiceHandlerMock {
	if mmRemoveAssociation.defaultExpectation != nil {
		mmRemoveAssociation.mock.t.Fatalf("Default expectation is already set for the OAuthUserServiceHandler.RemoveAssociation method")
	}

	if len(mmRemoveAssociation.expectations) > 0 {
		mmRemoveAssociation.mock.t.Fatalf("Some expectations are already set for the OAuthUserServiceHandler.RemoveAssociation method")
	}

	mmRemoveAssociation.mock.funcRemoveAssociation = f
	return mmRemoveAssociation.mock
}

// When sets expectation for the OAuthUserServiceHandler.RemoveAssociation which will trigger the result defined by the following
// Then helper
func (mmRemoveAssociation *mOAuthUserServiceHandlerMockRemoveAssociation) When(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]) *OAuthUserServiceHandlerMockRemoveAssociationExpectation {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("OAuthUserServiceHandlerMock.RemoveAssociation mock is already set by Set")
	}

	expectation := &OAuthUserServiceHandlerMockRemoveAssociationExpectation{
		mock:   mmRemoveAssociation.mock,
		params: &OAuthUserServiceHandlerMockRemoveAssociationParams{ctx, pp1},
	}
	mmRemoveAssociation.expectations = append(mmRemoveAssociation.expectations, expectation)
	return expectation
}

// Then sets up OAuthUserServiceHandler.RemoveAssociation return parameters for the expectation previously defined by the When method
func (e *OAuthUserServiceHandlerMockRemoveAssociationExpectation) Then(pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse], err error) *OAuthUserServiceHandlerMock {
	e.results = &OAuthUserServiceHandlerMockRemoveAssociationResults{pp2, err}
	return e.mock
}

// RemoveAssociation implements OAuthUserServiceHandler
func (mmRemoveAssociation *OAuthUserServiceHandlerMock) RemoveAssociation(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveAssociation.beforeRemoveAssociationCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAssociation.afterRemoveAssociationCounter, 1)

	if mmRemoveAssociation.inspectFuncRemoveAssociation != nil {
		mmRemoveAssociation.inspectFuncRemoveAssociation(ctx, pp1)
	}

	mm_params := &OAuthUserServiceHandlerMockRemoveAssociationParams{ctx, pp1}

	// Record call args
	mmRemoveAssociation.RemoveAssociationMock.mutex.Lock()
	mmRemoveAssociation.RemoveAssociationMock.callArgs = append(mmRemoveAssociation.RemoveAssociationMock.callArgs, mm_params)
	mmRemoveAssociation.RemoveAssociationMock.mutex.Unlock()

	for _, e := range mmRemoveAssociation.RemoveAssociationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveAssociation.RemoveAssociationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.params
		mm_got := OAuthUserServiceHandlerMockRemoveAssociationParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveAssociation.t.Errorf("OAuthUserServiceHandlerMock.RemoveAssociation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAssociation.t.Fatal("No results are set for the OAuthUserServiceHandlerMock.RemoveAssociation")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveAssociation.funcRemoveAssociation != nil {
		return mmRemoveAssociation.funcRemoveAssociation(ctx, pp1)
	}
	mmRemoveAssociation.t.Fatalf("Unexpected call to OAuthUserServiceHandlerMock.RemoveAssociation. %v %v", ctx, pp1)
	return
}

// RemoveAssociationAfterCounter returns a count of finished OAuthUserServiceHandlerMock.RemoveAssociation invocations
func (mmRemoveAssociation *OAuthUserServiceHandlerMock) RemoveAssociationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAssociation.afterRemoveAssociationCounter)
}

// RemoveAssociationBeforeCounter returns a count of OAuthUserServiceHandlerMock.RemoveAssociation invocations
func (mmRemoveAssociation *OAuthUserServiceHandlerMock) RemoveAssociationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAssociation.beforeRemoveAssociationCounter)
}

// Calls returns a list of arguments used in each call to OAuthUserServiceHandlerMock.RemoveAssociation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAssociation *mOAuthUserServiceHandlerMockRemoveAssociation) Calls() []*OAuthUserServiceHandlerMockRemoveAssociationParams {
	mmRemoveAssociation.mutex.RLock()

	argCopy := make([]*OAuthUserServiceHandlerMockRemoveAssociationParams, len(mmRemoveAssociation.callArgs))
	copy(argCopy, mmRemoveAssociation.callArgs)

	mmRemoveAssociation.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAssociationDone returns true if the count of the RemoveAssociation invocations corresponds
// the number of defined expectations
func (m *OAuthUserServiceHandlerMock) MinimockRemoveAssociationDone() bool {
	for _, e := range m.RemoveAssociationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAssociationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAssociation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveAssociationInspect logs each unmet expectation
func (m *OAuthUserServiceHandlerMock) MinimockRemoveAssociationInspect() {
	for _, e := range m.RemoveAssociationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OAuthUserServiceHandlerMock.RemoveAssociation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAssociationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		if m.RemoveAssociationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OAuthUserServiceHandlerMock.RemoveAssociation")
		} else {
			m.t.Errorf("Expected call to OAuthUserServiceHandlerMock.RemoveAssociation with params: %#v", *m.RemoveAssociationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAssociation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		m.t.Error("Expected call to OAuthUserServiceHandlerMock.RemoveAssociation")
	}
}

type mOAuthUserServiceHandlerMockUpsertUser struct {
	mock               *OAuthUserServiceHandlerMock
	defaultExpectation *OAuthUserServiceHandlerMockUpsertUserExpectation
	expectations       []*OAuthUserServiceHandlerMockUpsertUserExpectation

	callArgs []*OAuthUserServiceHandlerMockUpsertUserParams
	mutex    sync.RWMutex
}

// OAuthUserServiceHandlerMockUpsertUserExpectation specifies expectation struct of the OAuthUserServiceHandler.UpsertUser
type OAuthUserServiceHandlerMockUpsertUserExpectation struct {
	mock    *OAuthUserServiceHandlerMock
	params  *OAuthUserServiceHandlerMockUpsertUserParams
	results *OAuthUserServiceHandlerMockUpsertUserResults
	Counter uint64
}

// OAuthUserServiceHandlerMockUpsertUserParams contains parameters of the OAuthUserServiceHandler.UpsertUser
type OAuthUserServiceHandlerMockUpsertUserParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]
}

// OAuthUserServiceHandlerMockUpsertUserResults contains results of the OAuthUserServiceHandler.UpsertUser
type OAuthUserServiceHandlerMockUpsertUserResults struct {
	pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse]
	err error
}

// Expect sets up expected params for OAuthUserServiceHandler.UpsertUser
func (mmUpsertUser *mOAuthUserServiceHandlerMockUpsertUser) Expect(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]) *mOAuthUserServiceHandlerMockUpsertUser {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("OAuthUserServiceHandlerMock.UpsertUser mock is already set by Set")
	}

	if mmUpsertUser.defaultExpectation == nil {
		mmUpsertUser.defaultExpectation = &OAuthUserServiceHandlerMockUpsertUserExpectation{}
	}

	mmUpsertUser.defaultExpectation.params = &OAuthUserServiceHandlerMockUpsertUserParams{ctx, pp1}
	for _, e := range mmUpsertUser.expectations {
		if minimock.Equal(e.params, mmUpsertUser.defaultExpectation.params) {
			mmUpsertUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertUser.defaultExpectation.params)
		}
	}

	return mmUpsertUser
}

// Inspect accepts an inspector function that has same arguments as the OAuthUserServiceHandler.UpsertUser
func (mmUpsertUser *mOAuthUserServiceHandlerMockUpsertUser) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest])) *mOAuthUserServiceHandlerMockUpsertUser {
	if mmUpsertUser.mock.inspectFuncUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("Inspect function is already set for OAuthUserServiceHandlerMock.UpsertUser")
	}

	mmUpsertUser.mock.inspectFuncUpsertUser = f

	return mmUpsertUser
}

// Return sets up results that will be returned by OAuthUserServiceHandler.UpsertUser
func (mmUpsertUser *mOAuthUserServiceHandlerMockUpsertUser) Return(pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse], err error) *OAuthUserServiceHandlerMock {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("OAuthUserServiceHandlerMock.UpsertUser mock is already set by Set")
	}

	if mmUpsertUser.defaultExpectation == nil {
		mmUpsertUser.defaultExpectation = &OAuthUserServiceHandlerMockUpsertUserExpectation{mock: mmUpsertUser.mock}
	}
	mmUpsertUser.defaultExpectation.results = &OAuthUserServiceHandlerMockUpsertUserResults{pp2, err}
	return mmUpsertUser.mock
}

// Set uses given function f to mock the OAuthUserServiceHandler.UpsertUser method
func (mmUpsertUser *mOAuthUserServiceHandlerMockUpsertUser) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse], err error)) *OAuthUserServiceHandlerMock {
	if mmUpsertUser.defaultExpectation != nil {
		mmUpsertUser.mock.t.Fatalf("Default expectation is already set for the OAuthUserServiceHandler.UpsertUser method")
	}

	if len(mmUpsertUser.expectations) > 0 {
		mmUpsertUser.mock.t.Fatalf("Some expectations are already set for the OAuthUserServiceHandler.UpsertUser method")
	}

	mmUpsertUser.mock.funcUpsertUser = f
	return mmUpsertUser.mock
}

// When sets expectation for the OAuthUserServiceHandler.UpsertUser which will trigger the result defined by the following
// Then helper
func (mmUpsertUser *mOAuthUserServiceHandlerMockUpsertUser) When(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]) *OAuthUserServiceHandlerMockUpsertUserExpectation {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("OAuthUserServiceHandlerMock.UpsertUser mock is already set by Set")
	}

	expectation := &OAuthUserServiceHandlerMockUpsertUserExpectation{
		mock:   mmUpsertUser.mock,
		params: &OAuthUserServiceHandlerMockUpsertUserParams{ctx, pp1},
	}
	mmUpsertUser.expectations = append(mmUpsertUser.expectations, expectation)
	return expectation
}

// Then sets up OAuthUserServiceHandler.UpsertUser return parameters for the expectation previously defined by the When method
func (e *OAuthUserServiceHandlerMockUpsertUserExpectation) Then(pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse], err error) *OAuthUserServiceHandlerMock {
	e.results = &OAuthUserServiceHandlerMockUpsertUserResults{pp2, err}
	return e.mock
}

// UpsertUser implements OAuthUserServiceHandler
func (mmUpsertUser *OAuthUserServiceHandlerMock) UpsertUser(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse], err error) {
	mm_atomic.AddUint64(&mmUpsertUser.beforeUpsertUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertUser.afterUpsertUserCounter, 1)

	if mmUpsertUser.inspectFuncUpsertUser != nil {
		mmUpsertUser.inspectFuncUpsertUser(ctx, pp1)
	}

	mm_params := &OAuthUserServiceHandlerMockUpsertUserParams{ctx, pp1}

	// Record call args
	mmUpsertUser.UpsertUserMock.mutex.Lock()
	mmUpsertUser.UpsertUserMock.callArgs = append(mmUpsertUser.UpsertUserMock.callArgs, mm_params)
	mmUpsertUser.UpsertUserMock.mutex.Unlock()

	for _, e := range mmUpsertUser.UpsertUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpsertUser.UpsertUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertUser.UpsertUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertUser.UpsertUserMock.defaultExpectation.params
		mm_got := OAuthUserServiceHandlerMockUpsertUserParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertUser.t.Errorf("OAuthUserServiceHandlerMock.UpsertUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertUser.UpsertUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertUser.t.Fatal("No results are set for the OAuthUserServiceHandlerMock.UpsertUser")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpsertUser.funcUpsertUser != nil {
		return mmUpsertUser.funcUpsertUser(ctx, pp1)
	}
	mmUpsertUser.t.Fatalf("Unexpected call to OAuthUserServiceHandlerMock.UpsertUser. %v %v", ctx, pp1)
	return
}

// UpsertUserAfterCounter returns a count of finished OAuthUserServiceHandlerMock.UpsertUser invocations
func (mmUpsertUser *OAuthUserServiceHandlerMock) UpsertUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertUser.afterUpsertUserCounter)
}

// UpsertUserBeforeCounter returns a count of OAuthUserServiceHandlerMock.UpsertUser invocations
func (mmUpsertUser *OAuthUserServiceHandlerMock) UpsertUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertUser.beforeUpsertUserCounter)
}

// Calls returns a list of arguments used in each call to OAuthUserServiceHandlerMock.UpsertUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertUser *mOAuthUserServiceHandlerMockUpsertUser) Calls() []*OAuthUserServiceHandlerMockUpsertUserParams {
	mmUpsertUser.mutex.RLock()

	argCopy := make([]*OAuthUserServiceHandlerMockUpsertUserParams, len(mmUpsertUser.callArgs))
	copy(argCopy, mmUpsertUser.callArgs)

	mmUpsertUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertUserDone returns true if the count of the UpsertUser invocations corresponds
// the number of defined expectations
func (m *OAuthUserServiceHandlerMock) MinimockUpsertUserDone() bool {
	for _, e := range m.UpsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertUser != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertUserInspect logs each unmet expectation
func (m *OAuthUserServiceHandlerMock) MinimockUpsertUserInspect() {
	for _, e := range m.UpsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OAuthUserServiceHandlerMock.UpsertUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		if m.UpsertUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OAuthUserServiceHandlerMock.UpsertUser")
		} else {
			m.t.Errorf("Expected call to OAuthUserServiceHandlerMock.UpsertUser with params: %#v", *m.UpsertUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertUser != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		m.t.Error("Expected call to OAuthUserServiceHandlerMock.UpsertUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OAuthUserServiceHandlerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetAuthUrlInspect()

		m.MinimockListAssociationsInspect()

		m.MinimockRemoveAssociationInspect()

		m.MinimockUpsertUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OAuthUserServiceHandlerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OAuthUserServiceHandlerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAuthUrlDone() &&
		m.MinimockListAssociationsDone() &&
		m.MinimockRemoveAssociationDone() &&
		m.MinimockUpsertUserDone()
}
