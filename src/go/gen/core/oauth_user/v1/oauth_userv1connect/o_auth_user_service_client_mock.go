package oauth_userv1connect

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/koblas/grpc-todo/gen/core/oauth_user/v1/oauth_userv1connect.OAuthUserServiceClient -o ./o_auth_user_service_client_mock.go -n OAuthUserServiceClientMock

import (
	context "context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	connect_go "github.com/bufbuild/connect-go"
	"github.com/gojuno/minimock/v3"
	v1 "github.com/koblas/grpc-todo/gen/core/oauth_user/v1"
)

// OAuthUserServiceClientMock implements OAuthUserServiceClient
type OAuthUserServiceClientMock struct {
	t minimock.Tester

	funcGetAuthUrl          func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse], err error)
	inspectFuncGetAuthUrl   func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest])
	afterGetAuthUrlCounter  uint64
	beforeGetAuthUrlCounter uint64
	GetAuthUrlMock          mOAuthUserServiceClientMockGetAuthUrl

	funcListAssociations          func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse], err error)
	inspectFuncListAssociations   func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest])
	afterListAssociationsCounter  uint64
	beforeListAssociationsCounter uint64
	ListAssociationsMock          mOAuthUserServiceClientMockListAssociations

	funcRemoveAssociation          func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse], err error)
	inspectFuncRemoveAssociation   func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest])
	afterRemoveAssociationCounter  uint64
	beforeRemoveAssociationCounter uint64
	RemoveAssociationMock          mOAuthUserServiceClientMockRemoveAssociation

	funcUpsertUser          func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse], err error)
	inspectFuncUpsertUser   func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest])
	afterUpsertUserCounter  uint64
	beforeUpsertUserCounter uint64
	UpsertUserMock          mOAuthUserServiceClientMockUpsertUser
}

// NewOAuthUserServiceClientMock returns a mock for OAuthUserServiceClient
func NewOAuthUserServiceClientMock(t minimock.Tester) *OAuthUserServiceClientMock {
	m := &OAuthUserServiceClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAuthUrlMock = mOAuthUserServiceClientMockGetAuthUrl{mock: m}
	m.GetAuthUrlMock.callArgs = []*OAuthUserServiceClientMockGetAuthUrlParams{}

	m.ListAssociationsMock = mOAuthUserServiceClientMockListAssociations{mock: m}
	m.ListAssociationsMock.callArgs = []*OAuthUserServiceClientMockListAssociationsParams{}

	m.RemoveAssociationMock = mOAuthUserServiceClientMockRemoveAssociation{mock: m}
	m.RemoveAssociationMock.callArgs = []*OAuthUserServiceClientMockRemoveAssociationParams{}

	m.UpsertUserMock = mOAuthUserServiceClientMockUpsertUser{mock: m}
	m.UpsertUserMock.callArgs = []*OAuthUserServiceClientMockUpsertUserParams{}

	return m
}

type mOAuthUserServiceClientMockGetAuthUrl struct {
	mock               *OAuthUserServiceClientMock
	defaultExpectation *OAuthUserServiceClientMockGetAuthUrlExpectation
	expectations       []*OAuthUserServiceClientMockGetAuthUrlExpectation

	callArgs []*OAuthUserServiceClientMockGetAuthUrlParams
	mutex    sync.RWMutex
}

// OAuthUserServiceClientMockGetAuthUrlExpectation specifies expectation struct of the OAuthUserServiceClient.GetAuthUrl
type OAuthUserServiceClientMockGetAuthUrlExpectation struct {
	mock    *OAuthUserServiceClientMock
	params  *OAuthUserServiceClientMockGetAuthUrlParams
	results *OAuthUserServiceClientMockGetAuthUrlResults
	Counter uint64
}

// OAuthUserServiceClientMockGetAuthUrlParams contains parameters of the OAuthUserServiceClient.GetAuthUrl
type OAuthUserServiceClientMockGetAuthUrlParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]
}

// OAuthUserServiceClientMockGetAuthUrlResults contains results of the OAuthUserServiceClient.GetAuthUrl
type OAuthUserServiceClientMockGetAuthUrlResults struct {
	pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse]
	err error
}

// Expect sets up expected params for OAuthUserServiceClient.GetAuthUrl
func (mmGetAuthUrl *mOAuthUserServiceClientMockGetAuthUrl) Expect(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]) *mOAuthUserServiceClientMockGetAuthUrl {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("OAuthUserServiceClientMock.GetAuthUrl mock is already set by Set")
	}

	if mmGetAuthUrl.defaultExpectation == nil {
		mmGetAuthUrl.defaultExpectation = &OAuthUserServiceClientMockGetAuthUrlExpectation{}
	}

	mmGetAuthUrl.defaultExpectation.params = &OAuthUserServiceClientMockGetAuthUrlParams{ctx, pp1}
	for _, e := range mmGetAuthUrl.expectations {
		if minimock.Equal(e.params, mmGetAuthUrl.defaultExpectation.params) {
			mmGetAuthUrl.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAuthUrl.defaultExpectation.params)
		}
	}

	return mmGetAuthUrl
}

// Inspect accepts an inspector function that has same arguments as the OAuthUserServiceClient.GetAuthUrl
func (mmGetAuthUrl *mOAuthUserServiceClientMockGetAuthUrl) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest])) *mOAuthUserServiceClientMockGetAuthUrl {
	if mmGetAuthUrl.mock.inspectFuncGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("Inspect function is already set for OAuthUserServiceClientMock.GetAuthUrl")
	}

	mmGetAuthUrl.mock.inspectFuncGetAuthUrl = f

	return mmGetAuthUrl
}

// Return sets up results that will be returned by OAuthUserServiceClient.GetAuthUrl
func (mmGetAuthUrl *mOAuthUserServiceClientMockGetAuthUrl) Return(pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse], err error) *OAuthUserServiceClientMock {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("OAuthUserServiceClientMock.GetAuthUrl mock is already set by Set")
	}

	if mmGetAuthUrl.defaultExpectation == nil {
		mmGetAuthUrl.defaultExpectation = &OAuthUserServiceClientMockGetAuthUrlExpectation{mock: mmGetAuthUrl.mock}
	}
	mmGetAuthUrl.defaultExpectation.results = &OAuthUserServiceClientMockGetAuthUrlResults{pp2, err}
	return mmGetAuthUrl.mock
}

// Set uses given function f to mock the OAuthUserServiceClient.GetAuthUrl method
func (mmGetAuthUrl *mOAuthUserServiceClientMockGetAuthUrl) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse], err error)) *OAuthUserServiceClientMock {
	if mmGetAuthUrl.defaultExpectation != nil {
		mmGetAuthUrl.mock.t.Fatalf("Default expectation is already set for the OAuthUserServiceClient.GetAuthUrl method")
	}

	if len(mmGetAuthUrl.expectations) > 0 {
		mmGetAuthUrl.mock.t.Fatalf("Some expectations are already set for the OAuthUserServiceClient.GetAuthUrl method")
	}

	mmGetAuthUrl.mock.funcGetAuthUrl = f
	return mmGetAuthUrl.mock
}

// When sets expectation for the OAuthUserServiceClient.GetAuthUrl which will trigger the result defined by the following
// Then helper
func (mmGetAuthUrl *mOAuthUserServiceClientMockGetAuthUrl) When(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]) *OAuthUserServiceClientMockGetAuthUrlExpectation {
	if mmGetAuthUrl.mock.funcGetAuthUrl != nil {
		mmGetAuthUrl.mock.t.Fatalf("OAuthUserServiceClientMock.GetAuthUrl mock is already set by Set")
	}

	expectation := &OAuthUserServiceClientMockGetAuthUrlExpectation{
		mock:   mmGetAuthUrl.mock,
		params: &OAuthUserServiceClientMockGetAuthUrlParams{ctx, pp1},
	}
	mmGetAuthUrl.expectations = append(mmGetAuthUrl.expectations, expectation)
	return expectation
}

// Then sets up OAuthUserServiceClient.GetAuthUrl return parameters for the expectation previously defined by the When method
func (e *OAuthUserServiceClientMockGetAuthUrlExpectation) Then(pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse], err error) *OAuthUserServiceClientMock {
	e.results = &OAuthUserServiceClientMockGetAuthUrlResults{pp2, err}
	return e.mock
}

// GetAuthUrl implements OAuthUserServiceClient
func (mmGetAuthUrl *OAuthUserServiceClientMock) GetAuthUrl(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceGetAuthUrlRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceGetAuthUrlResponse], err error) {
	mm_atomic.AddUint64(&mmGetAuthUrl.beforeGetAuthUrlCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAuthUrl.afterGetAuthUrlCounter, 1)

	if mmGetAuthUrl.inspectFuncGetAuthUrl != nil {
		mmGetAuthUrl.inspectFuncGetAuthUrl(ctx, pp1)
	}

	mm_params := &OAuthUserServiceClientMockGetAuthUrlParams{ctx, pp1}

	// Record call args
	mmGetAuthUrl.GetAuthUrlMock.mutex.Lock()
	mmGetAuthUrl.GetAuthUrlMock.callArgs = append(mmGetAuthUrl.GetAuthUrlMock.callArgs, mm_params)
	mmGetAuthUrl.GetAuthUrlMock.mutex.Unlock()

	for _, e := range mmGetAuthUrl.GetAuthUrlMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmGetAuthUrl.GetAuthUrlMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.params
		mm_got := OAuthUserServiceClientMockGetAuthUrlParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAuthUrl.t.Errorf("OAuthUserServiceClientMock.GetAuthUrl got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAuthUrl.GetAuthUrlMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAuthUrl.t.Fatal("No results are set for the OAuthUserServiceClientMock.GetAuthUrl")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmGetAuthUrl.funcGetAuthUrl != nil {
		return mmGetAuthUrl.funcGetAuthUrl(ctx, pp1)
	}
	mmGetAuthUrl.t.Fatalf("Unexpected call to OAuthUserServiceClientMock.GetAuthUrl. %v %v", ctx, pp1)
	return
}

// GetAuthUrlAfterCounter returns a count of finished OAuthUserServiceClientMock.GetAuthUrl invocations
func (mmGetAuthUrl *OAuthUserServiceClientMock) GetAuthUrlAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthUrl.afterGetAuthUrlCounter)
}

// GetAuthUrlBeforeCounter returns a count of OAuthUserServiceClientMock.GetAuthUrl invocations
func (mmGetAuthUrl *OAuthUserServiceClientMock) GetAuthUrlBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthUrl.beforeGetAuthUrlCounter)
}

// Calls returns a list of arguments used in each call to OAuthUserServiceClientMock.GetAuthUrl.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAuthUrl *mOAuthUserServiceClientMockGetAuthUrl) Calls() []*OAuthUserServiceClientMockGetAuthUrlParams {
	mmGetAuthUrl.mutex.RLock()

	argCopy := make([]*OAuthUserServiceClientMockGetAuthUrlParams, len(mmGetAuthUrl.callArgs))
	copy(argCopy, mmGetAuthUrl.callArgs)

	mmGetAuthUrl.mutex.RUnlock()

	return argCopy
}

// MinimockGetAuthUrlDone returns true if the count of the GetAuthUrl invocations corresponds
// the number of defined expectations
func (m *OAuthUserServiceClientMock) MinimockGetAuthUrlDone() bool {
	for _, e := range m.GetAuthUrlMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthUrlMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthUrl != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAuthUrlInspect logs each unmet expectation
func (m *OAuthUserServiceClientMock) MinimockGetAuthUrlInspect() {
	for _, e := range m.GetAuthUrlMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OAuthUserServiceClientMock.GetAuthUrl with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthUrlMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		if m.GetAuthUrlMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OAuthUserServiceClientMock.GetAuthUrl")
		} else {
			m.t.Errorf("Expected call to OAuthUserServiceClientMock.GetAuthUrl with params: %#v", *m.GetAuthUrlMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthUrl != nil && mm_atomic.LoadUint64(&m.afterGetAuthUrlCounter) < 1 {
		m.t.Error("Expected call to OAuthUserServiceClientMock.GetAuthUrl")
	}
}

type mOAuthUserServiceClientMockListAssociations struct {
	mock               *OAuthUserServiceClientMock
	defaultExpectation *OAuthUserServiceClientMockListAssociationsExpectation
	expectations       []*OAuthUserServiceClientMockListAssociationsExpectation

	callArgs []*OAuthUserServiceClientMockListAssociationsParams
	mutex    sync.RWMutex
}

// OAuthUserServiceClientMockListAssociationsExpectation specifies expectation struct of the OAuthUserServiceClient.ListAssociations
type OAuthUserServiceClientMockListAssociationsExpectation struct {
	mock    *OAuthUserServiceClientMock
	params  *OAuthUserServiceClientMockListAssociationsParams
	results *OAuthUserServiceClientMockListAssociationsResults
	Counter uint64
}

// OAuthUserServiceClientMockListAssociationsParams contains parameters of the OAuthUserServiceClient.ListAssociations
type OAuthUserServiceClientMockListAssociationsParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]
}

// OAuthUserServiceClientMockListAssociationsResults contains results of the OAuthUserServiceClient.ListAssociations
type OAuthUserServiceClientMockListAssociationsResults struct {
	pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse]
	err error
}

// Expect sets up expected params for OAuthUserServiceClient.ListAssociations
func (mmListAssociations *mOAuthUserServiceClientMockListAssociations) Expect(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]) *mOAuthUserServiceClientMockListAssociations {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("OAuthUserServiceClientMock.ListAssociations mock is already set by Set")
	}

	if mmListAssociations.defaultExpectation == nil {
		mmListAssociations.defaultExpectation = &OAuthUserServiceClientMockListAssociationsExpectation{}
	}

	mmListAssociations.defaultExpectation.params = &OAuthUserServiceClientMockListAssociationsParams{ctx, pp1}
	for _, e := range mmListAssociations.expectations {
		if minimock.Equal(e.params, mmListAssociations.defaultExpectation.params) {
			mmListAssociations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListAssociations.defaultExpectation.params)
		}
	}

	return mmListAssociations
}

// Inspect accepts an inspector function that has same arguments as the OAuthUserServiceClient.ListAssociations
func (mmListAssociations *mOAuthUserServiceClientMockListAssociations) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest])) *mOAuthUserServiceClientMockListAssociations {
	if mmListAssociations.mock.inspectFuncListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("Inspect function is already set for OAuthUserServiceClientMock.ListAssociations")
	}

	mmListAssociations.mock.inspectFuncListAssociations = f

	return mmListAssociations
}

// Return sets up results that will be returned by OAuthUserServiceClient.ListAssociations
func (mmListAssociations *mOAuthUserServiceClientMockListAssociations) Return(pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse], err error) *OAuthUserServiceClientMock {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("OAuthUserServiceClientMock.ListAssociations mock is already set by Set")
	}

	if mmListAssociations.defaultExpectation == nil {
		mmListAssociations.defaultExpectation = &OAuthUserServiceClientMockListAssociationsExpectation{mock: mmListAssociations.mock}
	}
	mmListAssociations.defaultExpectation.results = &OAuthUserServiceClientMockListAssociationsResults{pp2, err}
	return mmListAssociations.mock
}

// Set uses given function f to mock the OAuthUserServiceClient.ListAssociations method
func (mmListAssociations *mOAuthUserServiceClientMockListAssociations) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse], err error)) *OAuthUserServiceClientMock {
	if mmListAssociations.defaultExpectation != nil {
		mmListAssociations.mock.t.Fatalf("Default expectation is already set for the OAuthUserServiceClient.ListAssociations method")
	}

	if len(mmListAssociations.expectations) > 0 {
		mmListAssociations.mock.t.Fatalf("Some expectations are already set for the OAuthUserServiceClient.ListAssociations method")
	}

	mmListAssociations.mock.funcListAssociations = f
	return mmListAssociations.mock
}

// When sets expectation for the OAuthUserServiceClient.ListAssociations which will trigger the result defined by the following
// Then helper
func (mmListAssociations *mOAuthUserServiceClientMockListAssociations) When(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]) *OAuthUserServiceClientMockListAssociationsExpectation {
	if mmListAssociations.mock.funcListAssociations != nil {
		mmListAssociations.mock.t.Fatalf("OAuthUserServiceClientMock.ListAssociations mock is already set by Set")
	}

	expectation := &OAuthUserServiceClientMockListAssociationsExpectation{
		mock:   mmListAssociations.mock,
		params: &OAuthUserServiceClientMockListAssociationsParams{ctx, pp1},
	}
	mmListAssociations.expectations = append(mmListAssociations.expectations, expectation)
	return expectation
}

// Then sets up OAuthUserServiceClient.ListAssociations return parameters for the expectation previously defined by the When method
func (e *OAuthUserServiceClientMockListAssociationsExpectation) Then(pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse], err error) *OAuthUserServiceClientMock {
	e.results = &OAuthUserServiceClientMockListAssociationsResults{pp2, err}
	return e.mock
}

// ListAssociations implements OAuthUserServiceClient
func (mmListAssociations *OAuthUserServiceClientMock) ListAssociations(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceListAssociationsRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceListAssociationsResponse], err error) {
	mm_atomic.AddUint64(&mmListAssociations.beforeListAssociationsCounter, 1)
	defer mm_atomic.AddUint64(&mmListAssociations.afterListAssociationsCounter, 1)

	if mmListAssociations.inspectFuncListAssociations != nil {
		mmListAssociations.inspectFuncListAssociations(ctx, pp1)
	}

	mm_params := &OAuthUserServiceClientMockListAssociationsParams{ctx, pp1}

	// Record call args
	mmListAssociations.ListAssociationsMock.mutex.Lock()
	mmListAssociations.ListAssociationsMock.callArgs = append(mmListAssociations.ListAssociationsMock.callArgs, mm_params)
	mmListAssociations.ListAssociationsMock.mutex.Unlock()

	for _, e := range mmListAssociations.ListAssociationsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmListAssociations.ListAssociationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListAssociations.ListAssociationsMock.defaultExpectation.Counter, 1)
		mm_want := mmListAssociations.ListAssociationsMock.defaultExpectation.params
		mm_got := OAuthUserServiceClientMockListAssociationsParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListAssociations.t.Errorf("OAuthUserServiceClientMock.ListAssociations got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListAssociations.ListAssociationsMock.defaultExpectation.results
		if mm_results == nil {
			mmListAssociations.t.Fatal("No results are set for the OAuthUserServiceClientMock.ListAssociations")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmListAssociations.funcListAssociations != nil {
		return mmListAssociations.funcListAssociations(ctx, pp1)
	}
	mmListAssociations.t.Fatalf("Unexpected call to OAuthUserServiceClientMock.ListAssociations. %v %v", ctx, pp1)
	return
}

// ListAssociationsAfterCounter returns a count of finished OAuthUserServiceClientMock.ListAssociations invocations
func (mmListAssociations *OAuthUserServiceClientMock) ListAssociationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAssociations.afterListAssociationsCounter)
}

// ListAssociationsBeforeCounter returns a count of OAuthUserServiceClientMock.ListAssociations invocations
func (mmListAssociations *OAuthUserServiceClientMock) ListAssociationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListAssociations.beforeListAssociationsCounter)
}

// Calls returns a list of arguments used in each call to OAuthUserServiceClientMock.ListAssociations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListAssociations *mOAuthUserServiceClientMockListAssociations) Calls() []*OAuthUserServiceClientMockListAssociationsParams {
	mmListAssociations.mutex.RLock()

	argCopy := make([]*OAuthUserServiceClientMockListAssociationsParams, len(mmListAssociations.callArgs))
	copy(argCopy, mmListAssociations.callArgs)

	mmListAssociations.mutex.RUnlock()

	return argCopy
}

// MinimockListAssociationsDone returns true if the count of the ListAssociations invocations corresponds
// the number of defined expectations
func (m *OAuthUserServiceClientMock) MinimockListAssociationsDone() bool {
	for _, e := range m.ListAssociationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListAssociationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAssociations != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListAssociationsInspect logs each unmet expectation
func (m *OAuthUserServiceClientMock) MinimockListAssociationsInspect() {
	for _, e := range m.ListAssociationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OAuthUserServiceClientMock.ListAssociations with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListAssociationsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		if m.ListAssociationsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OAuthUserServiceClientMock.ListAssociations")
		} else {
			m.t.Errorf("Expected call to OAuthUserServiceClientMock.ListAssociations with params: %#v", *m.ListAssociationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListAssociations != nil && mm_atomic.LoadUint64(&m.afterListAssociationsCounter) < 1 {
		m.t.Error("Expected call to OAuthUserServiceClientMock.ListAssociations")
	}
}

type mOAuthUserServiceClientMockRemoveAssociation struct {
	mock               *OAuthUserServiceClientMock
	defaultExpectation *OAuthUserServiceClientMockRemoveAssociationExpectation
	expectations       []*OAuthUserServiceClientMockRemoveAssociationExpectation

	callArgs []*OAuthUserServiceClientMockRemoveAssociationParams
	mutex    sync.RWMutex
}

// OAuthUserServiceClientMockRemoveAssociationExpectation specifies expectation struct of the OAuthUserServiceClient.RemoveAssociation
type OAuthUserServiceClientMockRemoveAssociationExpectation struct {
	mock    *OAuthUserServiceClientMock
	params  *OAuthUserServiceClientMockRemoveAssociationParams
	results *OAuthUserServiceClientMockRemoveAssociationResults
	Counter uint64
}

// OAuthUserServiceClientMockRemoveAssociationParams contains parameters of the OAuthUserServiceClient.RemoveAssociation
type OAuthUserServiceClientMockRemoveAssociationParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]
}

// OAuthUserServiceClientMockRemoveAssociationResults contains results of the OAuthUserServiceClient.RemoveAssociation
type OAuthUserServiceClientMockRemoveAssociationResults struct {
	pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse]
	err error
}

// Expect sets up expected params for OAuthUserServiceClient.RemoveAssociation
func (mmRemoveAssociation *mOAuthUserServiceClientMockRemoveAssociation) Expect(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]) *mOAuthUserServiceClientMockRemoveAssociation {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("OAuthUserServiceClientMock.RemoveAssociation mock is already set by Set")
	}

	if mmRemoveAssociation.defaultExpectation == nil {
		mmRemoveAssociation.defaultExpectation = &OAuthUserServiceClientMockRemoveAssociationExpectation{}
	}

	mmRemoveAssociation.defaultExpectation.params = &OAuthUserServiceClientMockRemoveAssociationParams{ctx, pp1}
	for _, e := range mmRemoveAssociation.expectations {
		if minimock.Equal(e.params, mmRemoveAssociation.defaultExpectation.params) {
			mmRemoveAssociation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAssociation.defaultExpectation.params)
		}
	}

	return mmRemoveAssociation
}

// Inspect accepts an inspector function that has same arguments as the OAuthUserServiceClient.RemoveAssociation
func (mmRemoveAssociation *mOAuthUserServiceClientMockRemoveAssociation) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest])) *mOAuthUserServiceClientMockRemoveAssociation {
	if mmRemoveAssociation.mock.inspectFuncRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("Inspect function is already set for OAuthUserServiceClientMock.RemoveAssociation")
	}

	mmRemoveAssociation.mock.inspectFuncRemoveAssociation = f

	return mmRemoveAssociation
}

// Return sets up results that will be returned by OAuthUserServiceClient.RemoveAssociation
func (mmRemoveAssociation *mOAuthUserServiceClientMockRemoveAssociation) Return(pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse], err error) *OAuthUserServiceClientMock {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("OAuthUserServiceClientMock.RemoveAssociation mock is already set by Set")
	}

	if mmRemoveAssociation.defaultExpectation == nil {
		mmRemoveAssociation.defaultExpectation = &OAuthUserServiceClientMockRemoveAssociationExpectation{mock: mmRemoveAssociation.mock}
	}
	mmRemoveAssociation.defaultExpectation.results = &OAuthUserServiceClientMockRemoveAssociationResults{pp2, err}
	return mmRemoveAssociation.mock
}

// Set uses given function f to mock the OAuthUserServiceClient.RemoveAssociation method
func (mmRemoveAssociation *mOAuthUserServiceClientMockRemoveAssociation) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse], err error)) *OAuthUserServiceClientMock {
	if mmRemoveAssociation.defaultExpectation != nil {
		mmRemoveAssociation.mock.t.Fatalf("Default expectation is already set for the OAuthUserServiceClient.RemoveAssociation method")
	}

	if len(mmRemoveAssociation.expectations) > 0 {
		mmRemoveAssociation.mock.t.Fatalf("Some expectations are already set for the OAuthUserServiceClient.RemoveAssociation method")
	}

	mmRemoveAssociation.mock.funcRemoveAssociation = f
	return mmRemoveAssociation.mock
}

// When sets expectation for the OAuthUserServiceClient.RemoveAssociation which will trigger the result defined by the following
// Then helper
func (mmRemoveAssociation *mOAuthUserServiceClientMockRemoveAssociation) When(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]) *OAuthUserServiceClientMockRemoveAssociationExpectation {
	if mmRemoveAssociation.mock.funcRemoveAssociation != nil {
		mmRemoveAssociation.mock.t.Fatalf("OAuthUserServiceClientMock.RemoveAssociation mock is already set by Set")
	}

	expectation := &OAuthUserServiceClientMockRemoveAssociationExpectation{
		mock:   mmRemoveAssociation.mock,
		params: &OAuthUserServiceClientMockRemoveAssociationParams{ctx, pp1},
	}
	mmRemoveAssociation.expectations = append(mmRemoveAssociation.expectations, expectation)
	return expectation
}

// Then sets up OAuthUserServiceClient.RemoveAssociation return parameters for the expectation previously defined by the When method
func (e *OAuthUserServiceClientMockRemoveAssociationExpectation) Then(pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse], err error) *OAuthUserServiceClientMock {
	e.results = &OAuthUserServiceClientMockRemoveAssociationResults{pp2, err}
	return e.mock
}

// RemoveAssociation implements OAuthUserServiceClient
func (mmRemoveAssociation *OAuthUserServiceClientMock) RemoveAssociation(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceRemoveAssociationRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceRemoveAssociationResponse], err error) {
	mm_atomic.AddUint64(&mmRemoveAssociation.beforeRemoveAssociationCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAssociation.afterRemoveAssociationCounter, 1)

	if mmRemoveAssociation.inspectFuncRemoveAssociation != nil {
		mmRemoveAssociation.inspectFuncRemoveAssociation(ctx, pp1)
	}

	mm_params := &OAuthUserServiceClientMockRemoveAssociationParams{ctx, pp1}

	// Record call args
	mmRemoveAssociation.RemoveAssociationMock.mutex.Lock()
	mmRemoveAssociation.RemoveAssociationMock.callArgs = append(mmRemoveAssociation.RemoveAssociationMock.callArgs, mm_params)
	mmRemoveAssociation.RemoveAssociationMock.mutex.Unlock()

	for _, e := range mmRemoveAssociation.RemoveAssociationMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmRemoveAssociation.RemoveAssociationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.params
		mm_got := OAuthUserServiceClientMockRemoveAssociationParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveAssociation.t.Errorf("OAuthUserServiceClientMock.RemoveAssociation got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveAssociation.RemoveAssociationMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveAssociation.t.Fatal("No results are set for the OAuthUserServiceClientMock.RemoveAssociation")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmRemoveAssociation.funcRemoveAssociation != nil {
		return mmRemoveAssociation.funcRemoveAssociation(ctx, pp1)
	}
	mmRemoveAssociation.t.Fatalf("Unexpected call to OAuthUserServiceClientMock.RemoveAssociation. %v %v", ctx, pp1)
	return
}

// RemoveAssociationAfterCounter returns a count of finished OAuthUserServiceClientMock.RemoveAssociation invocations
func (mmRemoveAssociation *OAuthUserServiceClientMock) RemoveAssociationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAssociation.afterRemoveAssociationCounter)
}

// RemoveAssociationBeforeCounter returns a count of OAuthUserServiceClientMock.RemoveAssociation invocations
func (mmRemoveAssociation *OAuthUserServiceClientMock) RemoveAssociationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAssociation.beforeRemoveAssociationCounter)
}

// Calls returns a list of arguments used in each call to OAuthUserServiceClientMock.RemoveAssociation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAssociation *mOAuthUserServiceClientMockRemoveAssociation) Calls() []*OAuthUserServiceClientMockRemoveAssociationParams {
	mmRemoveAssociation.mutex.RLock()

	argCopy := make([]*OAuthUserServiceClientMockRemoveAssociationParams, len(mmRemoveAssociation.callArgs))
	copy(argCopy, mmRemoveAssociation.callArgs)

	mmRemoveAssociation.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAssociationDone returns true if the count of the RemoveAssociation invocations corresponds
// the number of defined expectations
func (m *OAuthUserServiceClientMock) MinimockRemoveAssociationDone() bool {
	for _, e := range m.RemoveAssociationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAssociationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAssociation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveAssociationInspect logs each unmet expectation
func (m *OAuthUserServiceClientMock) MinimockRemoveAssociationInspect() {
	for _, e := range m.RemoveAssociationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OAuthUserServiceClientMock.RemoveAssociation with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAssociationMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		if m.RemoveAssociationMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OAuthUserServiceClientMock.RemoveAssociation")
		} else {
			m.t.Errorf("Expected call to OAuthUserServiceClientMock.RemoveAssociation with params: %#v", *m.RemoveAssociationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAssociation != nil && mm_atomic.LoadUint64(&m.afterRemoveAssociationCounter) < 1 {
		m.t.Error("Expected call to OAuthUserServiceClientMock.RemoveAssociation")
	}
}

type mOAuthUserServiceClientMockUpsertUser struct {
	mock               *OAuthUserServiceClientMock
	defaultExpectation *OAuthUserServiceClientMockUpsertUserExpectation
	expectations       []*OAuthUserServiceClientMockUpsertUserExpectation

	callArgs []*OAuthUserServiceClientMockUpsertUserParams
	mutex    sync.RWMutex
}

// OAuthUserServiceClientMockUpsertUserExpectation specifies expectation struct of the OAuthUserServiceClient.UpsertUser
type OAuthUserServiceClientMockUpsertUserExpectation struct {
	mock    *OAuthUserServiceClientMock
	params  *OAuthUserServiceClientMockUpsertUserParams
	results *OAuthUserServiceClientMockUpsertUserResults
	Counter uint64
}

// OAuthUserServiceClientMockUpsertUserParams contains parameters of the OAuthUserServiceClient.UpsertUser
type OAuthUserServiceClientMockUpsertUserParams struct {
	ctx context.Context
	pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]
}

// OAuthUserServiceClientMockUpsertUserResults contains results of the OAuthUserServiceClient.UpsertUser
type OAuthUserServiceClientMockUpsertUserResults struct {
	pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse]
	err error
}

// Expect sets up expected params for OAuthUserServiceClient.UpsertUser
func (mmUpsertUser *mOAuthUserServiceClientMockUpsertUser) Expect(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]) *mOAuthUserServiceClientMockUpsertUser {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("OAuthUserServiceClientMock.UpsertUser mock is already set by Set")
	}

	if mmUpsertUser.defaultExpectation == nil {
		mmUpsertUser.defaultExpectation = &OAuthUserServiceClientMockUpsertUserExpectation{}
	}

	mmUpsertUser.defaultExpectation.params = &OAuthUserServiceClientMockUpsertUserParams{ctx, pp1}
	for _, e := range mmUpsertUser.expectations {
		if minimock.Equal(e.params, mmUpsertUser.defaultExpectation.params) {
			mmUpsertUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertUser.defaultExpectation.params)
		}
	}

	return mmUpsertUser
}

// Inspect accepts an inspector function that has same arguments as the OAuthUserServiceClient.UpsertUser
func (mmUpsertUser *mOAuthUserServiceClientMockUpsertUser) Inspect(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest])) *mOAuthUserServiceClientMockUpsertUser {
	if mmUpsertUser.mock.inspectFuncUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("Inspect function is already set for OAuthUserServiceClientMock.UpsertUser")
	}

	mmUpsertUser.mock.inspectFuncUpsertUser = f

	return mmUpsertUser
}

// Return sets up results that will be returned by OAuthUserServiceClient.UpsertUser
func (mmUpsertUser *mOAuthUserServiceClientMockUpsertUser) Return(pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse], err error) *OAuthUserServiceClientMock {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("OAuthUserServiceClientMock.UpsertUser mock is already set by Set")
	}

	if mmUpsertUser.defaultExpectation == nil {
		mmUpsertUser.defaultExpectation = &OAuthUserServiceClientMockUpsertUserExpectation{mock: mmUpsertUser.mock}
	}
	mmUpsertUser.defaultExpectation.results = &OAuthUserServiceClientMockUpsertUserResults{pp2, err}
	return mmUpsertUser.mock
}

// Set uses given function f to mock the OAuthUserServiceClient.UpsertUser method
func (mmUpsertUser *mOAuthUserServiceClientMockUpsertUser) Set(f func(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse], err error)) *OAuthUserServiceClientMock {
	if mmUpsertUser.defaultExpectation != nil {
		mmUpsertUser.mock.t.Fatalf("Default expectation is already set for the OAuthUserServiceClient.UpsertUser method")
	}

	if len(mmUpsertUser.expectations) > 0 {
		mmUpsertUser.mock.t.Fatalf("Some expectations are already set for the OAuthUserServiceClient.UpsertUser method")
	}

	mmUpsertUser.mock.funcUpsertUser = f
	return mmUpsertUser.mock
}

// When sets expectation for the OAuthUserServiceClient.UpsertUser which will trigger the result defined by the following
// Then helper
func (mmUpsertUser *mOAuthUserServiceClientMockUpsertUser) When(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]) *OAuthUserServiceClientMockUpsertUserExpectation {
	if mmUpsertUser.mock.funcUpsertUser != nil {
		mmUpsertUser.mock.t.Fatalf("OAuthUserServiceClientMock.UpsertUser mock is already set by Set")
	}

	expectation := &OAuthUserServiceClientMockUpsertUserExpectation{
		mock:   mmUpsertUser.mock,
		params: &OAuthUserServiceClientMockUpsertUserParams{ctx, pp1},
	}
	mmUpsertUser.expectations = append(mmUpsertUser.expectations, expectation)
	return expectation
}

// Then sets up OAuthUserServiceClient.UpsertUser return parameters for the expectation previously defined by the When method
func (e *OAuthUserServiceClientMockUpsertUserExpectation) Then(pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse], err error) *OAuthUserServiceClientMock {
	e.results = &OAuthUserServiceClientMockUpsertUserResults{pp2, err}
	return e.mock
}

// UpsertUser implements OAuthUserServiceClient
func (mmUpsertUser *OAuthUserServiceClientMock) UpsertUser(ctx context.Context, pp1 *connect_go.Request[v1.OAuthUserServiceUpsertUserRequest]) (pp2 *connect_go.Response[v1.OAuthUserServiceUpsertUserResponse], err error) {
	mm_atomic.AddUint64(&mmUpsertUser.beforeUpsertUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertUser.afterUpsertUserCounter, 1)

	if mmUpsertUser.inspectFuncUpsertUser != nil {
		mmUpsertUser.inspectFuncUpsertUser(ctx, pp1)
	}

	mm_params := &OAuthUserServiceClientMockUpsertUserParams{ctx, pp1}

	// Record call args
	mmUpsertUser.UpsertUserMock.mutex.Lock()
	mmUpsertUser.UpsertUserMock.callArgs = append(mmUpsertUser.UpsertUserMock.callArgs, mm_params)
	mmUpsertUser.UpsertUserMock.mutex.Unlock()

	for _, e := range mmUpsertUser.UpsertUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp2, e.results.err
		}
	}

	if mmUpsertUser.UpsertUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertUser.UpsertUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertUser.UpsertUserMock.defaultExpectation.params
		mm_got := OAuthUserServiceClientMockUpsertUserParams{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertUser.t.Errorf("OAuthUserServiceClientMock.UpsertUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertUser.UpsertUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertUser.t.Fatal("No results are set for the OAuthUserServiceClientMock.UpsertUser")
		}
		return (*mm_results).pp2, (*mm_results).err
	}
	if mmUpsertUser.funcUpsertUser != nil {
		return mmUpsertUser.funcUpsertUser(ctx, pp1)
	}
	mmUpsertUser.t.Fatalf("Unexpected call to OAuthUserServiceClientMock.UpsertUser. %v %v", ctx, pp1)
	return
}

// UpsertUserAfterCounter returns a count of finished OAuthUserServiceClientMock.UpsertUser invocations
func (mmUpsertUser *OAuthUserServiceClientMock) UpsertUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertUser.afterUpsertUserCounter)
}

// UpsertUserBeforeCounter returns a count of OAuthUserServiceClientMock.UpsertUser invocations
func (mmUpsertUser *OAuthUserServiceClientMock) UpsertUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertUser.beforeUpsertUserCounter)
}

// Calls returns a list of arguments used in each call to OAuthUserServiceClientMock.UpsertUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertUser *mOAuthUserServiceClientMockUpsertUser) Calls() []*OAuthUserServiceClientMockUpsertUserParams {
	mmUpsertUser.mutex.RLock()

	argCopy := make([]*OAuthUserServiceClientMockUpsertUserParams, len(mmUpsertUser.callArgs))
	copy(argCopy, mmUpsertUser.callArgs)

	mmUpsertUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertUserDone returns true if the count of the UpsertUser invocations corresponds
// the number of defined expectations
func (m *OAuthUserServiceClientMock) MinimockUpsertUserDone() bool {
	for _, e := range m.UpsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertUser != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpsertUserInspect logs each unmet expectation
func (m *OAuthUserServiceClientMock) MinimockUpsertUserInspect() {
	for _, e := range m.UpsertUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OAuthUserServiceClientMock.UpsertUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		if m.UpsertUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OAuthUserServiceClientMock.UpsertUser")
		} else {
			m.t.Errorf("Expected call to OAuthUserServiceClientMock.UpsertUser with params: %#v", *m.UpsertUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertUser != nil && mm_atomic.LoadUint64(&m.afterUpsertUserCounter) < 1 {
		m.t.Error("Expected call to OAuthUserServiceClientMock.UpsertUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OAuthUserServiceClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetAuthUrlInspect()

		m.MinimockListAssociationsInspect()

		m.MinimockRemoveAssociationInspect()

		m.MinimockUpsertUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OAuthUserServiceClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OAuthUserServiceClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAuthUrlDone() &&
		m.MinimockListAssociationsDone() &&
		m.MinimockRemoveAssociationDone() &&
		m.MinimockUpsertUserDone()
}
