// Code generated by protoc-gen-twirp v8.1.1, DO NOT EDIT.
// source: corepb/v1/eventbus.proto

package corepbv1

import context "context"
import fmt "fmt"
import http "net/http"
import ioutil "io/ioutil"
import json "encoding/json"
import strconv "strconv"
import strings "strings"

import protojson "google.golang.org/protobuf/encoding/protojson"
import proto "google.golang.org/protobuf/proto"
import twirp "github.com/twitchtv/twirp"
import ctxsetters "github.com/twitchtv/twirp/ctxsetters"

// Version compatibility assertion.
// If the constant is not defined in the package, that likely means
// the package needs to be updated to work with this generated code.
// See https://twitchtv.github.io/twirp/docs/version_matrix.html
const _ = twirp.TwirpPackageMinVersion_8_1_0

// ==================================
// BroadcastEventbusService Interface
// ==================================

// Websocket broadcast event
type BroadcastEventbusService interface {
	Send(context.Context, *BroadcastEvent) (*BroadcastEventbusSendResponse, error)
}

// ========================================
// BroadcastEventbusService Protobuf Client
// ========================================

type broadcastEventbusServiceProtobufClient struct {
	client      HTTPClient
	urls        [1]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewBroadcastEventbusServiceProtobufClient creates a Protobuf client that implements the BroadcastEventbusService interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewBroadcastEventbusServiceProtobufClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) BroadcastEventbusService {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "corepb.v1", "BroadcastEventbusService")
	urls := [1]string{
		serviceURL + "Send",
	}

	return &broadcastEventbusServiceProtobufClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *broadcastEventbusServiceProtobufClient) Send(ctx context.Context, in *BroadcastEvent) (*BroadcastEventbusSendResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "BroadcastEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "Send")
	caller := c.callSend
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *BroadcastEvent) (*BroadcastEventbusSendResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BroadcastEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BroadcastEvent) when calling interceptor")
					}
					return c.callSend(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BroadcastEventbusSendResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BroadcastEventbusSendResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *broadcastEventbusServiceProtobufClient) callSend(ctx context.Context, in *BroadcastEvent) (*BroadcastEventbusSendResponse, error) {
	out := new(BroadcastEventbusSendResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ====================================
// BroadcastEventbusService JSON Client
// ====================================

type broadcastEventbusServiceJSONClient struct {
	client      HTTPClient
	urls        [1]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewBroadcastEventbusServiceJSONClient creates a JSON client that implements the BroadcastEventbusService interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewBroadcastEventbusServiceJSONClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) BroadcastEventbusService {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "corepb.v1", "BroadcastEventbusService")
	urls := [1]string{
		serviceURL + "Send",
	}

	return &broadcastEventbusServiceJSONClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *broadcastEventbusServiceJSONClient) Send(ctx context.Context, in *BroadcastEvent) (*BroadcastEventbusSendResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "BroadcastEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "Send")
	caller := c.callSend
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *BroadcastEvent) (*BroadcastEventbusSendResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BroadcastEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BroadcastEvent) when calling interceptor")
					}
					return c.callSend(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BroadcastEventbusSendResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BroadcastEventbusSendResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *broadcastEventbusServiceJSONClient) callSend(ctx context.Context, in *BroadcastEvent) (*BroadcastEventbusSendResponse, error) {
	out := new(BroadcastEventbusSendResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// =======================================
// BroadcastEventbusService Server Handler
// =======================================

type broadcastEventbusServiceServer struct {
	BroadcastEventbusService
	interceptor      twirp.Interceptor
	hooks            *twirp.ServerHooks
	pathPrefix       string // prefix for routing
	jsonSkipDefaults bool   // do not include unpopulated fields (default values) in the response
	jsonCamelCase    bool   // JSON fields are serialized as lowerCamelCase rather than keeping the original proto names
}

// NewBroadcastEventbusServiceServer builds a TwirpServer that can be used as an http.Handler to handle
// HTTP requests that are routed to the right method in the provided svc implementation.
// The opts are twirp.ServerOption modifiers, for example twirp.WithServerHooks(hooks).
func NewBroadcastEventbusServiceServer(svc BroadcastEventbusService, opts ...interface{}) TwirpServer {
	serverOpts := newServerOpts(opts)

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	jsonSkipDefaults := false
	_ = serverOpts.ReadOpt("jsonSkipDefaults", &jsonSkipDefaults)
	jsonCamelCase := false
	_ = serverOpts.ReadOpt("jsonCamelCase", &jsonCamelCase)
	var pathPrefix string
	if ok := serverOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	return &broadcastEventbusServiceServer{
		BroadcastEventbusService: svc,
		hooks:                    serverOpts.Hooks,
		interceptor:              twirp.ChainInterceptors(serverOpts.Interceptors...),
		pathPrefix:               pathPrefix,
		jsonSkipDefaults:         jsonSkipDefaults,
		jsonCamelCase:            jsonCamelCase,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *broadcastEventbusServiceServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	writeError(ctx, resp, err, s.hooks)
}

// handleRequestBodyError is used to handle error when the twirp server cannot read request
func (s *broadcastEventbusServiceServer) handleRequestBodyError(ctx context.Context, resp http.ResponseWriter, msg string, err error) {
	if context.Canceled == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.Canceled, "failed to read request: context canceled"))
		return
	}
	if context.DeadlineExceeded == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.DeadlineExceeded, "failed to read request: deadline exceeded"))
		return
	}
	s.writeError(ctx, resp, twirp.WrapError(malformedRequestError(msg), err))
}

// BroadcastEventbusServicePathPrefix is a convenience constant that may identify URL paths.
// Should be used with caution, it only matches routes generated by Twirp Go clients,
// with the default "/twirp" prefix and default CamelCase service and method names.
// More info: https://twitchtv.github.io/twirp/docs/routing.html
const BroadcastEventbusServicePathPrefix = "/twirp/corepb.v1.BroadcastEventbusService/"

func (s *broadcastEventbusServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "BroadcastEventbusService")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = callRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	// Verify path format: [<prefix>]/<package>.<Service>/<Method>
	prefix, pkgService, method := parseTwirpPath(req.URL.Path)
	if pkgService != "corepb.v1.BroadcastEventbusService" {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
	if prefix != s.pathPrefix {
		msg := fmt.Sprintf("invalid path prefix %q, expected %q, on path %q", prefix, s.pathPrefix, req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	switch method {
	case "Send":
		s.serveSend(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
}

func (s *broadcastEventbusServiceServer) serveSend(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSendJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveSendProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *broadcastEventbusServiceServer) serveSendJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "Send")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(BroadcastEvent)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.BroadcastEventbusService.Send
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *BroadcastEvent) (*BroadcastEventbusSendResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BroadcastEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BroadcastEvent) when calling interceptor")
					}
					return s.BroadcastEventbusService.Send(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BroadcastEventbusSendResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BroadcastEventbusSendResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *BroadcastEventbusSendResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *BroadcastEventbusSendResponse and nil error while calling Send. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *broadcastEventbusServiceServer) serveSendProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "Send")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(BroadcastEvent)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.BroadcastEventbusService.Send
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *BroadcastEvent) (*BroadcastEventbusSendResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*BroadcastEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*BroadcastEvent) when calling interceptor")
					}
					return s.BroadcastEventbusService.Send(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*BroadcastEventbusSendResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*BroadcastEventbusSendResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *BroadcastEventbusSendResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *BroadcastEventbusSendResponse and nil error while calling Send. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *broadcastEventbusServiceServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor4, 0
}

func (s *broadcastEventbusServiceServer) ProtocGenTwirpVersion() string {
	return "v8.1.1"
}

// PathPrefix returns the base service path, in the form: "/<prefix>/<package>.<Service>/"
// that is everything in a Twirp route except for the <Method>. This can be used for routing,
// for example to identify the requests that are targeted to this service in a mux.
func (s *broadcastEventbusServiceServer) PathPrefix() string {
	return baseServicePath(s.pathPrefix, "corepb.v1", "BroadcastEventbusService")
}

// =============================
// UserEventbusService Interface
// =============================

type UserEventbusService interface {
	UserChange(context.Context, *UserChangeEvent) (*UserEventbusUserChangeResponse, error)

	// Password change notification
	SecurityPasswordChange(context.Context, *UserSecurityEvent) (*UserEventbusSecurityPasswordChangeResponse, error)

	// Forgot password request notfication
	SecurityForgotRequest(context.Context, *UserSecurityEvent) (*UserEventbusSecurityForgotRequestResponse, error)

	// New user registration
	SecurityRegisterToken(context.Context, *UserSecurityEvent) (*UserEventbusSecurityRegisterTokenResponse, error)

	// Invite sent
	SecurityInviteToken(context.Context, *UserSecurityEvent) (*UserEventbusSecurityInviteTokenResponse, error)
}

// ===================================
// UserEventbusService Protobuf Client
// ===================================

type userEventbusServiceProtobufClient struct {
	client      HTTPClient
	urls        [5]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewUserEventbusServiceProtobufClient creates a Protobuf client that implements the UserEventbusService interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewUserEventbusServiceProtobufClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) UserEventbusService {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "corepb.v1", "UserEventbusService")
	urls := [5]string{
		serviceURL + "UserChange",
		serviceURL + "SecurityPasswordChange",
		serviceURL + "SecurityForgotRequest",
		serviceURL + "SecurityRegisterToken",
		serviceURL + "SecurityInviteToken",
	}

	return &userEventbusServiceProtobufClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *userEventbusServiceProtobufClient) UserChange(ctx context.Context, in *UserChangeEvent) (*UserEventbusUserChangeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "UserChange")
	caller := c.callUserChange
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UserChangeEvent) (*UserEventbusUserChangeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserChangeEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserChangeEvent) when calling interceptor")
					}
					return c.callUserChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusUserChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusUserChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *userEventbusServiceProtobufClient) callUserChange(ctx context.Context, in *UserChangeEvent) (*UserEventbusUserChangeResponse, error) {
	out := new(UserEventbusUserChangeResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *userEventbusServiceProtobufClient) SecurityPasswordChange(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityPasswordChangeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "SecurityPasswordChange")
	caller := c.callSecurityPasswordChange
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityPasswordChangeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return c.callSecurityPasswordChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityPasswordChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityPasswordChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *userEventbusServiceProtobufClient) callSecurityPasswordChange(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityPasswordChangeResponse, error) {
	out := new(UserEventbusSecurityPasswordChangeResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *userEventbusServiceProtobufClient) SecurityForgotRequest(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityForgotRequestResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "SecurityForgotRequest")
	caller := c.callSecurityForgotRequest
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityForgotRequestResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return c.callSecurityForgotRequest(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityForgotRequestResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityForgotRequestResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *userEventbusServiceProtobufClient) callSecurityForgotRequest(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityForgotRequestResponse, error) {
	out := new(UserEventbusSecurityForgotRequestResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[2], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *userEventbusServiceProtobufClient) SecurityRegisterToken(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityRegisterTokenResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "SecurityRegisterToken")
	caller := c.callSecurityRegisterToken
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityRegisterTokenResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return c.callSecurityRegisterToken(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityRegisterTokenResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityRegisterTokenResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *userEventbusServiceProtobufClient) callSecurityRegisterToken(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityRegisterTokenResponse, error) {
	out := new(UserEventbusSecurityRegisterTokenResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[3], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *userEventbusServiceProtobufClient) SecurityInviteToken(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityInviteTokenResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "SecurityInviteToken")
	caller := c.callSecurityInviteToken
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityInviteTokenResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return c.callSecurityInviteToken(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityInviteTokenResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityInviteTokenResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *userEventbusServiceProtobufClient) callSecurityInviteToken(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityInviteTokenResponse, error) {
	out := new(UserEventbusSecurityInviteTokenResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[4], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ===============================
// UserEventbusService JSON Client
// ===============================

type userEventbusServiceJSONClient struct {
	client      HTTPClient
	urls        [5]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewUserEventbusServiceJSONClient creates a JSON client that implements the UserEventbusService interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewUserEventbusServiceJSONClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) UserEventbusService {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "corepb.v1", "UserEventbusService")
	urls := [5]string{
		serviceURL + "UserChange",
		serviceURL + "SecurityPasswordChange",
		serviceURL + "SecurityForgotRequest",
		serviceURL + "SecurityRegisterToken",
		serviceURL + "SecurityInviteToken",
	}

	return &userEventbusServiceJSONClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *userEventbusServiceJSONClient) UserChange(ctx context.Context, in *UserChangeEvent) (*UserEventbusUserChangeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "UserChange")
	caller := c.callUserChange
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UserChangeEvent) (*UserEventbusUserChangeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserChangeEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserChangeEvent) when calling interceptor")
					}
					return c.callUserChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusUserChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusUserChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *userEventbusServiceJSONClient) callUserChange(ctx context.Context, in *UserChangeEvent) (*UserEventbusUserChangeResponse, error) {
	out := new(UserEventbusUserChangeResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *userEventbusServiceJSONClient) SecurityPasswordChange(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityPasswordChangeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "SecurityPasswordChange")
	caller := c.callSecurityPasswordChange
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityPasswordChangeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return c.callSecurityPasswordChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityPasswordChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityPasswordChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *userEventbusServiceJSONClient) callSecurityPasswordChange(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityPasswordChangeResponse, error) {
	out := new(UserEventbusSecurityPasswordChangeResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *userEventbusServiceJSONClient) SecurityForgotRequest(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityForgotRequestResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "SecurityForgotRequest")
	caller := c.callSecurityForgotRequest
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityForgotRequestResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return c.callSecurityForgotRequest(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityForgotRequestResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityForgotRequestResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *userEventbusServiceJSONClient) callSecurityForgotRequest(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityForgotRequestResponse, error) {
	out := new(UserEventbusSecurityForgotRequestResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[2], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *userEventbusServiceJSONClient) SecurityRegisterToken(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityRegisterTokenResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "SecurityRegisterToken")
	caller := c.callSecurityRegisterToken
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityRegisterTokenResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return c.callSecurityRegisterToken(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityRegisterTokenResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityRegisterTokenResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *userEventbusServiceJSONClient) callSecurityRegisterToken(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityRegisterTokenResponse, error) {
	out := new(UserEventbusSecurityRegisterTokenResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[3], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *userEventbusServiceJSONClient) SecurityInviteToken(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityInviteTokenResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "SecurityInviteToken")
	caller := c.callSecurityInviteToken
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityInviteTokenResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return c.callSecurityInviteToken(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityInviteTokenResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityInviteTokenResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *userEventbusServiceJSONClient) callSecurityInviteToken(ctx context.Context, in *UserSecurityEvent) (*UserEventbusSecurityInviteTokenResponse, error) {
	out := new(UserEventbusSecurityInviteTokenResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[4], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ==================================
// UserEventbusService Server Handler
// ==================================

type userEventbusServiceServer struct {
	UserEventbusService
	interceptor      twirp.Interceptor
	hooks            *twirp.ServerHooks
	pathPrefix       string // prefix for routing
	jsonSkipDefaults bool   // do not include unpopulated fields (default values) in the response
	jsonCamelCase    bool   // JSON fields are serialized as lowerCamelCase rather than keeping the original proto names
}

// NewUserEventbusServiceServer builds a TwirpServer that can be used as an http.Handler to handle
// HTTP requests that are routed to the right method in the provided svc implementation.
// The opts are twirp.ServerOption modifiers, for example twirp.WithServerHooks(hooks).
func NewUserEventbusServiceServer(svc UserEventbusService, opts ...interface{}) TwirpServer {
	serverOpts := newServerOpts(opts)

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	jsonSkipDefaults := false
	_ = serverOpts.ReadOpt("jsonSkipDefaults", &jsonSkipDefaults)
	jsonCamelCase := false
	_ = serverOpts.ReadOpt("jsonCamelCase", &jsonCamelCase)
	var pathPrefix string
	if ok := serverOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	return &userEventbusServiceServer{
		UserEventbusService: svc,
		hooks:               serverOpts.Hooks,
		interceptor:         twirp.ChainInterceptors(serverOpts.Interceptors...),
		pathPrefix:          pathPrefix,
		jsonSkipDefaults:    jsonSkipDefaults,
		jsonCamelCase:       jsonCamelCase,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *userEventbusServiceServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	writeError(ctx, resp, err, s.hooks)
}

// handleRequestBodyError is used to handle error when the twirp server cannot read request
func (s *userEventbusServiceServer) handleRequestBodyError(ctx context.Context, resp http.ResponseWriter, msg string, err error) {
	if context.Canceled == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.Canceled, "failed to read request: context canceled"))
		return
	}
	if context.DeadlineExceeded == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.DeadlineExceeded, "failed to read request: deadline exceeded"))
		return
	}
	s.writeError(ctx, resp, twirp.WrapError(malformedRequestError(msg), err))
}

// UserEventbusServicePathPrefix is a convenience constant that may identify URL paths.
// Should be used with caution, it only matches routes generated by Twirp Go clients,
// with the default "/twirp" prefix and default CamelCase service and method names.
// More info: https://twitchtv.github.io/twirp/docs/routing.html
const UserEventbusServicePathPrefix = "/twirp/corepb.v1.UserEventbusService/"

func (s *userEventbusServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "UserEventbusService")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = callRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	// Verify path format: [<prefix>]/<package>.<Service>/<Method>
	prefix, pkgService, method := parseTwirpPath(req.URL.Path)
	if pkgService != "corepb.v1.UserEventbusService" {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
	if prefix != s.pathPrefix {
		msg := fmt.Sprintf("invalid path prefix %q, expected %q, on path %q", prefix, s.pathPrefix, req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	switch method {
	case "UserChange":
		s.serveUserChange(ctx, resp, req)
		return
	case "SecurityPasswordChange":
		s.serveSecurityPasswordChange(ctx, resp, req)
		return
	case "SecurityForgotRequest":
		s.serveSecurityForgotRequest(ctx, resp, req)
		return
	case "SecurityRegisterToken":
		s.serveSecurityRegisterToken(ctx, resp, req)
		return
	case "SecurityInviteToken":
		s.serveSecurityInviteToken(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
}

func (s *userEventbusServiceServer) serveUserChange(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveUserChangeJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveUserChangeProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *userEventbusServiceServer) serveUserChangeJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "UserChange")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(UserChangeEvent)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.UserEventbusService.UserChange
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UserChangeEvent) (*UserEventbusUserChangeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserChangeEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserChangeEvent) when calling interceptor")
					}
					return s.UserEventbusService.UserChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusUserChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusUserChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UserEventbusUserChangeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEventbusUserChangeResponse and nil error while calling UserChange. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *userEventbusServiceServer) serveUserChangeProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "UserChange")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(UserChangeEvent)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.UserEventbusService.UserChange
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UserChangeEvent) (*UserEventbusUserChangeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserChangeEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserChangeEvent) when calling interceptor")
					}
					return s.UserEventbusService.UserChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusUserChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusUserChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UserEventbusUserChangeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEventbusUserChangeResponse and nil error while calling UserChange. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *userEventbusServiceServer) serveSecurityPasswordChange(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSecurityPasswordChangeJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveSecurityPasswordChangeProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *userEventbusServiceServer) serveSecurityPasswordChangeJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SecurityPasswordChange")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(UserSecurityEvent)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.UserEventbusService.SecurityPasswordChange
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityPasswordChangeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return s.UserEventbusService.SecurityPasswordChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityPasswordChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityPasswordChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UserEventbusSecurityPasswordChangeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEventbusSecurityPasswordChangeResponse and nil error while calling SecurityPasswordChange. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *userEventbusServiceServer) serveSecurityPasswordChangeProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SecurityPasswordChange")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(UserSecurityEvent)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.UserEventbusService.SecurityPasswordChange
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityPasswordChangeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return s.UserEventbusService.SecurityPasswordChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityPasswordChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityPasswordChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UserEventbusSecurityPasswordChangeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEventbusSecurityPasswordChangeResponse and nil error while calling SecurityPasswordChange. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *userEventbusServiceServer) serveSecurityForgotRequest(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSecurityForgotRequestJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveSecurityForgotRequestProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *userEventbusServiceServer) serveSecurityForgotRequestJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SecurityForgotRequest")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(UserSecurityEvent)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.UserEventbusService.SecurityForgotRequest
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityForgotRequestResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return s.UserEventbusService.SecurityForgotRequest(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityForgotRequestResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityForgotRequestResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UserEventbusSecurityForgotRequestResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEventbusSecurityForgotRequestResponse and nil error while calling SecurityForgotRequest. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *userEventbusServiceServer) serveSecurityForgotRequestProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SecurityForgotRequest")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(UserSecurityEvent)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.UserEventbusService.SecurityForgotRequest
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityForgotRequestResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return s.UserEventbusService.SecurityForgotRequest(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityForgotRequestResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityForgotRequestResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UserEventbusSecurityForgotRequestResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEventbusSecurityForgotRequestResponse and nil error while calling SecurityForgotRequest. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *userEventbusServiceServer) serveSecurityRegisterToken(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSecurityRegisterTokenJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveSecurityRegisterTokenProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *userEventbusServiceServer) serveSecurityRegisterTokenJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SecurityRegisterToken")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(UserSecurityEvent)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.UserEventbusService.SecurityRegisterToken
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityRegisterTokenResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return s.UserEventbusService.SecurityRegisterToken(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityRegisterTokenResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityRegisterTokenResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UserEventbusSecurityRegisterTokenResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEventbusSecurityRegisterTokenResponse and nil error while calling SecurityRegisterToken. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *userEventbusServiceServer) serveSecurityRegisterTokenProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SecurityRegisterToken")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(UserSecurityEvent)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.UserEventbusService.SecurityRegisterToken
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityRegisterTokenResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return s.UserEventbusService.SecurityRegisterToken(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityRegisterTokenResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityRegisterTokenResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UserEventbusSecurityRegisterTokenResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEventbusSecurityRegisterTokenResponse and nil error while calling SecurityRegisterToken. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *userEventbusServiceServer) serveSecurityInviteToken(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveSecurityInviteTokenJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveSecurityInviteTokenProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *userEventbusServiceServer) serveSecurityInviteTokenJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SecurityInviteToken")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(UserSecurityEvent)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.UserEventbusService.SecurityInviteToken
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityInviteTokenResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return s.UserEventbusService.SecurityInviteToken(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityInviteTokenResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityInviteTokenResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UserEventbusSecurityInviteTokenResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEventbusSecurityInviteTokenResponse and nil error while calling SecurityInviteToken. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *userEventbusServiceServer) serveSecurityInviteTokenProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "SecurityInviteToken")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(UserSecurityEvent)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.UserEventbusService.SecurityInviteToken
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *UserSecurityEvent) (*UserEventbusSecurityInviteTokenResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*UserSecurityEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*UserSecurityEvent) when calling interceptor")
					}
					return s.UserEventbusService.SecurityInviteToken(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*UserEventbusSecurityInviteTokenResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*UserEventbusSecurityInviteTokenResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *UserEventbusSecurityInviteTokenResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEventbusSecurityInviteTokenResponse and nil error while calling SecurityInviteToken. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *userEventbusServiceServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor4, 1
}

func (s *userEventbusServiceServer) ProtocGenTwirpVersion() string {
	return "v8.1.1"
}

// PathPrefix returns the base service path, in the form: "/<prefix>/<package>.<Service>/"
// that is everything in a Twirp route except for the <Method>. This can be used for routing,
// for example to identify the requests that are targeted to this service in a mux.
func (s *userEventbusServiceServer) PathPrefix() string {
	return baseServicePath(s.pathPrefix, "corepb.v1", "UserEventbusService")
}

// =============================
// TodoEventbusService Interface
// =============================

type TodoEventbusService interface {
	TodoChange(context.Context, *TodoChangeEvent) (*TodoEventbusTodoChangeResponse, error)
}

// ===================================
// TodoEventbusService Protobuf Client
// ===================================

type todoEventbusServiceProtobufClient struct {
	client      HTTPClient
	urls        [1]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewTodoEventbusServiceProtobufClient creates a Protobuf client that implements the TodoEventbusService interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewTodoEventbusServiceProtobufClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) TodoEventbusService {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "corepb.v1", "TodoEventbusService")
	urls := [1]string{
		serviceURL + "TodoChange",
	}

	return &todoEventbusServiceProtobufClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *todoEventbusServiceProtobufClient) TodoChange(ctx context.Context, in *TodoChangeEvent) (*TodoEventbusTodoChangeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "TodoEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "TodoChange")
	caller := c.callTodoChange
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *TodoChangeEvent) (*TodoEventbusTodoChangeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*TodoChangeEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*TodoChangeEvent) when calling interceptor")
					}
					return c.callTodoChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*TodoEventbusTodoChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*TodoEventbusTodoChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *todoEventbusServiceProtobufClient) callTodoChange(ctx context.Context, in *TodoChangeEvent) (*TodoEventbusTodoChangeResponse, error) {
	out := new(TodoEventbusTodoChangeResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ===============================
// TodoEventbusService JSON Client
// ===============================

type todoEventbusServiceJSONClient struct {
	client      HTTPClient
	urls        [1]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewTodoEventbusServiceJSONClient creates a JSON client that implements the TodoEventbusService interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewTodoEventbusServiceJSONClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) TodoEventbusService {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "corepb.v1", "TodoEventbusService")
	urls := [1]string{
		serviceURL + "TodoChange",
	}

	return &todoEventbusServiceJSONClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *todoEventbusServiceJSONClient) TodoChange(ctx context.Context, in *TodoChangeEvent) (*TodoEventbusTodoChangeResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "TodoEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "TodoChange")
	caller := c.callTodoChange
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *TodoChangeEvent) (*TodoEventbusTodoChangeResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*TodoChangeEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*TodoChangeEvent) when calling interceptor")
					}
					return c.callTodoChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*TodoEventbusTodoChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*TodoEventbusTodoChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *todoEventbusServiceJSONClient) callTodoChange(ctx context.Context, in *TodoChangeEvent) (*TodoEventbusTodoChangeResponse, error) {
	out := new(TodoEventbusTodoChangeResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ==================================
// TodoEventbusService Server Handler
// ==================================

type todoEventbusServiceServer struct {
	TodoEventbusService
	interceptor      twirp.Interceptor
	hooks            *twirp.ServerHooks
	pathPrefix       string // prefix for routing
	jsonSkipDefaults bool   // do not include unpopulated fields (default values) in the response
	jsonCamelCase    bool   // JSON fields are serialized as lowerCamelCase rather than keeping the original proto names
}

// NewTodoEventbusServiceServer builds a TwirpServer that can be used as an http.Handler to handle
// HTTP requests that are routed to the right method in the provided svc implementation.
// The opts are twirp.ServerOption modifiers, for example twirp.WithServerHooks(hooks).
func NewTodoEventbusServiceServer(svc TodoEventbusService, opts ...interface{}) TwirpServer {
	serverOpts := newServerOpts(opts)

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	jsonSkipDefaults := false
	_ = serverOpts.ReadOpt("jsonSkipDefaults", &jsonSkipDefaults)
	jsonCamelCase := false
	_ = serverOpts.ReadOpt("jsonCamelCase", &jsonCamelCase)
	var pathPrefix string
	if ok := serverOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	return &todoEventbusServiceServer{
		TodoEventbusService: svc,
		hooks:               serverOpts.Hooks,
		interceptor:         twirp.ChainInterceptors(serverOpts.Interceptors...),
		pathPrefix:          pathPrefix,
		jsonSkipDefaults:    jsonSkipDefaults,
		jsonCamelCase:       jsonCamelCase,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *todoEventbusServiceServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	writeError(ctx, resp, err, s.hooks)
}

// handleRequestBodyError is used to handle error when the twirp server cannot read request
func (s *todoEventbusServiceServer) handleRequestBodyError(ctx context.Context, resp http.ResponseWriter, msg string, err error) {
	if context.Canceled == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.Canceled, "failed to read request: context canceled"))
		return
	}
	if context.DeadlineExceeded == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.DeadlineExceeded, "failed to read request: deadline exceeded"))
		return
	}
	s.writeError(ctx, resp, twirp.WrapError(malformedRequestError(msg), err))
}

// TodoEventbusServicePathPrefix is a convenience constant that may identify URL paths.
// Should be used with caution, it only matches routes generated by Twirp Go clients,
// with the default "/twirp" prefix and default CamelCase service and method names.
// More info: https://twitchtv.github.io/twirp/docs/routing.html
const TodoEventbusServicePathPrefix = "/twirp/corepb.v1.TodoEventbusService/"

func (s *todoEventbusServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "TodoEventbusService")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = callRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	// Verify path format: [<prefix>]/<package>.<Service>/<Method>
	prefix, pkgService, method := parseTwirpPath(req.URL.Path)
	if pkgService != "corepb.v1.TodoEventbusService" {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
	if prefix != s.pathPrefix {
		msg := fmt.Sprintf("invalid path prefix %q, expected %q, on path %q", prefix, s.pathPrefix, req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	switch method {
	case "TodoChange":
		s.serveTodoChange(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
}

func (s *todoEventbusServiceServer) serveTodoChange(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveTodoChangeJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveTodoChangeProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *todoEventbusServiceServer) serveTodoChangeJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "TodoChange")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(TodoChangeEvent)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.TodoEventbusService.TodoChange
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *TodoChangeEvent) (*TodoEventbusTodoChangeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*TodoChangeEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*TodoChangeEvent) when calling interceptor")
					}
					return s.TodoEventbusService.TodoChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*TodoEventbusTodoChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*TodoEventbusTodoChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *TodoEventbusTodoChangeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *TodoEventbusTodoChangeResponse and nil error while calling TodoChange. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *todoEventbusServiceServer) serveTodoChangeProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "TodoChange")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(TodoChangeEvent)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.TodoEventbusService.TodoChange
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *TodoChangeEvent) (*TodoEventbusTodoChangeResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*TodoChangeEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*TodoChangeEvent) when calling interceptor")
					}
					return s.TodoEventbusService.TodoChange(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*TodoEventbusTodoChangeResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*TodoEventbusTodoChangeResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *TodoEventbusTodoChangeResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *TodoEventbusTodoChangeResponse and nil error while calling TodoChange. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *todoEventbusServiceServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor4, 2
}

func (s *todoEventbusServiceServer) ProtocGenTwirpVersion() string {
	return "v8.1.1"
}

// PathPrefix returns the base service path, in the form: "/<prefix>/<package>.<Service>/"
// that is everything in a Twirp route except for the <Method>. This can be used for routing,
// for example to identify the requests that are targeted to this service in a mux.
func (s *todoEventbusServiceServer) PathPrefix() string {
	return baseServicePath(s.pathPrefix, "corepb.v1", "TodoEventbusService")
}

// =============================
// FileEventbusService Interface
// =============================

type FileEventbusService interface {
	FileUploaded(context.Context, *FileServiceUploadEvent) (*FileEventbusFileUploadedResponse, error)

	FileComplete(context.Context, *FileServiceCompleteEvent) (*FileEventbusFileCompleteResponse, error)
}

// ===================================
// FileEventbusService Protobuf Client
// ===================================

type fileEventbusServiceProtobufClient struct {
	client      HTTPClient
	urls        [2]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewFileEventbusServiceProtobufClient creates a Protobuf client that implements the FileEventbusService interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewFileEventbusServiceProtobufClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) FileEventbusService {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "corepb.v1", "FileEventbusService")
	urls := [2]string{
		serviceURL + "FileUploaded",
		serviceURL + "FileComplete",
	}

	return &fileEventbusServiceProtobufClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *fileEventbusServiceProtobufClient) FileUploaded(ctx context.Context, in *FileServiceUploadEvent) (*FileEventbusFileUploadedResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "FileEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "FileUploaded")
	caller := c.callFileUploaded
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *FileServiceUploadEvent) (*FileEventbusFileUploadedResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FileServiceUploadEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FileServiceUploadEvent) when calling interceptor")
					}
					return c.callFileUploaded(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FileEventbusFileUploadedResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FileEventbusFileUploadedResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *fileEventbusServiceProtobufClient) callFileUploaded(ctx context.Context, in *FileServiceUploadEvent) (*FileEventbusFileUploadedResponse, error) {
	out := new(FileEventbusFileUploadedResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *fileEventbusServiceProtobufClient) FileComplete(ctx context.Context, in *FileServiceCompleteEvent) (*FileEventbusFileCompleteResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "FileEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "FileComplete")
	caller := c.callFileComplete
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *FileServiceCompleteEvent) (*FileEventbusFileCompleteResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FileServiceCompleteEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FileServiceCompleteEvent) when calling interceptor")
					}
					return c.callFileComplete(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FileEventbusFileCompleteResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FileEventbusFileCompleteResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *fileEventbusServiceProtobufClient) callFileComplete(ctx context.Context, in *FileServiceCompleteEvent) (*FileEventbusFileCompleteResponse, error) {
	out := new(FileEventbusFileCompleteResponse)
	ctx, err := doProtobufRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ===============================
// FileEventbusService JSON Client
// ===============================

type fileEventbusServiceJSONClient struct {
	client      HTTPClient
	urls        [2]string
	interceptor twirp.Interceptor
	opts        twirp.ClientOptions
}

// NewFileEventbusServiceJSONClient creates a JSON client that implements the FileEventbusService interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewFileEventbusServiceJSONClient(baseURL string, client HTTPClient, opts ...twirp.ClientOption) FileEventbusService {
	if c, ok := client.(*http.Client); ok {
		client = withoutRedirects(c)
	}

	clientOpts := twirp.ClientOptions{}
	for _, o := range opts {
		o(&clientOpts)
	}

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	literalURLs := false
	_ = clientOpts.ReadOpt("literalURLs", &literalURLs)
	var pathPrefix string
	if ok := clientOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	// Build method URLs: <baseURL>[<prefix>]/<package>.<Service>/<Method>
	serviceURL := sanitizeBaseURL(baseURL)
	serviceURL += baseServicePath(pathPrefix, "corepb.v1", "FileEventbusService")
	urls := [2]string{
		serviceURL + "FileUploaded",
		serviceURL + "FileComplete",
	}

	return &fileEventbusServiceJSONClient{
		client:      client,
		urls:        urls,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		opts:        clientOpts,
	}
}

func (c *fileEventbusServiceJSONClient) FileUploaded(ctx context.Context, in *FileServiceUploadEvent) (*FileEventbusFileUploadedResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "FileEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "FileUploaded")
	caller := c.callFileUploaded
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *FileServiceUploadEvent) (*FileEventbusFileUploadedResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FileServiceUploadEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FileServiceUploadEvent) when calling interceptor")
					}
					return c.callFileUploaded(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FileEventbusFileUploadedResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FileEventbusFileUploadedResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *fileEventbusServiceJSONClient) callFileUploaded(ctx context.Context, in *FileServiceUploadEvent) (*FileEventbusFileUploadedResponse, error) {
	out := new(FileEventbusFileUploadedResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[0], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

func (c *fileEventbusServiceJSONClient) FileComplete(ctx context.Context, in *FileServiceCompleteEvent) (*FileEventbusFileCompleteResponse, error) {
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "FileEventbusService")
	ctx = ctxsetters.WithMethodName(ctx, "FileComplete")
	caller := c.callFileComplete
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *FileServiceCompleteEvent) (*FileEventbusFileCompleteResponse, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FileServiceCompleteEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FileServiceCompleteEvent) when calling interceptor")
					}
					return c.callFileComplete(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FileEventbusFileCompleteResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FileEventbusFileCompleteResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}
	return caller(ctx, in)
}

func (c *fileEventbusServiceJSONClient) callFileComplete(ctx context.Context, in *FileServiceCompleteEvent) (*FileEventbusFileCompleteResponse, error) {
	out := new(FileEventbusFileCompleteResponse)
	ctx, err := doJSONRequest(ctx, c.client, c.opts.Hooks, c.urls[1], in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		callClientError(ctx, c.opts.Hooks, twerr)
		return nil, err
	}

	callClientResponseReceived(ctx, c.opts.Hooks)

	return out, nil
}

// ==================================
// FileEventbusService Server Handler
// ==================================

type fileEventbusServiceServer struct {
	FileEventbusService
	interceptor      twirp.Interceptor
	hooks            *twirp.ServerHooks
	pathPrefix       string // prefix for routing
	jsonSkipDefaults bool   // do not include unpopulated fields (default values) in the response
	jsonCamelCase    bool   // JSON fields are serialized as lowerCamelCase rather than keeping the original proto names
}

// NewFileEventbusServiceServer builds a TwirpServer that can be used as an http.Handler to handle
// HTTP requests that are routed to the right method in the provided svc implementation.
// The opts are twirp.ServerOption modifiers, for example twirp.WithServerHooks(hooks).
func NewFileEventbusServiceServer(svc FileEventbusService, opts ...interface{}) TwirpServer {
	serverOpts := newServerOpts(opts)

	// Using ReadOpt allows backwards and forwads compatibility with new options in the future
	jsonSkipDefaults := false
	_ = serverOpts.ReadOpt("jsonSkipDefaults", &jsonSkipDefaults)
	jsonCamelCase := false
	_ = serverOpts.ReadOpt("jsonCamelCase", &jsonCamelCase)
	var pathPrefix string
	if ok := serverOpts.ReadOpt("pathPrefix", &pathPrefix); !ok {
		pathPrefix = "/twirp" // default prefix
	}

	return &fileEventbusServiceServer{
		FileEventbusService: svc,
		hooks:               serverOpts.Hooks,
		interceptor:         twirp.ChainInterceptors(serverOpts.Interceptors...),
		pathPrefix:          pathPrefix,
		jsonSkipDefaults:    jsonSkipDefaults,
		jsonCamelCase:       jsonCamelCase,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *fileEventbusServiceServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	writeError(ctx, resp, err, s.hooks)
}

// handleRequestBodyError is used to handle error when the twirp server cannot read request
func (s *fileEventbusServiceServer) handleRequestBodyError(ctx context.Context, resp http.ResponseWriter, msg string, err error) {
	if context.Canceled == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.Canceled, "failed to read request: context canceled"))
		return
	}
	if context.DeadlineExceeded == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.DeadlineExceeded, "failed to read request: deadline exceeded"))
		return
	}
	s.writeError(ctx, resp, twirp.WrapError(malformedRequestError(msg), err))
}

// FileEventbusServicePathPrefix is a convenience constant that may identify URL paths.
// Should be used with caution, it only matches routes generated by Twirp Go clients,
// with the default "/twirp" prefix and default CamelCase service and method names.
// More info: https://twitchtv.github.io/twirp/docs/routing.html
const FileEventbusServicePathPrefix = "/twirp/corepb.v1.FileEventbusService/"

func (s *fileEventbusServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "corepb.v1")
	ctx = ctxsetters.WithServiceName(ctx, "FileEventbusService")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = callRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	// Verify path format: [<prefix>]/<package>.<Service>/<Method>
	prefix, pkgService, method := parseTwirpPath(req.URL.Path)
	if pkgService != "corepb.v1.FileEventbusService" {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
	if prefix != s.pathPrefix {
		msg := fmt.Sprintf("invalid path prefix %q, expected %q, on path %q", prefix, s.pathPrefix, req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}

	switch method {
	case "FileUploaded":
		s.serveFileUploaded(ctx, resp, req)
		return
	case "FileComplete":
		s.serveFileComplete(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))
		return
	}
}

func (s *fileEventbusServiceServer) serveFileUploaded(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveFileUploadedJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveFileUploadedProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *fileEventbusServiceServer) serveFileUploadedJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "FileUploaded")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(FileServiceUploadEvent)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.FileEventbusService.FileUploaded
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *FileServiceUploadEvent) (*FileEventbusFileUploadedResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FileServiceUploadEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FileServiceUploadEvent) when calling interceptor")
					}
					return s.FileEventbusService.FileUploaded(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FileEventbusFileUploadedResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FileEventbusFileUploadedResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *FileEventbusFileUploadedResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *FileEventbusFileUploadedResponse and nil error while calling FileUploaded. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *fileEventbusServiceServer) serveFileUploadedProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "FileUploaded")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(FileServiceUploadEvent)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.FileEventbusService.FileUploaded
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *FileServiceUploadEvent) (*FileEventbusFileUploadedResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FileServiceUploadEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FileServiceUploadEvent) when calling interceptor")
					}
					return s.FileEventbusService.FileUploaded(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FileEventbusFileUploadedResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FileEventbusFileUploadedResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *FileEventbusFileUploadedResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *FileEventbusFileUploadedResponse and nil error while calling FileUploaded. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *fileEventbusServiceServer) serveFileComplete(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveFileCompleteJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveFileCompleteProtobuf(ctx, resp, req)
	default:
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, twerr)
	}
}

func (s *fileEventbusServiceServer) serveFileCompleteJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "FileComplete")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	d := json.NewDecoder(req.Body)
	rawReqBody := json.RawMessage{}
	if err := d.Decode(&rawReqBody); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}
	reqContent := new(FileServiceCompleteEvent)
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(rawReqBody, reqContent); err != nil {
		s.handleRequestBodyError(ctx, resp, "the json request could not be decoded", err)
		return
	}

	handler := s.FileEventbusService.FileComplete
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *FileServiceCompleteEvent) (*FileEventbusFileCompleteResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FileServiceCompleteEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FileServiceCompleteEvent) when calling interceptor")
					}
					return s.FileEventbusService.FileComplete(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FileEventbusFileCompleteResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FileEventbusFileCompleteResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *FileEventbusFileCompleteResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *FileEventbusFileCompleteResponse and nil error while calling FileComplete. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	marshaler := &protojson.MarshalOptions{UseProtoNames: !s.jsonCamelCase, EmitUnpopulated: !s.jsonSkipDefaults}
	respBytes, err := marshaler.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal json response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/json")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *fileEventbusServiceServer) serveFileCompleteProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = ctxsetters.WithMethodName(ctx, "FileComplete")
	ctx, err = callRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.handleRequestBodyError(ctx, resp, "failed to read request body", err)
		return
	}
	reqContent := new(FileServiceCompleteEvent)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		s.writeError(ctx, resp, malformedRequestError("the protobuf request could not be decoded"))
		return
	}

	handler := s.FileEventbusService.FileComplete
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *FileServiceCompleteEvent) (*FileEventbusFileCompleteResponse, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*FileServiceCompleteEvent)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*FileServiceCompleteEvent) when calling interceptor")
					}
					return s.FileEventbusService.FileComplete(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*FileEventbusFileCompleteResponse)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*FileEventbusFileCompleteResponse) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	// Call service method
	var respContent *FileEventbusFileCompleteResponse
	func() {
		defer ensurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *FileEventbusFileCompleteResponse and nil error while calling FileComplete. nil responses are not supported"))
		return
	}

	ctx = callResponsePrepared(ctx, s.hooks)

	respBytes, err := proto.Marshal(respContent)
	if err != nil {
		s.writeError(ctx, resp, wrapInternal(err, "failed to marshal proto response"))
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header().Set("Content-Type", "application/protobuf")
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBytes)))
	resp.WriteHeader(http.StatusOK)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = callError(ctx, s.hooks, twerr)
	}
	callResponseSent(ctx, s.hooks)
}

func (s *fileEventbusServiceServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor4, 3
}

func (s *fileEventbusServiceServer) ProtocGenTwirpVersion() string {
	return "v8.1.1"
}

// PathPrefix returns the base service path, in the form: "/<prefix>/<package>.<Service>/"
// that is everything in a Twirp route except for the <Method>. This can be used for routing,
// for example to identify the requests that are targeted to this service in a mux.
func (s *fileEventbusServiceServer) PathPrefix() string {
	return baseServicePath(s.pathPrefix, "corepb.v1", "FileEventbusService")
}

var twirpFileDescriptor4 = []byte{
	// 455 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x85, 0x54, 0x21, 0x31, 0x50, 0x21, 0xad, 0x01, 0xb5, 0x11, 0x94, 0x60, 0x0e, 0x10,
	0x8a, 0x1c, 0xc5, 0xc0, 0x89, 0x5b, 0xab, 0x56, 0x42, 0x5c, 0x50, 0xd2, 0x5e, 0x38, 0x20, 0xfc,
	0x67, 0x30, 0x26, 0x8e, 0xc7, 0xec, 0xae, 0x5d, 0xf5, 0x5d, 0x78, 0x2f, 0x5e, 0x07, 0x99, 0xcd,
	0xda, 0x6b, 0x77, 0x63, 0x1f, 0x7a, 0x5b, 0xcd, 0xf7, 0xf3, 0x7c, 0xf6, 0xce, 0x37, 0x86, 0x83,
	0x88, 0x38, 0x16, 0xe1, 0xbc, 0x5a, 0xcc, 0xb1, 0xc2, 0x5c, 0x86, 0xa5, 0xf0, 0x0a, 0x4e, 0x92,
	0xd8, 0x3d, 0xa5, 0x78, 0xd5, 0x62, 0xf2, 0xa8, 0x85, 0x4a, 0x81, 0x5c, 0x01, 0x66, 0x55, 0x52,
	0x4c, 0x37, 0xab, 0x3f, 0xd2, 0x0c, 0xb7, 0xd5, 0xc3, 0xb6, 0x7a, 0x85, 0xa1, 0xa0, 0x68, 0x8d,
	0x52, 0x49, 0xee, 0x43, 0xd8, 0x3f, 0xdb, 0x3a, 0x9f, 0x6d, 0x0a, 0x79, 0xed, 0x3e, 0x87, 0x67,
	0x27, 0x9c, 0x82, 0x38, 0x0a, 0x84, 0xd4, 0xca, 0x0a, 0xf3, 0x78, 0x89, 0xa2, 0xa0, 0x5c, 0xa0,
	0x3b, 0x85, 0xa3, 0x4b, 0x81, 0x5c, 0x6b, 0xf5, 0xf9, 0xf4, 0x67, 0x90, 0x27, 0xd8, 0x10, 0x6f,
	0xe1, 0x8d, 0x49, 0xac, 0x30, 0x2a, 0x79, 0x2a, 0xaf, 0xbf, 0x04, 0x42, 0x5c, 0x11, 0x8f, 0x7b,
	0xf4, 0x31, 0xcc, 0x6c, 0xf4, 0x39, 0xf1, 0x84, 0xe4, 0x12, 0x7f, 0x97, 0x28, 0xe4, 0x18, 0xbc,
	0xc4, 0x24, 0x15, 0x12, 0xf9, 0x05, 0xad, 0x31, 0x6f, 0xe0, 0x19, 0xbc, 0xb2, 0xc1, 0x9f, 0xf2,
	0x2a, 0x95, 0xd8, 0x45, 0xa7, 0x70, 0x74, 0x41, 0x31, 0x69, 0xb4, 0x3e, 0xf7, 0x5e, 0xd3, 0x85,
	0xe9, 0x79, 0x9a, 0xa1, 0x26, 0xea, 0xf3, 0x65, 0x91, 0x51, 0x10, 0x63, 0x3c, 0xc4, 0x9c, 0xd2,
	0xa6, 0xc8, 0x50, 0x36, 0x7d, 0xfc, 0x04, 0x0e, 0x2c, 0xf7, 0xcb, 0xab, 0x34, 0x42, 0xf6, 0x19,
	0xf6, 0xea, 0xab, 0x66, 0x87, 0x5e, 0x33, 0x7d, 0xaf, 0x0b, 0x4f, 0x5e, 0xef, 0x94, 0x7a, 0x73,
	0xf2, 0xff, 0xec, 0x81, 0xd3, 0xfd, 0x7c, 0x65, 0xb2, 0x02, 0x68, 0x67, 0xc6, 0x26, 0x46, 0xbf,
	0xb6, 0xac, 0xbc, 0x66, 0x3d, 0x6d, 0xf7, 0xc8, 0xd9, 0x06, 0x9e, 0xd8, 0xc7, 0xcc, 0x9e, 0xf6,
	0x9a, 0x68, 0x4c, 0x59, 0x7c, 0xd8, 0x61, 0x31, 0x9c, 0x19, 0xb6, 0x86, 0xc7, 0xd6, 0x9c, 0x8c,
	0xb8, 0xbd, 0x1f, 0x71, 0xb3, 0x66, 0xce, 0x34, 0xeb, 0xe4, 0xec, 0x96, 0x66, 0xd6, 0xcc, 0xb2,
	0x04, 0x1c, 0x4b, 0x4e, 0x47, 0xac, 0xfc, 0x11, 0x2b, 0x4b, 0xe2, 0xfd, 0x5f, 0xe0, 0x98, 0x89,
	0x37, 0xd2, 0xd1, 0x86, 0xbf, 0x93, 0x8e, 0xb6, 0x7c, 0x33, 0x1d, 0xc3, 0xbb, 0xe3, 0xff, 0xbd,
	0x03, 0x8e, 0xb9, 0x18, 0xda, 0xec, 0x1b, 0x3c, 0x30, 0xf7, 0x88, 0xbd, 0x30, 0x5a, 0xd6, 0xc2,
	0x96, 0x53, 0xba, 0x72, 0x3d, 0xee, 0x21, 0x43, 0xfb, 0xc8, 0xbe, 0xab, 0xfe, 0x7a, 0x07, 0xd9,
	0x4b, 0x7b, 0x7f, 0xad, 0x8f, 0x3b, 0xf4, 0xb7, 0xf9, 0x64, 0xff, 0xeb, 0x7d, 0x6f, 0xfe, 0x51,
	0x3d, 0x50, 0x2d, 0xc2, 0xbb, 0xff, 0x7f, 0xaa, 0xef, 0xfe, 0x05, 0x00, 0x00, 0xff, 0xff, 0x30,
	0x1f, 0x46, 0x95, 0xd8, 0x05, 0x00, 0x00,
}
